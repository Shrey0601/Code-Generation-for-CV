{"nl": "resize an image", "code": "def resize(img, scale):\n    return cv2.resize(img, None, fx=scale, fy=scale, interpolation=cv2.INTER_CUBIC)"}
{"nl": "enlarge a picture to twice its size ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "enlarge a picture to twice its size ", "code": "def resize_image(image):\n    \n    \n    width, height = image.size\n    new_width = width * 2\n    new_height = height * 2\n    new_image = Image.new('RGB', (new_width, new_height))\n    for x in range(new_width):\n        for y in range(new_height):\n            new_image.putpixel((x, y), image.getpixel((x // 2, y // 2)))\n    return new_image"}
{"nl": "enlarge a picture to twice its size ", "code": "def resize_image(image):\n    width, height = image.size\n\n    result = Image.new(image.mode, (width * 2, height * 2))\n\n    for x in range(width):\n        for y in range(height):\n            pixel = image.getpixel((x, y))\n\n            result.putpixel((x * 2, y * 2), pixel)\n            result.putpixel((x * 2 + 1, y * 2), pixel)\n            result.putpixel((x * 2, y * 2 + 1), pixel)\n            result.putpixel((x * 2 + 1, y * 2 + 1), pixel)\n\n    return result\n"}
{"nl": "enlarge a picture to twice its size ", "code": "def resize_image(image):\n   \n    return image.resize((image.size[0] * 2, image.size[1] * 2))\n"}
{"nl": "enlarge a picture to twice its size ", "code": "def resize_image(image):\n    img = np.asarray(image)\n    x,y,z = img.shape\n    img2 = np.zeros((x*2,y*2,z))\n    for i in range(x):\n        for j in range(y):\n            for k in range(z):\n                img2[2*i,2*j,k] = img[i,j,k]\n                img2[2*i+1,2*j,k] = img[i,j,k]\n                img2[2*i,2*j+1,k] = img[i,j,k]\n                img2[2*i+1,2*j+1,k] = img[i,j,k]\n    return img2\n"}
{"nl": "enlarge a picture to twice its size ", "code": "def resize_image(image):\n   \n    img = img.resize((img.size[0]*2, img.size[1]*2))\n    return img\n"}
{"nl": "enlarge a picture to twice its size ", "code": "def resize_image(img):\n        (h,w) = img.shape[:2]\n\n        output = np.zeros((2*h,2*w), dtype = \"uint8\")\n\n        for i in range(0,h):\n                for j in range(0,w):\n                        pixel = img[i,j]\n                        output[2*i,2*j] = pixel\n                        output[2*i+1,2*j] = pixel\n                        output[2*i,2*j+1] = pixel\n                        output[2*i+1,2*j+1] = pixel\n\n        return output"}
{"nl": "enlarge an image to double its size ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "enlarge an image to double its size ", "code": "def resize_image(image):\n   \n    width, height = image.size\n    new_width = width * 2\n    new_height = height * 2\n    new_image = Image.new('RGB', (new_width, new_height))\n    for x in range(new_width):\n        for y in range(new_height):\n            new_image.putpixel((x, y), image.getpixel((x // 2, y // 2)))\n    return new_image\n"}
{"nl": "enlarge an image to double its size ", "code": "def resize_image(image):\n    width, height = image.size\n\n    result = Image.new(image.mode, (width * 2, height * 2))\n\n    for x in range(width):\n        for y in range(height):\n            pixel = image.getpixel((x, y))\n\n            result.putpixel((x * 2, y * 2), pixel)\n            result.putpixel((x * 2 + 1, y * 2), pixel)\n            result.putpixel((x * 2, y * 2 + 1), pixel)\n            result.putpixel((x * 2 + 1, y * 2 + 1), pixel)\n\n    return result\n"}
{"nl": "enlarge an image to double its size ", "code": "def resize_image(img):\n        (h,w) = img.shape[:2]\n\n        output = np.zeros((2*h,2*w), dtype = \"uint8\")\n\n        for i in range(0,h):\n                for j in range(0,w):\n                        pixel = img[i,j]\n                        output[2*i,2*j] = pixel\n                        output[2*i+1,2*j] = pixel\n                        output[2*i,2*j+1] = pixel\n                        output[2*i+1,2*j+1] = pixel\n\n        return output"}
{"nl": "resize an image to double its shape", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "resize an image to double its shape", "code": "def resize_image(image):\n   \n    width, height = image.size\n    new_width = width * 2\n    new_height = height * 2\n    new_image = Image.new('RGB', (new_width, new_height))\n    for x in range(new_width):\n        for y in range(new_height):\n            new_image.putpixel((x, y), image.getpixel((x // 2, y // 2)))\n    return new_image\n"}
{"nl": "resize an image to double its shape", "code": "def resize_image(image):\n    width, height = image.size\n\n    result = Image.new(image.mode, (width * 2, height * 2))\n\n    for x in range(width):\n        for y in range(height):\n            pixel = image.getpixel((x, y))\n\n            result.putpixel((x * 2, y * 2), pixel)\n            result.putpixel((x * 2 + 1, y * 2), pixel)\n            result.putpixel((x * 2, y * 2 + 1), pixel)\n            result.putpixel((x * 2 + 1, y * 2 + 1), pixel)\n\n    return result\n"}
{"nl": "resize an image to double its shape", "code": "def resize_image(image):\n   \n    return image.resize((image.size[0] * 2, image.size[1] * 2))\n"}
{"nl": "resize an image to double its shape", "code": "def resize_image(img):\n        (h,w) = img.shape[:2]\n\n        output = np.zeros((2*h,2*w), dtype = \"uint8\")\n\n        for i in range(0,h):\n                for j in range(0,w):\n                        pixel = img[i,j]\n                        output[2*i,2*j] = pixel\n                        output[2*i+1,2*j] = pixel\n                        output[2*i,2*j+1] = pixel\n                        output[2*i+1,2*j+1] = pixel\n\n        return output"}
{"nl": "resize a picture to twice its size ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "resize a picture to twice its size ", "code": "def resize_image(image):\n   \n    width, height = image.size\n    new_width = width * 2\n    new_height = height * 2\n    new_image = Image.new('RGB', (new_width, new_height))\n    for x in range(new_width):\n        for y in range(new_height):\n            new_image.putpixel((x, y), image.getpixel((x // 2, y // 2)))\n    return new_image\n"}
{"nl": "resize a picture to twice its size ", "code": "def resize_image(image):\n    width, height = image.size\n\n    result = Image.new(image.mode, (width * 2, height * 2))\n\n    for x in range(width):\n        for y in range(height):\n            pixel = image.getpixel((x, y))\n\n            result.putpixel((x * 2, y * 2), pixel)\n            result.putpixel((x * 2 + 1, y * 2), pixel)\n            result.putpixel((x * 2, y * 2 + 1), pixel)\n            result.putpixel((x * 2 + 1, y * 2 + 1), pixel)\n\n    return result\n"}
{"nl": "resize a picture to twice its size ", "code": "def resize_image(image):\n   \n    return image.resize((image.size[0] * 2, image.size[1] * 2))\n"}
{"nl": "resize a picture to twice its size ", "code": "def resize_image(img):\n        (h,w) = img.shape[:2]\n\n        output = np.zeros((2*h,2*w), dtype = \"uint8\")\n\n        for i in range(0,h):\n                for j in range(0,w):\n                        pixel = img[i,j]\n                        output[2*i,2*j] = pixel\n                        output[2*i+1,2*j] = pixel\n                        output[2*i,2*j+1] = pixel\n                        output[2*i+1,2*j+1] = pixel\n\n        return output"}
{"nl": "twice the size of a picture ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "twice the size of a picture ", "code": "def resize_image(image):\n   \n    width, height = image.size\n    new_width = width * 2\n    new_height = height * 2\n    new_image = Image.new('RGB', (new_width, new_height))\n    for x in range(new_width):\n        for y in range(new_height):\n            new_image.putpixel((x, y), image.getpixel((x // 2, y // 2)))\n    return new_image\n"}
{"nl": "twice the size of a picture ", "code": "def resize_image(image):\n    width, height = image.size\n\n    result = Image.new(image.mode, (width * 2, height * 2))\n\n    for x in range(width):\n        for y in range(height):\n            pixel = image.getpixel((x, y))\n\n            result.putpixel((x * 2, y * 2), pixel)\n            result.putpixel((x * 2 + 1, y * 2), pixel)\n            result.putpixel((x * 2, y * 2 + 1), pixel)\n            result.putpixel((x * 2 + 1, y * 2 + 1), pixel)\n\n    return result\n"}
{"nl": "twice the size of a picture ", "code": "def resize_image(image):\n   \n    return image.resize((image.size[0] * 2, image.size[1] * 2))\n"}
{"nl": "twice the size of a picture ", "code": "def resize_image(img):\n        (h,w) = img.shape[:2]\n\n        output = np.zeros((2*h,2*w), dtype = \"uint8\")\n\n        for i in range(0,h):\n                for j in range(0,w):\n                        pixel = img[i,j]\n                        output[2*i,2*j] = pixel\n                        output[2*i+1,2*j] = pixel\n                        output[2*i,2*j+1] = pixel\n                        output[2*i+1,2*j+1] = pixel\n\n        return output"}
{"nl": "To double an image's shape, enlarge it. ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "To double an image's shape, enlarge it. ", "code": "def resize_image(image):\n   \n    width, height = image.size\n    new_width = width * 2\n    new_height = height * 2\n    new_image = Image.new('RGB', (new_width, new_height))\n    for x in range(new_width):\n        for y in range(new_height):\n            new_image.putpixel((x, y), image.getpixel((x // 2, y // 2)))\n    return new_image\n"}
{"nl": "To double an image's shape, enlarge it. ", "code": "def resize_image(image):\n    width, height = image.size\n\n    result = Image.new(image.mode, (width * 2, height * 2))\n\n    for x in range(width):\n        for y in range(height):\n            pixel = image.getpixel((x, y))\n\n            result.putpixel((x * 2, y * 2), pixel)\n            result.putpixel((x * 2 + 1, y * 2), pixel)\n            result.putpixel((x * 2, y * 2 + 1), pixel)\n            result.putpixel((x * 2 + 1, y * 2 + 1), pixel)\n\n    return result\n"}
{"nl": "To double an image's shape, enlarge it. ", "code": "def resize_image(image):\n   \n    return image.resize((image.size[0] * 2, image.size[1] * 2))\n"}
{"nl": "To double an image's shape, enlarge it. ", "code": "def resize_image(img):\n        (h,w) = img.shape[:2]\n\n        output = np.zeros((2*h,2*w), dtype = \"uint8\")\n\n        for i in range(0,h):\n                for j in range(0,w):\n                        pixel = img[i,j]\n                        output[2*i,2*j] = pixel\n                        output[2*i+1,2*j] = pixel\n                        output[2*i,2*j+1] = pixel\n                        output[2*i+1,2*j+1] = pixel\n\n        return output"}
{"nl": "Double the size of a picture. ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "Double the size of a picture. ", "code": "def resize_image(image):\n   \n    width, height = image.size\n    new_width = width * 2\n    new_height = height * 2\n    new_image = Image.new('RGB', (new_width, new_height))\n    for x in range(new_width):\n        for y in range(new_height):\n            new_image.putpixel((x, y), image.getpixel((x // 2, y // 2)))\n    return new_image\n"}
{"nl": "Double the size of a picture. ", "code": "def resize_image(image):\n    width, height = image.size\n\n    result = Image.new(image.mode, (width * 2, height * 2))\n\n    for x in range(width):\n        for y in range(height):\n            pixel = image.getpixel((x, y))\n\n            result.putpixel((x * 2, y * 2), pixel)\n            result.putpixel((x * 2 + 1, y * 2), pixel)\n            result.putpixel((x * 2, y * 2 + 1), pixel)\n            result.putpixel((x * 2 + 1, y * 2 + 1), pixel)\n\n    return result\n"}
{"nl": "Double the size of a picture. ", "code": "def resize_image(image):\n   \n    return image.resize((image.size[0] * 2, image.size[1] * 2))\n"}
{"nl": "Double the size of a picture. ", "code": "def resize_image(img):\n        (h,w) = img.shape[:2]\n\n        output = np.zeros((2*h,2*w), dtype = \"uint8\")\n\n        for i in range(0,h):\n                for j in range(0,w):\n                        pixel = img[i,j]\n                        output[2*i,2*j] = pixel\n                        output[2*i+1,2*j] = pixel\n                        output[2*i,2*j+1] = pixel\n                        output[2*i+1,2*j+1] = pixel\n\n        return output"}
{"nl": "enlarge a photo so that it's twice as big. ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "enlarge a photo so that it's twice as big. ", "code": "def resize_image(image):\n   \n    width, height = image.size\n    new_width = width * 2\n    new_height = height * 2\n    new_image = Image.new('RGB', (new_width, new_height))\n    for x in range(new_width):\n        for y in range(new_height):\n            new_image.putpixel((x, y), image.getpixel((x // 2, y // 2)))\n    return new_image\n"}
{"nl": "enlarge a photo so that it's twice as big. ", "code": "def resize_image(image):\n    width, height = image.size\n\n    result = Image.new(image.mode, (width * 2, height * 2))\n\n    for x in range(width):\n        for y in range(height):\n            pixel = image.getpixel((x, y))\n\n            result.putpixel((x * 2, y * 2), pixel)\n            result.putpixel((x * 2 + 1, y * 2), pixel)\n            result.putpixel((x * 2, y * 2 + 1), pixel)\n            result.putpixel((x * 2 + 1, y * 2 + 1), pixel)\n\n    return result\n"}
{"nl": "enlarge a photo so that it's twice as big. ", "code": "def resize_image(image):\n   \n    return image.resize((image.size[0] * 2, image.size[1] * 2))\n"}
{"nl": "enlarge a photo so that it's twice as big. ", "code": "def resize_image(img):\n        (h,w) = img.shape[:2]\n\n        output = np.zeros((2*h,2*w), dtype = \"uint8\")\n\n        for i in range(0,h):\n                for j in range(0,w):\n                        pixel = img[i,j]\n                        output[2*i,2*j] = pixel\n                        output[2*i+1,2*j] = pixel\n                        output[2*i,2*j+1] = pixel\n                        output[2*i+1,2*j+1] = pixel\n\n        return output"}
{"nl": "the photo will need to be resized to be twice as big. ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "the photo will need to be resized to be twice as big.  ", "code": "def resize_image(image):\n    \n    \n    width, height = image.size\n    new_width = width * 2\n    new_height = height * 2\n    new_image = Image.new('RGB', (new_width, new_height))\n    for x in range(new_width):\n        for y in range(new_height):\n            new_image.putpixel((x, y), image.getpixel((x // 2, y // 2)))\n    return new_image"}
{"nl": "the photo will need to be resized to be twice as big.  ", "code": "def resize_image(image):\n    width, height = image.size\n\n    result = Image.new(image.mode, (width * 2, height * 2))\n\n    for x in range(width):\n        for y in range(height):\n            pixel = image.getpixel((x, y))\n\n            result.putpixel((x * 2, y * 2), pixel)\n            result.putpixel((x * 2 + 1, y * 2), pixel)\n            result.putpixel((x * 2, y * 2 + 1), pixel)\n            result.putpixel((x * 2 + 1, y * 2 + 1), pixel)\n\n    return result\n "}
{"nl": "the photo will need to be resized to be twice as big.  ", "code": "def resize_image(image):\n    \n    \n    return image.resize((image.size[0] * 2, image.size[1] * 2))\n "}
{"nl": " the photo will need to be resized to be twice as big. ", "code": "def resize_image(img):\n        (h,w) = img.shape[:2]\n\n        output = np.zeros((2*h,2*w), dtype = \"uint8\")\n\n        for i in range(0,h):\n                for j in range(0,w):\n                        pixel = img[i,j]\n                        output[2*i,2*j] = pixel\n                        output[2*i+1,2*j] = pixel\n                        output[2*i,2*j+1] = pixel\n                        output[2*i+1,2*j+1] = pixel\n\n        return output "}
{"nl": "2x the initial image shape", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "2x the initial image shape", "code": "def resize_image(image):\n    \n    \n    width, height = image.size\n    new_width = width * 2\n    new_height = height * 2\n    new_image = Image.new('RGB', (new_width, new_height))\n    for x in range(new_width):\n        for y in range(new_height):\n            new_image.putpixel((x, y), image.getpixel((x // 2, y // 2)))\n    return new_image"}
{"nl": "2x the initial image shape", "code": "def resize_image(image):\n    width, height = image.size\n\n    result = Image.new(image.mode, (width * 2, height * 2))\n\n    for x in range(width):\n        for y in range(height):\n            pixel = image.getpixel((x, y))\n\n            result.putpixel((x * 2, y * 2), pixel)\n            result.putpixel((x * 2 + 1, y * 2), pixel)\n            result.putpixel((x * 2, y * 2 + 1), pixel)\n            result.putpixel((x * 2 + 1, y * 2 + 1), pixel)\n\n    return result\n "}
{"nl": "2x the initial image shape", "code": "def resize_image(image):\n    \n    \n    return image.resize((image.size[0] * 2, image.size[1] * 2))\n "}
{"nl": "2x the initial image shape", "code": "def resize_image(img):\n        (h,w) = img.shape[:2]\n\n        output = np.zeros((2*h,2*w), dtype = \"uint8\")\n\n        for i in range(0,h):\n                for j in range(0,w):\n                        pixel = img[i,j]\n                        output[2*i,2*j] = pixel\n                        output[2*i+1,2*j] = pixel\n                        output[2*i,2*j+1] = pixel\n                        output[2*i+1,2*j+1] = pixel\n\n        return output "}
{"nl": "the picture will need to be resized to be twice as large. ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "the picture will need to be resized to be twice as large. ", "code": "def resize_image(image):\n    \n    \n    width, height = image.size\n    new_width = width * 2\n    new_height = height * 2\n    new_image = Image.new('RGB', (new_width, new_height))\n    for x in range(new_width):\n        for y in range(new_height):\n            new_image.putpixel((x, y), image.getpixel((x // 2, y // 2)))\n    return new_image"}
{"nl": "the picture will need to be resized to be twice as large. ", "code": "def resize_image(image):\n    width, height = image.size\n\n    result = Image.new(image.mode, (width * 2, height * 2))\n\n    for x in range(width):\n        for y in range(height):\n            pixel = image.getpixel((x, y))\n\n            result.putpixel((x * 2, y * 2), pixel)\n            result.putpixel((x * 2 + 1, y * 2), pixel)\n            result.putpixel((x * 2, y * 2 + 1), pixel)\n            result.putpixel((x * 2 + 1, y * 2 + 1), pixel)\n\n    return result\n  "}
{"nl": "the picture will need to be resized to be twice as large. ", "code": "def resize_image(image):\n    \n    \n    return image.resize((image.size[0] * 2, image.size[1] * 2))"}
{"nl": "the picture will need to be resized to be twice as large. ", "code": "def resize_image(img):\n        (h,w) = img.shape[:2]\n\n        output = np.zeros((2*h,2*w), dtype = \"uint8\")\n\n        for i in range(0,h):\n                for j in range(0,w):\n                        pixel = img[i,j]\n                        output[2*i,2*j] = pixel\n                        output[2*i+1,2*j] = pixel\n                        output[2*i,2*j+1] = pixel\n                        output[2*i+1,2*j+1] = pixel\n\n        return output "}
{"nl": "Double the size of a photograph ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "Double the size of a photograph ", "code": "def resize_image(image):\n    \n    \n    width, height = image.size\n    new_width = width * 2\n    new_height = height * 2\n    new_image = Image.new('RGB', (new_width, new_height))\n    for x in range(new_width):\n        for y in range(new_height):\n            new_image.putpixel((x, y), image.getpixel((x // 2, y // 2)))\n    return new_image"}
{"nl": "Double the size of a photograph ", "code": "def resize_image(image):\n    width, height = image.size\n\n    result = Image.new(image.mode, (width * 2, height * 2))\n\n    for x in range(width):\n        for y in range(height):\n            pixel = image.getpixel((x, y))\n\n            result.putpixel((x * 2, y * 2), pixel)\n            result.putpixel((x * 2 + 1, y * 2), pixel)\n            result.putpixel((x * 2, y * 2 + 1), pixel)\n            result.putpixel((x * 2 + 1, y * 2 + 1), pixel)\n\n    return result\n  "}
{"nl": "Double the size of a photograph ", "code": "def resize_image(image):\n    \n    \n    return image.resize((image.size[0] * 2, image.size[1] * 2))"}
{"nl": "Double the size of a photograph ", "code": "def resize_image(img):\n        (h,w) = img.shape[:2]\n\n        output = np.zeros((2*h,2*w), dtype = \"uint8\")\n\n        for i in range(0,h):\n                for j in range(0,w):\n                        pixel = img[i,j]\n                        output[2*i,2*j] = pixel\n                        output[2*i+1,2*j] = pixel\n                        output[2*i,2*j+1] = pixel\n                        output[2*i+1,2*j+1] = pixel\n\n        return output "}
{"nl": "enlarge an image to twice its size ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "enlarge an image to twice its size ", "code": "def resize_image(image):\n    \n    \n    width, height = image.size\n    new_width = width * 2\n    new_height = height * 2\n    new_image = Image.new('RGB', (new_width, new_height))\n    for x in range(new_width):\n        for y in range(new_height):\n            new_image.putpixel((x, y), image.getpixel((x // 2, y // 2)))\n    return new_image"}
{"nl": "enlarge an image to twice its size ", "code": "def resize_image(image):\n    width, height = image.size\n\n    result = Image.new(image.mode, (width * 2, height * 2))\n\n    for x in range(width):\n        for y in range(height):\n            pixel = image.getpixel((x, y))\n\n            result.putpixel((x * 2, y * 2), pixel)\n            result.putpixel((x * 2 + 1, y * 2), pixel)\n            result.putpixel((x * 2, y * 2 + 1), pixel)\n            result.putpixel((x * 2 + 1, y * 2 + 1), pixel)\n\n    return result\n  "}
{"nl": "enlarge an image to twice its size ", "code": "def resize_image(image):\n    \n    \n    return image.resize((image.size[0] * 2, image.size[1] * 2))"}
{"nl": "enlarge an image to twice its size ", "code": "def resize_image(img):\n        (h,w) = img.shape[:2]\n\n        output = np.zeros((2*h,2*w), dtype = \"uint8\")\n\n        for i in range(0,h):\n                for j in range(0,w):\n                        pixel = img[i,j]\n                        output[2*i,2*j] = pixel\n                        output[2*i+1,2*j] = pixel\n                        output[2*i,2*j+1] = pixel\n                        output[2*i+1,2*j+1] = pixel\n\n        return output "}
{"nl": "enlarge a photograph to twice its size ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "enlarge a photograph to twice its size ", "code": "def resize_image(image):\n    \n    \n    width, height = image.size\n    new_width = width * 2\n    new_height = height * 2\n    new_image = Image.new('RGB', (new_width, new_height))\n    for x in range(new_width):\n        for y in range(new_height):\n            new_image.putpixel((x, y), image.getpixel((x // 2, y // 2)))\n    return new_image"}
{"nl": "enlarge a photograph to twice its size ", "code": "def resize_image(image):\n    width, height = image.size\n\n    result = Image.new(image.mode, (width * 2, height * 2))\n\n    for x in range(width):\n        for y in range(height):\n            pixel = image.getpixel((x, y))\n\n            result.putpixel((x * 2, y * 2), pixel)\n            result.putpixel((x * 2 + 1, y * 2), pixel)\n            result.putpixel((x * 2, y * 2 + 1), pixel)\n            result.putpixel((x * 2 + 1, y * 2 + 1), pixel)\n\n    return result\n  "}
{"nl": "enlarge a photograph to twice its size ", "code": "def resize_image(image):\n    \n    \n    return image.resize((image.size[0] * 2, image.size[1] * 2))"}
{"nl": "enlarge a photograph to twice its size ", "code": "def resize_image(img):\n        (h,w) = img.shape[:2]\n\n        output = np.zeros((2*h,2*w), dtype = \"uint8\")\n\n        for i in range(0,h):\n                for j in range(0,w):\n                        pixel = img[i,j]\n                        output[2*i,2*j] = pixel\n                        output[2*i+1,2*j] = pixel\n                        output[2*i,2*j+1] = pixel\n                        output[2*i+1,2*j+1] = pixel\n\n        return output "}
{"nl": "photo doubled ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "photo doubled ", "code": "def resize_image(image):\n    \n    \n    width, height = image.size\n    new_width = width * 2\n    new_height = height * 2\n    new_image = Image.new('RGB', (new_width, new_height))\n    for x in range(new_width):\n        for y in range(new_height):\n            new_image.putpixel((x, y), image.getpixel((x // 2, y // 2)))\n    return new_image"}
{"nl": "photo doubled ", "code": "def resize_image(image):\n    width, height = image.size\n\n    result = Image.new(image.mode, (width * 2, height * 2))\n\n    for x in range(width):\n        for y in range(height):\n            pixel = image.getpixel((x, y))\n\n            result.putpixel((x * 2, y * 2), pixel)\n            result.putpixel((x * 2 + 1, y * 2), pixel)\n            result.putpixel((x * 2, y * 2 + 1), pixel)\n            result.putpixel((x * 2 + 1, y * 2 + 1), pixel)\n\n    return result\n  "}
{"nl": "photo doubled ", "code": "def resize_image(image):\n    \n    \n    return image.resize((image.size[0] * 2, image.size[1] * 2))"}
{"nl": "photo doubled ", "code": "def resize_image(img):\n        (h,w) = img.shape[:2]\n\n        output = np.zeros((2*h,2*w), dtype = \"uint8\")\n\n        for i in range(0,h):\n                for j in range(0,w):\n                        pixel = img[i,j]\n                        output[2*i,2*j] = pixel\n                        output[2*i+1,2*j] = pixel\n                        output[2*i,2*j+1] = pixel\n                        output[2*i+1,2*j+1] = pixel\n\n        return output "}
{"nl": "resize an image to 4 times its shape", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "resize an image to 4 times its shape", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "resize an image to 4 times its shape", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "resize an image to 4 times its shape", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "resize an image to 4 times its shape", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "resize an image to 4 times its shape", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "Four times the size of a picture ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "Four times the size of a picture ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "Four times the size of a picture ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "Four times the size of a picture ", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "Four times the size of a picture ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "Four times the size of a picture ", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "Four times the size of a picture ", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "picture resizing to 4 times its original size ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "picture resizing to 4 times its original size ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "picture resizing to 4 times its original size ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "picture resizing to 4 times its original size ", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "picture resizing to 4 times its original size ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "picture resizing to 4 times its original size ", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "picture resizing to 4 times its original size ", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "4 times the original picture size ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "4 times the original picture size ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "4 times the original picture size ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "4 times the original picture size ", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "4 times the original picture size ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "4 times the original picture size ", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "4 times the original picture size ", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "enlarge a picture to four times its original size. ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "enlarge a picture to four times its original size. ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "enlarge a picture to four times its original size. ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "enlarge a picture to four times its original size. ", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "enlarge a picture to four times its original size. ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "enlarge a picture to four times its original size. ", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "enlarge a picture to four times its original size. ", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "enlarge a photograph to four times its original size ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "enlarge a photograph to four times its original size ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "enlarge a photograph to four times its original size ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "enlarge a photograph to four times its original size ", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "enlarge a photograph to four times its original size ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "enlarge a photograph to four times its original size ", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "enlarge a photograph to four times its original size ", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "Increase the size of an image to four times its current shape. ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "Increase the size of an image to four times its current shape. ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "Increase the size of an image to four times its current shape. ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "Increase the size of an image to four times its current shape. ", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "Increase the size of an image to four times its current shape. ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "Increase the size of an image to four times its current shape. ", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "Increase the size of an image to four times its current shape. ", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "resize an image to be four times its original shape. ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "resize an image to be four times its original shape. ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "resize an image to be four times its original shape. ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "resize an image to be four times its original shape. ", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "resize an image to be four times its original shape. ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "resize an image to be four times its original shape. ", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "resize an image to be four times its original shape. ", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "Adjust the size of an image so that it is four times its original shape. ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "Adjust the size of an image so that it is four times its original shape. ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "Adjust the size of an image so that it is four times its original shape. ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "Adjust the size of an image so that it is four times its original shape. ", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "Adjust the size of an image so that it is four times its original shape. ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "Adjust the size of an image so that it is four times its original shape. ", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "Adjust the size of an image so that it is four times its original shape. ", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "image scaled up to four times its original shape ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "image scaled up to four times its original shape ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "image scaled up to four times its original shape ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "image scaled up to four times its original shape ", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "image scaled up to four times its original shape ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "image scaled up to four times its original shape ", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "image scaled up to four times its original shape ", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "fourfold the size of an image's shape ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "fourfold the size of an image's shape ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "fourfold the size of an image's shape ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "fourfold the size of an image's shape ", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "fourfold the size of an image's shape ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "fourfold the size of an image's shape ", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "fourfold the size of an image's shape ", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "enlarge an image fourfold its shape ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "enlarge an image fourfold its shape ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "enlarge an image fourfold its shape ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "enlarge an image fourfold its shape ", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "enlarge an image fourfold its shape ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "enlarge an image fourfold its shape ", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "enlarge an image fourfold its shape ", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "image resizing to four times the original size ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "image resizing to four times the original size ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "image resizing to four times the original size ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "image resizing to four times the original size ", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "image resizing to four times the original size ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "image resizing to four times the original size ", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "image resizing to four times the original size ", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "4x image size ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "4x image size ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "4x image size ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "4x image size ", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "4x image size ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "4x image size ", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "4x image size ", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "enlarge an image by 4 ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "enlarge an image by 4 ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "enlarge an image by 4 ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "enlarge an image by 4 ", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "enlarge an image by 4 ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "enlarge an image by 4 ", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "enlarge an image by 4 ", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "4x an image's size ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "4x an image's size ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image\n"}
{"nl": "4x an image's size ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4), interpolation=cv2.INTER_CUBIC)"}
{"nl": "4x an image's size ", "code": "def resize_image(image):\n    \n    \n    rows, cols, channels = image.shape\n    image = cv2.resize(image, (cols * 4, rows * 4))\n    return image"}
{"nl": "4x an image's size ", "code": "def resize_image(img):\n    return cv2.resize(img, (img.shape[1] * 4, img.shape[0] * 4))"}
{"nl": "4x an image's size ", "code": "def resize_image(img, scale=4):\n    \n    \n    h, w = img.shape[:2]\n    output = np.zeros((h * scale, w * scale))\n\n    for i in range(h * scale):\n        for j in range(w * scale):\n            i_, j_ = i / scale, j / scale\n            i_1, j_1 = int(i_), int(j_)\n            i_2, j_2 = i_1 + 1, j_1 + 1\n\n            if i_2 >= h:\n                i_2 = h - 1\n            if j_2 >= w:\n                j_2 = w - 1\n\n            output[i, j] = img[i_1, j_1] * (i_2 - i_) * (j_2 - j_) + \\\n                           img[i_1, j_2] * (i_2 - i_) * (j_ - j_1) + \\\n                           img[i_2, j_1] * (i_ - i_1) * (j_2 - j_) + \\\n                           img[i_2, j_2] * (i_ - i_1) * (j_ - j_1)\n    return output"}
{"nl": "4x an image's size ", "code": "def resize_image(image):\n    h = img.shape[0]\n    w = img.shape[1]\n    img_new = np.zeros((h*2, w*2, 3))\n    new_h = img_new.shape[0]\n    new_w = img_new.shape[1]\n    for i in range(new_h):\n        for j in range(new_w):\n            x = int(i / 2)\n            y = int(j / 2)\n            if i % 2 == 0 and j % 2 == 0:\n                img_new[i][j] = img[x][y]\n            elif i % 2 == 0 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x][y+1]) / 2\n            elif i % 2 == 1 and j % 2 == 0:\n                img_new[i][j] = (img[x][y] + img[x+1][y]) / 2\n            elif i % 2 == 1 and j % 2 == 1:\n                img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4\n    return img_new"}
{"nl": "combine two images by adding them", "code": "def combine_images(img1, img2):\n    return cv2.add(img1, img2)"}
{"nl": "join two photos together by adding them ", "code": "def combine_images(img1, img2):\n    return cv2.add(img1, img2)"}
{"nl": "simply adding them, merge two photos. ", "code": "def combine_images(img1, img2):\n    return cv2.add(img1, img2)"}
{"nl": "merge two photos by adding them ", "code": "def combine_images(img1, img2):\n    return cv2.add(img1, img2)"}
{"nl": "simply combining two photos together ", "code": "def combine_images(img1, img2):\n    return cv2.add(img1, img2)"}
{"nl": "add the two pictures together. ", "code": "def combine_images(img1, img2):\n    return cv2.add(img1, img2)"}
{"nl": "Add the two pictures together to create a new one. ", "code": "def combine_images(img1, img2):\n    return cv2.add(img1, img2)"}
{"nl": "Add the two pictures together to create one composite. ", "code": "def combine_images(img1, img2):\n    return cv2.add(img1, img2)"}
{"nl": "Add the two pictures together to create a new one. ", "code": "def combine_images(img1, img2):\n    return cv2.add(img1, img2)"}
{"nl": "Add two photos. ", "code": "def combine_images(img1, img2):\n    return cv2.add(img1, img2)"}
{"nl": "add two images ", "code": "def combine_images(img1, img2):\n    return cv2.add(img1, img2)"}
{"nl": "merge two pictures by combining them. ", "code": "def combine_images(img1, img2):\n    return cv2.add(img1, img2)"}
{"nl": "add the two pictures together. ", "code": "def combine_images(img1, img2):\n    return cv2.add(img1, img2)"}
{"nl": "combine two pictures by adding them. ", "code": "def combine_images(img1, img2):\n    return cv2.add(img1, img2)"}
{"nl": "blur the image ", "code": "def blur_image(img):\n    return cv2.GaussianBlur(img, (11, 11), 0)"}
{"nl": "blur the image ", "code": "def blur_image(x, k):\n    kernel = np.ones((k, k), np.float32) / k ** 2\n    return cv2.filter2D(x, -1, kernel)"}
{"nl": "blur the image ", "code": "def blur_image(x, k=5, sigma=1.4):\n    return cv2.GaussianBlur(x, (k, k), sigma)"}
{"nl": "blur the image ", "code": "def blur_img(img, blur_size):\n    tmp_img = img.astype(np.float32)\n    tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)\n    tmp_img = np.clip(tmp_img, 0, 255)\n    res = tmp_img.astype(np.uint8)\n\n    return res"}
{"nl": "picture blur ", "code": "def blur_image(img):\n    return cv2.GaussianBlur(img, (11, 11), 0)"}
{"nl": "picture blur ", "code": "def blur_image(x, k):\n    kernel = np.ones((k, k), np.float32) / k ** 2\n    return cv2.filter2D(x, -1, kernel)"}
{"nl": "picture blur ", "code": "def blur_image(x, k=5, sigma=1.4):\n    return cv2.GaussianBlur(x, (k, k), sigma)"}
{"nl": "picture blur ", "code": "def blur_img(img, blur_size):\n    tmp_img = img.astype(np.float32)\n    tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)\n    tmp_img = np.clip(tmp_img, 0, 255)\n    res = tmp_img.astype(np.uint8)\n\n    return res"}
{"nl": "image blur ", "code": "def blur_image(img):\n    return cv2.GaussianBlur(img, (11, 11), 0)"}
{"nl": "image blur ", "code": "def blur_image(x, k):\n    kernel = np.ones((k, k), np.float32) / k ** 2\n    return cv2.filter2D(x, -1, kernel)"}
{"nl": "image blur ", "code": "def blur_image(x, k=5, sigma=1.4):\n    return cv2.GaussianBlur(x, (k, k), sigma)"}
{"nl": "image blur ", "code": "def blur_img(img, blur_size):\n    tmp_img = img.astype(np.float32)\n    tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)\n    tmp_img = np.clip(tmp_img, 0, 255)\n    res = tmp_img.astype(np.uint8)\n\n    return res"}
{"nl": "muddy up the picture", "code": "def blur_image(img):\n    return cv2.GaussianBlur(img, (11, 11), 0)"}
{"nl": "muddy up the picture", "code": "def blur_image(x, k):\n    kernel = np.ones((k, k), np.float32) / k ** 2\n    return cv2.filter2D(x, -1, kernel)"}
{"nl": "muddy up the picture", "code": "def blur_image(x, k=5, sigma=1.4):\n    return cv2.GaussianBlur(x, (k, k), sigma)"}
{"nl": "muddy up the picture", "code": "def blur_img(img, blur_size):\n    tmp_img = img.astype(np.float32)\n    tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)\n    tmp_img = np.clip(tmp_img, 0, 255)\n    res = tmp_img.astype(np.uint8)\n\n    return res"}
{"nl": "distort the picture in some way", "code": "def blur_image(img):\n    return cv2.GaussianBlur(img, (11, 11), 0)"}
{"nl": "distort the picture in some way", "code": "def blur_image(x, k):\n    kernel = np.ones((k, k), np.float32) / k ** 2\n    return cv2.filter2D(x, -1, kernel)"}
{"nl": "distort the picture in some way", "code": "def blur_image(x, k=5, sigma=1.4):\n    return cv2.GaussianBlur(x, (k, k), sigma)"}
{"nl": "distort the picture in some way", "code": "def blur_img(img, blur_size):\n    tmp_img = img.astype(np.float32)\n    tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)\n    tmp_img = np.clip(tmp_img, 0, 255)\n    res = tmp_img.astype(np.uint8)\n\n    return res"}
{"nl": "pixelize ", "code": "def blur_image(img):\n    return cv2.GaussianBlur(img, (11, 11), 0)"}
{"nl": "pixelize ", "code": "def blur_image(x, k):\n    kernel = np.ones((k, k), np.float32) / k ** 2\n    return cv2.filter2D(x, -1, kernel)"}
{"nl": "pixelize ", "code": "def blur_image(x, k=5, sigma=1.4):\n    return cv2.GaussianBlur(x, (k, k), sigma)"}
{"nl": "pixelize ", "code": "def blur_img(img, blur_size):\n    tmp_img = img.astype(np.float32)\n    tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)\n    tmp_img = np.clip(tmp_img, 0, 255)\n    res = tmp_img.astype(np.uint8)\n\n    return res"}
{"nl": "blur picture ", "code": "def blur_image(img):\n    return cv2.GaussianBlur(img, (11, 11), 0)"}
{"nl": "blur picture ", "code": "def blur_image(x, k):\n    kernel = np.ones((k, k), np.float32) / k ** 2\n    return cv2.filter2D(x, -1, kernel)"}
{"nl": "blur picture ", "code": "def blur_image(x, k=5, sigma=1.4):\n    return cv2.GaussianBlur(x, (k, k), sigma)"}
{"nl": "blur picture ", "code": "def blur_img(img, blur_size):\n    tmp_img = img.astype(np.float32)\n    tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)\n    tmp_img = np.clip(tmp_img, 0, 255)\n    res = tmp_img.astype(np.uint8)\n\n    return res"}
{"nl": "Blur the image ", "code": "def blur_image(img):\n    return cv2.GaussianBlur(img, (11, 11), 0)"}
{"nl": "Blur the image ", "code": "def blur_image(x, k):\n    kernel = np.ones((k, k), np.float32) / k ** 2\n    return cv2.filter2D(x, -1, kernel)"}
{"nl": "Blur the image ", "code": "def blur_image(x, k=5, sigma=1.4):\n    return cv2.GaussianBlur(x, (k, k), sigma)"}
{"nl": "Blur the image ", "code": "def blur_img(img, blur_size):\n    tmp_img = img.astype(np.float32)\n    tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)\n    tmp_img = np.clip(tmp_img, 0, 255)\n    res = tmp_img.astype(np.uint8)\n\n    return res"}
{"nl": "pixelate the picture", "code": "def blur_image(img):\n    return cv2.GaussianBlur(img, (11, 11), 0)"}
{"nl": "pixelate the picture", "code": "def blur_image(x, k):\n    kernel = np.ones((k, k), np.float32) / k ** 2\n    return cv2.filter2D(x, -1, kernel)"}
{"nl": "pixelate the picture", "code": "def blur_image(x, k=5, sigma=1.4):\n    return cv2.GaussianBlur(x, (k, k), sigma)"}
{"nl": "pixelate the picture", "code": "def blur_img(img, blur_size):\n    tmp_img = img.astype(np.float32)\n    tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)\n    tmp_img = np.clip(tmp_img, 0, 255)\n    res = tmp_img.astype(np.uint8)\n\n    return res"}
{"nl": "increase the brightness and contrast of the image", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "increase the image's brightness and contrast ", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "enhance the image's brightness and contrast ", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "Boost the image's contrast and brightness ", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "boost the brightness and contrast of the picture ", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "improve the image's brightness and contrast ", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "brighten and contrast up the picture ", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "Brightness and contrast should be increased in the picture. ", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "the brightness and contrast of the image need to be increased. ", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "Boost the intensity of the image's brightness and contrast. ", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "Boost image brightness and contrast ", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "brighten and contrast the photo ", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "Brighten and contrast the image ", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "boost image brightness and contrast ", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "enhance the image's brightness and contrast ", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "add contrast and brightness to the image ", "code": "def brightness_contrast(img):\n    alpha = 2.0 # Simple contrast control [1.0 - 3.0]\n    beta = 50    # Simple brightness control [0-100]\n    return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"}
{"nl": "To double an image's shape, enlarge it. ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "resize an image to double its shape", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "enlarge a picture to double its size ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "Double the size of an image. ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "enlarge an image to double its size ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "enlarge a picture to twice its size ", "code": "def resize_image(img):\n    return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"}
{"nl": "split the channels of a color image", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "split the channels of a color image", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "split the channels of a color image", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "split the channels of a color image", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "split the channels of a color image", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "split the channels of a color image", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "split the channels of a color image", "code": "def split_channels(image):\n    \n    \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "separate a colour image's channels ", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "separate a colour image's channels ", "code": "def split_channels(image):\n    \n    \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "separate a colour image's channels ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "separate a colour image's channels ", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "separate a colour image's channels ", "code": "def flip_image_horizontally(image):\n    return image[:, ::-1]"}
{"nl": "separate a colour image's channels ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "separate a colour image's channels ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "separate a colour image's channels ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "separate a colour image's channels ", "code": "def flip_image_horizontally(img, axis=1):\n    if axis == 0:\n        img = img[:,:,::-1]\n        return img\n    else:\n        img = img[:,::-1,:]\n        return img"}
{"nl": "separate a colour image's channels ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "separate a colour image's channels ", "code": "def flip_image_horizontally(image):\n    return image[:, ::-1]"}
{"nl": "separate a colour image's channels ", "code": "def flip_image_horizontally(img, axis=1):\n    if axis == 0:\n        img = img[:,:,::-1]\n        return img\n    else:\n        img = img[:,::-1,:]\n        return img"}
{"nl": "separate a colour image's channels ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "separate a colour image's channels ", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "separate a colour image's channels ", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "the division of a colour image's channels ", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "the division of a colour image's channels ", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "the division of a colour image's channels ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "the division of a colour image's channels ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "the division of a colour image's channels ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "the division of a colour image's channels ", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "the division of a colour image's channels ", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "Dividing a colour image's channels ", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "Dividing a colour image's channels ", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "Dividing a colour image's channels ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "Dividing a colour image's channels ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "Dividing a colour image's channels ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "Dividing a colour image's channels ", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "Dividing a colour image's channels ", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "divide the channels in a colour picture ", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "divide the channels in a colour picture ", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "divide the channels in a colour picture ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "divide the channels in a colour picture ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "divide the channels in a colour picture ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "divide the channels in a colour picture ", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "divide the channels in a colour picture ", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "colour picture channel division ", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "colour picture channel division ", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "colour picture channel division ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "colour picture channel division ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "colour picture channel division ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "colour picture channel division ", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "colour picture channel division ", "code": "def split_channels(image):\n    \n    \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "colour picture channel separation ", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "colour picture channel separation ", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "colour picture channel separation ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "colour picture channel separation ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "colour picture channel separation ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "colour picture channel separation ", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "colour picture channel separation ", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "the colour image was separated into its individual channels. ", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "the colour image was separated into its individual channels. ", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "the colour image was separated into its individual channels. ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "the colour image was separated into its individual channels. ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "the colour image was separated into its individual channels. ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "the colour image was separated into its individual channels. ", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "the colour image was separated into its individual channels. ", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "separation of the colour channels in a picture", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "separation of the colour channels in a picture", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "separation of the colour channels in a picture", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "separation of the colour channels in a picture", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "separation of the colour channels in a picture", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "separation of the colour channels in a picture", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "separation of the colour channels in a picture", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "the colour image was segmented into its individual channels", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "the colour image was segmented into its individual channels", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "the colour image was segmented into its individual channels", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "the colour image was segmented into its individual channels", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "the colour image was segmented into its individual channels", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "the colour image was segmented into its individual channels", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "the colour image was segmented into its individual channels", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "separating colour channels", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "separating colour channels", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "separating colour channels", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "separating colour channels", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "separating colour channels", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "separating colour channels", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "separating colour channels", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "Image channels are separated ", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "Image channels are separated ", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "Image channels are separated ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "Image channels are separated ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "Image channels are separated ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "Image channels are separated ", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "Image channels are separated ", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "divide image channels ", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "divide image channels ", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "divide image channels ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "divide image channels ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "divide image channels ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "divide image channels ", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "divide image channels ", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "Channelize a colour picture ", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "Channelize a colour picture ", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "Channelize a colour picture ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "Channelize a colour picture ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "Channelize a colour picture ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "Channelize a colour picture ", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "Channelize a colour picture ", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "Separate the colour channels of a picture ", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "Separate the colour channels of a picture ", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "Separate the colour channels of a picture ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "Separate the colour channels of a picture ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "Separate the colour channels of a picture ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "Separate the colour channels of a picture ", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "Separate the colour channels of a picture ", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "separating a colour image's channels ", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "separating a colour image's channels ", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "separating a colour image's channels ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "separating a colour image's channels ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "separating a colour image's channels ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "separating a colour image's channels ", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "separating a colour image's channels ", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "Channelize an image's colour channels ", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "Channelize an image's colour channels ", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "Channelize an image's colour channels ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "Channelize an image's colour channels ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "Channelize an image's colour channels ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "Channelize an image's colour channels ", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "Channelize an image's colour channels ", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "separating the colour channels of an image ", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "separating the colour channels of an image ", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "separating the colour channels of an image ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "separating the colour channels of an image ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "separating the colour channels of an image ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "separating the colour channels of an image ", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "separating the colour channels of an image ", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "split a colour image into its individual colour channels. ", "code": "def split_image(img):\n    b, g, r = cv2.split(img)\n    return r, g, b"}
{"nl": "split a colour image into its individual colour channels. ", "code": "def split_channels(image):\n    channels = cv2.split(image)\n    return channels"}
{"nl": "split a colour image into its individual colour channels. ", "code": "def split_colour_channels(img):\n  r, g, b = img.split()\n  return (r,g,b)\n"}
{"nl": "split a colour image into its individual colour channels. ", "code": "def split_colour(img):\n    red = img[:,:,0]\n    green = img[:,:,1]\n    blue = img[:,:,2]\n    return red, green, blue"}
{"nl": "split a colour image into its individual colour channels. ", "code": "def split_channels(img):\n    img_red = img[:,:,0]\n    img_green = img[:,:,1]\n    img_blue = img[:,:,2]\n    return img_red, img_green, img_blue\n"}
{"nl": "split a colour image into its individual colour channels. ", "code": "def split_image(img):\n    r_channel = img[:,:,0]\n    g_channel = img[:,:,1]\n    b_channel = img[:,:,2]\n    return r_channel, g_channel, b_channel\n"}
{"nl": "split a colour image into its individual colour channels. ", "code": "def split_channels(image):\n   \n    return image[:, :, 0], image[:, :, 1], image[:, :, 2]"}
{"nl": "create a mask for a color range", "code": "def mask_color_range(image, lower_color, upper_color):\n\n    lower = np.array(lower_color, dtype = \"uint8\")\n    upper = np.array(upper_color, dtype = \"uint8\")\n    mask = cv2.inRange(image, lower, upper)\n    output = cv2.bitwise_and(image, image, mask = mask)\n\n"}
{"nl": "make a mask for a set of colors", "code": "def mask_color_range(image, lower_color, upper_color):\n\n    lower = np.array(lower_color, dtype = \"uint8\")\n    upper = np.array(upper_color, dtype = \"uint8\")\n    mask = cv2.inRange(image, lower, upper)\n    output = cv2.bitwise_and(image, image, mask = mask)\n\n"}
{"nl": "make a mask for a certain colour range", "code": "def mask_color_range(image, lower_color, upper_color):\n\n    lower = np.array(lower_color, dtype = \"uint8\")\n    upper = np.array(upper_color, dtype = \"uint8\")\n    mask = cv2.inRange(image, lower, upper)\n    output = cv2.bitwise_and(image, image, mask = mask)\n\n"}
{"nl": "construct a mask for a set of colours ", "code": "def mask_color_range(image, lower_color, upper_color):\n\n    lower = np.array(lower_color, dtype = \"uint8\")\n    upper = np.array(upper_color, dtype = \"uint8\")\n    mask = cv2.inRange(image, lower, upper)\n    output = cv2.bitwise_and(image, image, mask = mask)\n\n"}
{"nl": "Make a mask for the colour range you want to work with", "code": "def mask_color_range(image, lower_color, upper_color):\n\n    lower = np.array(lower_color, dtype = \"uint8\")\n    upper = np.array(upper_color, dtype = \"uint8\")\n    mask = cv2.inRange(image, lower, upper)\n    output = cv2.bitwise_and(image, image, mask = mask)\n\n"}
{"nl": "Make a mask for a specific colour range", "code": "def mask_color_range(image, lower_color, upper_color):\n\n    lower = np.array(lower_color, dtype = \"uint8\")\n    upper = np.array(upper_color, dtype = \"uint8\")\n    mask = cv2.inRange(image, lower, upper)\n    output = cv2.bitwise_and(image, image, mask = mask)\n\n"}
{"nl": "Make a mask for a specific colour spectrum", "code": "def mask_color_range(image, lower_color, upper_color):\n\n    lower = np.array(lower_color, dtype = \"uint8\")\n    upper = np.array(upper_color, dtype = \"uint8\")\n    mask = cv2.inRange(image, lower, upper)\n    output = cv2.bitwise_and(image, image, mask = mask)\n\n"}
{"nl": "Color range mask ", "code": "def mask_color_range(image, lower_color, upper_color):\n\n    lower = np.array(lower_color, dtype = \"uint8\")\n    upper = np.array(upper_color, dtype = \"uint8\")\n    mask = cv2.inRange(image, lower, upper)\n    output = cv2.bitwise_and(image, image, mask = mask)\n\n"}
{"nl": "Mask a colour range ", "code": "def mask_color_range(image, lower_color, upper_color):\n\n    lower = np.array(lower_color, dtype = \"uint8\")\n    upper = np.array(upper_color, dtype = \"uint8\")\n    mask = cv2.inRange(image, lower, upper)\n    output = cv2.bitwise_and(image, image, mask = mask)\n\n"}
{"nl": "Create a mask for a colour range ", "code": "def mask_color_range(image, lower_color, upper_color):\n\n    lower = np.array(lower_color, dtype = \"uint8\")\n    upper = np.array(upper_color, dtype = \"uint8\")\n    mask = cv2.inRange(image, lower, upper)\n    output = cv2.bitwise_and(image, image, mask = mask)\n\n"}
{"nl": "make a mask for a range of colours ", "code": "def mask_color_range(image, lower_color, upper_color):\n\n    lower = np.array(lower_color, dtype = \"uint8\")\n    upper = np.array(upper_color, dtype = \"uint8\")\n    mask = cv2.inRange(image, lower, upper)\n    output = cv2.bitwise_and(image, image, mask = mask)\n\n"}
{"nl": "find all contours and the areas of those contours", "code": "def find_contours(img):\n    imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(imgray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    areas = [cv2.contourArea(c) for c in contours]\n    return contours, areas"}
{"nl": "Identify all contours and their corresponding areas. ", "code": "def find_contours(img):\n    imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(imgray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    areas = [cv2.contourArea(c) for c in contours]\n    return contours, areas"}
{"nl": "discover all of the contours and their corresponding areas. ", "code": "def find_contours(img):\n    imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(imgray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    areas = [cv2.contourArea(c) for c in contours]\n    return contours, areas"}
{"nl": "discover every contour and its corresponding areas. ", "code": "def find_contours(img):\n    imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(imgray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    areas = [cv2.contourArea(c) for c in contours]\n    return contours, areas"}
{"nl": "discover all curves and the spaces occupied by those contours ", "code": "def find_contours(img):\n    imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(imgray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    areas = [cv2.contourArea(c) for c in contours]\n    return contours, areas"}
{"nl": "locate all contours and their areas ", "code": "def find_contours(img):\n    imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(imgray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    areas = [cv2.contourArea(c) for c in contours]\n    return contours, areas"}
{"nl": "locate all curves and their respective areas. ", "code": "def find_contours(img):\n    imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(imgray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    areas = [cv2.contourArea(c) for c in contours]\n    return contours, areas"}
{"nl": "locate all contours and the areas of those contours. ", "code": "def find_contours(img):\n    imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(imgray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    areas = [cv2.contourArea(c) for c in contours]\n    return contours, areas"}
{"nl": "locate all contours and their corresponding areas. ", "code": "def find_contours(img):\n    imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(imgray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    areas = [cv2.contourArea(c) for c in contours]\n    return contours, areas"}
{"nl": "find all of the contours and their areas. ", "code": "def find_contours(img):\n    imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(imgray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    areas = [cv2.contourArea(c) for c in contours]\n    return contours, areas"}
{"nl": "find all contours and the areas of each contour. ", "code": "def find_contours(img):\n    imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(imgray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    areas = [cv2.contourArea(c) for c in contours]\n    return contours, areas"}
{"nl": "get a list of all curves and their respective areas ", "code": "def find_contours(img):\n    imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(imgray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    areas = [cv2.contourArea(c) for c in contours]\n    return contours, areas"}
{"nl": "contours and their respective areas must be discovered and recorded", "code": "def find_contours(img):\n    imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(imgray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    areas = [cv2.contourArea(c) for c in contours]\n    return contours, areas"}
{"nl": "locate all of the contours and the areas corresponding to those contours", "code": "def find_contours(img):\n    imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(imgray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    areas = [cv2.contourArea(c) for c in contours]\n    return contours, areas"}
{"nl": "locate all of the contours as well as the areas corresponding to those contours. ", "code": "def find_contours(img):\n    imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(imgray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, 1, 2)\n    areas = [cv2.contourArea(c) for c in contours]\n    return contours, areas"}
{"nl": "draw all contours on the original image", "code": "def draw_contours(img, contours):\n    img = img.copy()\n    cv2.drawContours(img, contours, -1, (0, 255, 0), 3)\n    return img"}
{"nl": "on the source image, draw every contour ", "code": "def draw_contours(img, contours):\n    img = img.copy()\n    cv2.drawContours(img, contours, -1, (0, 255, 0), 3)\n    return img"}
{"nl": "tracing every contour on the original image ", "code": "def draw_contours(img, contours):\n    img = img.copy()\n    cv2.drawContours(img, contours, -1, (0, 255, 0), 3)\n    return img"}
{"nl": "on the original image, draw every contour", "code": "def draw_contours(img, contours):\n    img = img.copy()\n    cv2.drawContours(img, contours, -1, (0, 255, 0), 3)\n    return img"}
{"nl": "draw all contours on the original image, but with a specific color", "code": "def draw_contours_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.drawContours(img, [c], -1, color, 2)\n    return img"}
{"nl": "the original image's outlines should all be drawn in a specified hue.", "code": "def draw_contours_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.drawContours(img, [c], -1, color, 2)\n    return img"}
{"nl": "Draw each contour on the original image using a certain colour", "code": "def draw_contours_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.drawContours(img, [c], -1, color, 2)\n    return img"}
{"nl": "Using a certain colour, trace every contour on the source image", "code": "def draw_contours_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.drawContours(img, [c], -1, color, 2)\n    return img"}
{"nl": "Draw every contour on the original image, but use a particular colour", "code": "def draw_contours_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.drawContours(img, [c], -1, color, 2)\n    return img"}
{"nl": "Using a specified colour, draw all outlines on the source image", "code": "def draw_contours_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.drawContours(img, [c], -1, color, 2)\n    return img"}
{"nl": "All contours on the source image should be drawn in a specified colour", "code": "def draw_contours_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.drawContours(img, [c], -1, color, 2)\n    return img"}
{"nl": "Draw all outlines on the original image, but with a certain hue", "code": "def draw_contours_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.drawContours(img, [c], -1, color, 2)\n    return img"}
{"nl": "draw all contours on the original image, but with a particular hue.", "code": "def draw_contours_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.drawContours(img, [c], -1, color, 2)\n    return img"}
{"nl": "Create all of the contours on the initial image, but do so using a particular colour. ", "code": "def draw_contours_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.drawContours(img, [c], -1, color, 2)\n    return img"}
{"nl": "Draw all contours on the source image in a certain hue. ", "code": "def draw_contours_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.drawContours(img, [c], -1, color, 2)\n    return img"}
{"nl": "Create all of the outlines on the original image, but use a certain shade of colour for them. ", "code": "def draw_contours_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.drawContours(img, [c], -1, color, 2)\n    return img"}
{"nl": "find the centroid of a contour", "code": "def find_centroid(img, contour):\n    M = cv2.moments(contour)\n    cx = int(M['m10']/M['m00'])\n    cy = int(M['m01']/M['m00'])\n    return cx, cy"}
{"nl": "locate a contour's centroid ", "code": "def find_centroid(img, contour):\n    M = cv2.moments(contour)\n    cx = int(M['m10']/M['m00'])\n    cy = int(M['m01']/M['m00'])\n    return cx, cy"}
{"nl": "determine a contour's centroid. ", "code": "def find_centroid(img, contour):\n    M = cv2.moments(contour)\n    cx = int(M['m10']/M['m00'])\n    cy = int(M['m01']/M['m00'])\n    return cx, cy"}
{"nl": "calculate a contour's centroid. ", "code": "def find_centroid(img, contour):\n    M = cv2.moments(contour)\n    cx = int(M['m10']/M['m00'])\n    cy = int(M['m01']/M['m00'])\n    return cx, cy"}
{"nl": "Locate the centre of a contour using its centroid", "code": "def find_centroid(img, contour):\n    M = cv2.moments(contour)\n    cx = int(M['m10']/M['m00'])\n    cy = int(M['m01']/M['m00'])\n    return cx, cy"}
{"nl": "Locate the centre of a contour ", "code": "def find_centroid(img, contour):\n    M = cv2.moments(contour)\n    cx = int(M['m10']/M['m00'])\n    cy = int(M['m01']/M['m00'])\n    return cx, cy"}
{"nl": "Determine the centre of a contour. ", "code": "def find_centroid(img, contour):\n    M = cv2.moments(contour)\n    cx = int(M['m10']/M['m00'])\n    cy = int(M['m01']/M['m00'])\n    return cx, cy"}
{"nl": "How do you find the contour's centroid", "code": "def find_centroid(img, contour):\n    M = cv2.moments(contour)\n    cx = int(M['m10']/M['m00'])\n    cy = int(M['m01']/M['m00'])\n    return cx, cy"}
{"nl": "contour centroid ", "code": "def find_centroid(img, contour):\n    M = cv2.moments(contour)\n    cx = int(M['m10']/M['m00'])\n    cy = int(M['m01']/M['m00'])\n    return cx, cy"}
{"nl": "a contour's centroid ", "code": "def find_centroid(img, contour):\n    M = cv2.moments(contour)\n    cx = int(M['m10']/M['m00'])\n    cy = int(M['m01']/M['m00'])\n    return cx, cy"}
{"nl": "draw a rectangle around the contours", "code": "def draw_rectangles(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "Draw a rectangle around the contours", "code": "def draw_rectangles(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "a rectangle should be drawn around the contours", "code": "def draw_rectangles(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "Create a rectangle encompassing the contours", "code": "def draw_rectangles(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "enclose the contours in a rectangle", "code": "def draw_rectangles(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "Create a rectangle around the outlines", "code": "def draw_rectangles(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "draw a rectangle around the outlines", "code": "def draw_rectangles(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "draw a rectangle around the outline ", "code": "def draw_rectangles(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "A rectangle should be drawn around the outlines ", "code": "def draw_rectangles(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "Create a rectangle that surrounds the outlines. ", "code": "def draw_rectangles(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "A rectangle should be drawn around the outside of the outlines. ", "code": "def draw_rectangles(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "Around the contours, draw a rectangle", "code": "def draw_rectangles(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "Outside of the contours, draw a rectangle", "code": "def draw_rectangles(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "surrounding the contours, draw a rectangle", "code": "def draw_rectangles(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "a rectangle enclosing the outline ", "code": "def draw_rectangles(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "draw a rectangle around the contours with a specific color", "code": "def draw_rectangles_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)\n    return img"}
{"nl": "In a given colour, draw a rectangle around the contours", "code": "def draw_rectangles_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)\n    return img"}
{"nl": "Create a rectangle with a given colour around the contours", "code": "def draw_rectangles_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)\n    return img"}
{"nl": "With a particular hue, create a rectangle around the contours", "code": "def draw_rectangles_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)\n    return img"}
{"nl": "With a certain hue, draw a rectangle around the contours", "code": "def draw_rectangles_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)\n    return img"}
{"nl": "Draw a rectangle with a certain colour around the contours", "code": "def draw_rectangles_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)\n    return img"}
{"nl": "Using a specified colour, draw a rectangle around the contours", "code": "def draw_rectangles_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)\n    return img"}
{"nl": "With a given colour, create a rectangle around the contours", "code": "def draw_rectangles_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)\n    return img"}
{"nl": "encircle the contours with a rectangle of a given colour ", "code": "def draw_rectangles_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)\n    return img"}
{"nl": "Use a specific colour to outline the contours with a rectangle ", "code": "def draw_rectangles_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)\n    return img"}
{"nl": "Create a rectangle using a particular colour and wrap it around the contours", "code": "def draw_rectangles_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)\n    return img"}
{"nl": "get the center of the contours", "code": "def get_contours_center(img, contours):\n    centers = []\n    for c in contours:\n        cx, cy = find_centroid(img, c)\n        centers.append((cx, cy))\n    return centers"}
{"nl": "Identify the contours' centre", "code": "def get_contours_center(img, contours):\n    centers = []\n    for c in contours:\n        cx, cy = find_centroid(img, c)\n        centers.append((cx, cy))\n    return centers"}
{"nl": "the contours' centre, please", "code": "def get_contours_center(img, contours):\n    centers = []\n    for c in contours:\n        cx, cy = find_centroid(img, c)\n        centers.append((cx, cy))\n    return centers"}
{"nl": "obtain the contours' centre ", "code": "def get_contours_center(img, contours):\n    centers = []\n    for c in contours:\n        cx, cy = find_centroid(img, c)\n        centers.append((cx, cy))\n    return centers"}
{"nl": "find the centre of the contours ", "code": "def get_contours_center(img, contours):\n    centers = []\n    for c in contours:\n        cx, cy = find_centroid(img, c)\n        centers.append((cx, cy))\n    return centers"}
{"nl": "contour centre ", "code": "def get_contours_center(img, contours):\n    centers = []\n    for c in contours:\n        cx, cy = find_centroid(img, c)\n        centers.append((cx, cy))\n    return centers"}
{"nl": "get contours' centres", "code": "def get_contours_center(img, contours):\n    centers = []\n    for c in contours:\n        cx, cy = find_centroid(img, c)\n        centers.append((cx, cy))\n    return centers"}
{"nl": "draw a circle at the center of the contours", "code": "def draw_circles(img, centers):\n    img = img.copy()\n    for c in centers:\n        cv2.circle(img, c, 2, (255, 0, 0), 2)\n    return img"}
{"nl": "At the centre of the contours, draw a circle", "code": "def draw_circles(img, centers):\n    img = img.copy()\n    for c in centers:\n        cv2.circle(img, c, 2, (255, 0, 0), 2)\n    return img"}
{"nl": "The centre of the contours should be marked with a circle", "code": "def draw_circles(img, centers):\n    img = img.copy()\n    for c in centers:\n        cv2.circle(img, c, 2, (255, 0, 0), 2)\n    return img"}
{"nl": "At the centre of the contours, trace a circle", "code": "def draw_circles(img, centers):\n    img = img.copy()\n    for c in centers:\n        cv2.circle(img, c, 2, (255, 0, 0), 2)\n    return img"}
{"nl": "In the centre of the contours, draw a circle", "code": "def draw_circles(img, centers):\n    img = img.copy()\n    for c in centers:\n        cv2.circle(img, c, 2, (255, 0, 0), 2)\n    return img"}
{"nl": "Make a circle in the centre of the contours", "code": "def draw_circles(img, centers):\n    img = img.copy()\n    for c in centers:\n        cv2.circle(img, c, 2, (255, 0, 0), 2)\n    return img"}
{"nl": "Create a circle in the centre of the outlines", "code": "def draw_circles(img, centers):\n    img = img.copy()\n    for c in centers:\n        cv2.circle(img, c, 2, (255, 0, 0), 2)\n    return img"}
{"nl": "draw a circle in the centre of the contours ", "code": "def draw_circles(img, centers):\n    img = img.copy()\n    for c in centers:\n        cv2.circle(img, c, 2, (255, 0, 0), 2)\n    return img"}
{"nl": "draw a circle at the center of the contours with a specific color", "code": "def draw_circles_with_colors(img, centers):\n    img = img.copy()\n    for c in centers:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.circle(img, c, 2, color, 2)\n    return img"}
{"nl": "With a specified hue, draw a circle in the centre of the contours", "code": "def draw_circles_with_colors(img, centers):\n    img = img.copy()\n    for c in centers:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.circle(img, c, 2, color, 2)\n    return img"}
{"nl": "Draw a circle with a certain colour in the centre of the contours", "code": "def draw_circles_with_colors(img, centers):\n    img = img.copy()\n    for c in centers:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.circle(img, c, 2, color, 2)\n    return img"}
{"nl": "Using a specified hue, create a circle with the contours in its centre", "code": "def draw_circles_with_colors(img, centers):\n    img = img.copy()\n    for c in centers:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.circle(img, c, 2, color, 2)\n    return img"}
{"nl": "Using a specified colour, create a circle in the centre of the contours", "code": "def draw_circles_with_colors(img, centers):\n    img = img.copy()\n    for c in centers:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.circle(img, c, 2, color, 2)\n    return img"}
{"nl": "Create a circle in the middle of the contours and fill it with a particular colour", "code": "def draw_circles_with_colors(img, centers):\n    img = img.copy()\n    for c in centers:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.circle(img, c, 2, color, 2)\n    return img"}
{"nl": "Draw a colour circle in the contours' centre", "code": "def draw_circles_with_colors(img, centers):\n    img = img.copy()\n    for c in centers:\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.circle(img, c, 2, color, 2)\n    return img"}
{"nl": "create a mask for a color range", "code": "def mask_color_range(image, lower_color, upper_color):\n\n    lower = np.array(lower_color, dtype = \"uint8\")\n    upper = np.array(upper_color, dtype = \"uint8\")\n    mask = cv2.inRange(image, lower, upper)\n    output = cv2.bitwise_and(image, image, mask = mask)\n\n"}
{"nl": "calculate the center of mass", "code": "def get_center_of_mass(img, contours):\n    M = cv2.moments(img)\n    return (int(M['m10']/M['m00']), int(M['m01']/M['m00']))"}
{"nl": "to determine the centre of mass ", "code": "def get_center_of_mass(img, contours):\n    M = cv2.moments(img)\n    return (int(M['m10']/M['m00']), int(M['m01']/M['m00']))"}
{"nl": "find the centre of mass ", "code": "def get_center_of_mass(img, contours):\n    M = cv2.moments(img)\n    return (int(M['m10']/M['m00']), int(M['m01']/M['m00']))"}
{"nl": "determine the centre of mass ", "code": "def get_center_of_mass(img, contours):\n    M = cv2.moments(img)\n    return (int(M['m10']/M['m00']), int(M['m01']/M['m00']))"}
{"nl": "centre of mass calculation ", "code": "def get_center_of_mass(img, contours):\n    M = cv2.moments(img)\n    return (int(M['m10']/M['m00']), int(M['m01']/M['m00']))"}
{"nl": "draw the center of mass", "code": "def draw_center_of_mass(img, center_of_mass):\n    img = img.copy()\n    cv2.circle(img, center_of_mass, 2, (255, 0, 0), 2)\n    return img"}
{"nl": "make a diagram showing the centre of mass ", "code": "def draw_center_of_mass(img, center_of_mass):\n    img = img.copy()\n    cv2.circle(img, center_of_mass, 2, (255, 0, 0), 2)\n    return img"}
{"nl": "create the centre of mass ", "code": "def draw_center_of_mass(img, center_of_mass):\n    img = img.copy()\n    cv2.circle(img, center_of_mass, 2, (255, 0, 0), 2)\n    return img"}
{"nl": "Draw the mass's centroid. ", "code": "def draw_center_of_mass(img, center_of_mass):\n    img = img.copy()\n    cv2.circle(img, center_of_mass, 2, (255, 0, 0), 2)\n    return img"}
{"nl": "Make a mass centre diagram. ", "code": "def draw_center_of_mass(img, center_of_mass):\n    img = img.copy()\n    cv2.circle(img, center_of_mass, 2, (255, 0, 0), 2)\n    return img"}
{"nl": "Figure out the mass's centre. ", "code": "def draw_center_of_mass(img, center_of_mass):\n    img = img.copy()\n    cv2.circle(img, center_of_mass, 2, (255, 0, 0), 2)\n    return img"}
{"nl": "Draw the mass's centroid. ", "code": "def draw_center_of_mass(img, center_of_mass):\n    img = img.copy()\n    cv2.circle(img, center_of_mass, 2, (255, 0, 0), 2)\n    return img"}
{"nl": "get the area of each contour", "code": "def get_areas(img, contours):\n    areas = [cv2.contourArea(c) for c in contours]\n    return areas"}
{"nl": "acquire each contour's area ", "code": "def get_areas(img, contours):\n    areas = [cv2.contourArea(c) for c in contours]\n    return areas"}
{"nl": "determine each contour's area", "code": "def get_areas(img, contours):\n    areas = [cv2.contourArea(c) for c in contours]\n    return areas"}
{"nl": "determining the area of each contour ", "code": "def get_areas(img, contours):\n    areas = [cv2.contourArea(c) for c in contours]\n    return areas"}
{"nl": "calculating the area of each contour", "code": "def get_areas(img, contours):\n    areas = [cv2.contourArea(c) for c in contours]\n    return areas"}
{"nl": "obtain the area of every contour", "code": "def get_areas(img, contours):\n    areas = [cv2.contourArea(c) for c in contours]\n    return areas"}
{"nl": "find the area of each contour ", "code": "def get_areas(img, contours):\n    areas = [cv2.contourArea(c) for c in contours]\n    return areas"}
{"nl": "determine the area occupied by each contour", "code": "def get_areas(img, contours):\n    areas = [cv2.contourArea(c) for c in contours]\n    return areas"}
{"nl": "contour area ", "code": "def get_areas(img, contours):\n    areas = [cv2.contourArea(c) for c in contours]\n    return areas"}
{"nl": "area of each contour ", "code": "def get_areas(img, contours):\n    areas = [cv2.contourArea(c) for c in contours]\n    return areas"}
{"nl": "get every contour area ", "code": "def get_areas(img, contours):\n    areas = [cv2.contourArea(c) for c in contours]\n    return areas"}
{"nl": "calculate the aspect ratio of each contour", "code": "def get_aspect_ratios(img, contours):\n    ratios = []\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        ratios.append(float(w)/h)\n    return ratios"}
{"nl": "draw a bounding box around the contours", "code": "def draw_bounding_boxes(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "The contours should be surrounded by a bounding box", "code": "def draw_bounding_boxes(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "around the contours, draw a bounding box", "code": "def draw_bounding_boxes(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "A bounding box should be drawn around the contours", "code": "def draw_bounding_boxes(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "Draw a bounding box around the contours", "code": "def draw_bounding_boxes(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "Create a box around the contours", "code": "def draw_bounding_boxes(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "Make a box around the contours", "code": "def draw_bounding_boxes(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    return img"}
{"nl": "draw a bounding box around the contours with a specific color", "code": "def draw_bounding_boxes_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)\n    return img"}
{"nl": "draw the bounding box around the contours with a specific color", "code": "def draw_bounding_ellipses(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.ellipse(img, (x + int(w/2), y + int(h/2)), (int(w/2), int(h/2)), 0, 0, 360, color, 2)\n    return img"}
{"nl": "draw the bounding box around the contours with a specific color", "code": "def draw_bounding_ellipses_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.ellipse(img, (x + int(w/2), y + int(h/2)), (int(w/2), int(h/2)), 0, 0, 360, color, 2)\n    return img"}
{"nl": "With a specified hue, create a bounding box around the contours. ", "code": "def draw_bounding_ellipses_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.ellipse(img, (x + int(w/2), y + int(h/2)), (int(w/2), int(h/2)), 0, 0, 360, color, 2)\n    return img"}
{"nl": "Using a specified hue, create a bounding box around the contours. ", "code": "def draw_bounding_ellipses_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.ellipse(img, (x + int(w/2), y + int(h/2)), (int(w/2), int(h/2)), 0, 0, 360, color, 2)\n    return img"}
{"nl": "The bounding box around the contours should be drawn using a certain colour. ", "code": "def draw_bounding_ellipses_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.ellipse(img, (x + int(w/2), y + int(h/2)), (int(w/2), int(h/2)), 0, 0, 360, color, 2)\n    return img"}
{"nl": "A certain colour should be used to outline the bounding box. ", "code": "def draw_bounding_ellipses_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.ellipse(img, (x + int(w/2), y + int(h/2)), (int(w/2), int(h/2)), 0, 0, 360, color, 2)\n    return img"}
{"nl": "Draw a specified colour for the bounding box around the contours. ", "code": "def draw_bounding_ellipses_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.ellipse(img, (x + int(w/2), y + int(h/2)), (int(w/2), int(h/2)), 0, 0, 360, color, 2)\n    return img"}
{"nl": "calculate the extreme points of the contours", "code": "def get_extreme_points(contours):\n    extreme_left = tuple(contours[contours[:, :, 0].argmin()][0])\n    extreme_right = tuple(contours[contours[:, :, 0].argmax()][0])\n    extreme_top = tuple(contours[contours[:, :, 1].argmin()][0])\n    extreme_bottom = tuple(contours[contours[:, :, 1].argmax()][0])\n    return extreme_left, extreme_right, extreme_top, extreme_bottom"}
{"nl": "compute the outlines extreme points ", "code": "def get_extreme_points(contours):\n    extreme_left = tuple(contours[contours[:, :, 0].argmin()][0])\n    extreme_right = tuple(contours[contours[:, :, 0].argmax()][0])\n    extreme_top = tuple(contours[contours[:, :, 1].argmin()][0])\n    extreme_bottom = tuple(contours[contours[:, :, 1].argmax()][0])\n    return extreme_left, extreme_right, extreme_top, extreme_bottom"}
{"nl": "determine the outlines extreme points ", "code": "def get_extreme_points(contours):\n    extreme_left = tuple(contours[contours[:, :, 0].argmin()][0])\n    extreme_right = tuple(contours[contours[:, :, 0].argmax()][0])\n    extreme_top = tuple(contours[contours[:, :, 1].argmin()][0])\n    extreme_bottom = tuple(contours[contours[:, :, 1].argmax()][0])\n    return extreme_left, extreme_right, extreme_top, extreme_bottom"}
{"nl": "Calculate the contours extreme points", "code": "def get_extreme_points(contours):\n    extreme_left = tuple(contours[contours[:, :, 0].argmin()][0])\n    extreme_right = tuple(contours[contours[:, :, 0].argmax()][0])\n    extreme_top = tuple(contours[contours[:, :, 1].argmin()][0])\n    extreme_bottom = tuple(contours[contours[:, :, 1].argmax()][0])\n    return extreme_left, extreme_right, extreme_top, extreme_bottom"}
{"nl": "draw the extreme points of the contours", "code": "def draw_extreme_points(img, contours):\n    img = img.copy()\n    left, right, top, bottom = get_extreme_points(contours)\n    cv2.circle(img, left, 5, (0, 0, 255), -1)\n    cv2.circle(img, right, 5, (0, 255, 255), -1)\n    cv2.circle(img, top, 5, (255, 0, 0), -1)\n    cv2.circle(img, bottom, 5, (255, 255, 0), -1)\n    return img"}
{"nl": "calculate the bounding rectangle area", "code": "def get_bounding_rectangle_area(img, contours):\n    _, _, width, height = cv2.boundingRect(contours[0])\n    return width * height"}
{"nl": "calculate the bounding rotated rectangle area", "code": "def get_bounding_rotated_rectangle_area(img, contours):\n    return cv2.minAreaRect(contours[0])[1][0] * cv2.minAreaRect(contours[0])[1][1]"}
{"nl": "draw a line through the center of the contours", "code": "def draw_lines_through_center(img, contours):\n    img = img.copy()\n    for c in contours:\n        cx, cy = find_centroid(img, c)\n        cv2.line(img, (cx, 0), (cx, img.shape[0]), (255, 0, 0), 1)\n        cv2.line(img, (0, cy), (img.shape[1], cy), (255, 0, 0), 1)\n    return img"}
{"nl": "draw a line through the center of the contours with a specific color", "code": "def draw_lines_through_center_with_colors(img, contours):\n    img = img.copy()\n    for c in contours:\n        cx, cy = find_centroid(img, c)\n        color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))\n        cv2.line(img, (cx, 0), (cx, img.shape[0]), color, 2)\n        cv2.line(img, (0, cy), (img.shape[1], cy), color, 2)\n    return img"}
{"nl": "return the length of the contours", "code": "def get_contour_lengths(img, contours):\n    lengths = [cv2.arcLength(c, True) for c in contours]\n    return lengths"}
{"nl": "return the contours' length ", "code": "def get_contour_lengths(img, contours):\n    lengths = [cv2.arcLength(c, True) for c in contours]\n    return lengths"}
{"nl": "give the contours length ", "code": "def get_contour_lengths(img, contours):\n    lengths = [cv2.arcLength(c, True) for c in contours]\n    return lengths"}
{"nl": "provide the contours length ", "code": "def get_contour_lengths(img, contours):\n    lengths = [cv2.arcLength(c, True) for c in contours]\n    return lengths"}
{"nl": "get the center of the bounding rectangle", "code": "def get_bounding_rectangle_centers(img, contours):\n    centers = []\n    for c in contours:\n        x, y, w, h = cv2.boundingRect(c)\n        cx = x + w / 2\n        cy = y + h / 2\n        centers.append((cx, cy))\n    return centers"}
{"nl": "get the center of the minimum enclosing circle", "code": "def get_minimum_enclosing_circle_centers(img, contours):\n    centers = []\n    for c in contours:\n        (x, y), radius = cv2.minEnclosingCircle(c)\n        centers.append((int(x), int(y)))\n    return centers"}
{"nl": "return the length of the contours", "code": "def get_contour_lengths(img, contours):\n    lengths = [cv2.arcLength(c, True) for c in contours]\n    return lengths"}
{"nl": "return the contours' length ", "code": "def get_contour_lengths(img, contours):\n    lengths = [cv2.arcLength(c, True) for c in contours]\n    return lengths"}
{"nl": "give the contours' length ", "code": "def get_contour_lengths(img, contours):\n    lengths = [cv2.arcLength(c, True) for c in contours]\n    return lengths"}
{"nl": "provide the contours' length", "code": "def get_contour_lengths(img, contours):\n    lengths = [cv2.arcLength(c, True) for c in contours]\n    return lengths"}
{"nl": "randomly rotates an image with an angle from -180 to 180", "code": "def random_rotation(image):\n    angle = np.random.uniform(-180, 180)\n    return rotate(image, angle)\n"}
{"nl": "Randomly spins an image from -180 to 180 degrees", "code": "def random_rotation(image):\n    angle = np.random.uniform(-180, 180)\n    return rotate(image, angle)\n"}
{"nl": "Randomly rotates an image's angle between -180 and 180 degrees", "code": "def random_rotation(image):\n    angle = np.random.uniform(-180, 180)\n    return rotate(image, angle)\n"}
{"nl": "A random rotation of 180 degrees is applied to an image", "code": "def random_rotation(image):\n    angle = np.random.uniform(-180, 180)\n    return rotate(image, angle)\n"}
{"nl": "performs a random rotation on a picture using an angle ranging from -180 to 180", "code": "def random_rotation(image):\n    angle = np.random.uniform(-180, 180)\n    return rotate(image, angle)\n"}
{"nl": "transforms an image by a random amount using an angle ranging from -180 to 180", "code": "def random_rotation(image):\n    angle = np.random.uniform(-180, 180)\n    return rotate(image, angle)\n"}
{"nl": "a random rotation with an angle ranging from -180 to 180 degrees is applied to an image", "code": "def random_rotation(image):\n    angle = np.random.uniform(-180, 180)\n    return rotate(image, angle)\n"}
{"nl": "generates a random angle between -180 and 180 degrees for rotating an image", "code": "def random_rotation(image):\n    angle = np.random.uniform(-180, 180)\n    return rotate(image, angle)\n"}
{"nl": "performs a random rotation on a picture using an angle ranging from -180 to 180", "code": "def random_rotation(image):\n    angle = np.random.uniform(-180, 180)\n    return rotate(image, angle)\n"}
{"nl": "random rotation from -180 to 180 ", "code": "def random_rotation(image):\n    angle = np.random.uniform(-180, 180)\n    return rotate(image, angle)\n"}
{"nl": "randomly translates the image both horizontally and vertically", "code": "def Translation(image):\n    transy=np.random.uniform(-0.2,0.2)\n    transx=np.random.uniform(-0.2,0.2)\n    height, width = image.shape[:2]\n    tx, ty = width * transx, height*transy\n    translation_matrix = np.array([[1, 0, tx],[0, 1, ty]], dtype=np.float32)\n    translated_image = cv2.warpAffine(src=image, M=translation_matrix, dsize=(width, height))\n    return translated_image"}
{"nl": "scales the image with a random factor value", "code": "def Scale(image):\n    factor=np.random.uniform(0.8,1.2)\n    scaled_image = cv2.resize(image, (0, 0), fx=factor, fy=factor)\n    return scaled_image"}
{"nl": "scales the picture using a random value", "code": "def Scale(image):\n    factor=np.random.uniform(0.8,1.2)\n    scaled_image = cv2.resize(image, (0, 0), fx=factor, fy=factor)\n    return scaled_image"}
{"nl": "enlarges the picture by a random factor", "code": "def Scale(image):\n    factor=np.random.uniform(0.8,1.2)\n    scaled_image = cv2.resize(image, (0, 0), fx=factor, fy=factor)\n    return scaled_image"}
{"nl": "adjusts the picture shape using a random value ", "code": "def Scale(image):\n    factor=np.random.uniform(0.8,1.2)\n    scaled_image = cv2.resize(image, (0, 0), fx=factor, fy=factor)\n    return scaled_image"}
{"nl": "uses a random factor value to scale the picture", "code": "def Scale(image):\n    factor=np.random.uniform(0.8,1.2)\n    scaled_image = cv2.resize(image, (0, 0), fx=factor, fy=factor)\n    return scaled_image"}
{"nl": "shears the image", "code": "def Shear(image):\n    height, width = image.shape[:2]\n    theta=np.random.uniform(-30,30)\n    M = np.float32([[1, np.tan(theta), 0],[np.tan(theta), 1  , 0],[0, 0  , 1]])  \n    M[0,2] = -M[0,1] * width/2\n    M[1,2] = -M[1,0] * height/2\n    sheared_img = cv2.warpPerspective(image,M,(width,height))\n    return sheared_img"}
{"nl": "shears the picture ", "code": "def Shear(image):\n    height, width = image.shape[:2]\n    theta=np.random.uniform(-30,30)\n    M = np.float32([[1, np.tan(theta), 0],[np.tan(theta), 1  , 0],[0, 0  , 1]])  \n    M[0,2] = -M[0,1] * width/2\n    M[1,2] = -M[1,0] * height/2\n    sheared_img = cv2.warpPerspective(image,M,(width,height))\n    return sheared_img"}
{"nl": "image shears ", "code": "def Shear(image):\n    height, width = image.shape[:2]\n    theta=np.random.uniform(-30,30)\n    M = np.float32([[1, np.tan(theta), 0],[np.tan(theta), 1  , 0],[0, 0  , 1]])  \n    M[0,2] = -M[0,1] * width/2\n    M[1,2] = -M[1,0] * height/2\n    sheared_img = cv2.warpPerspective(image,M,(width,height))\n    return sheared_img"}
{"nl": "cuts the picture. ", "code": "def Shear(image):\n    height, width = image.shape[:2]\n    theta=np.random.uniform(-30,30)\n    M = np.float32([[1, np.tan(theta), 0],[np.tan(theta), 1  , 0],[0, 0  , 1]])  \n    M[0,2] = -M[0,1] * width/2\n    M[1,2] = -M[1,0] * height/2\n    sheared_img = cv2.warpPerspective(image,M,(width,height))\n    return sheared_img"}
{"nl": "shreds the picture ", "code": "def Shear(image):\n    height, width = image.shape[:2]\n    theta=np.random.uniform(-30,30)\n    M = np.float32([[1, np.tan(theta), 0],[np.tan(theta), 1  , 0],[0, 0  , 1]])  \n    M[0,2] = -M[0,1] * width/2\n    M[1,2] = -M[1,0] * height/2\n    sheared_img = cv2.warpPerspective(image,M,(width,height))\n    return sheared_img"}
{"nl": "adds contrast to image", "code": "def Contrast(image):\n    alpha=np.random.uniform(0.2, 1.8)\n    new_image = np.zeros(image.shape, image.dtype)\n    new_image = cv2.convertScaleAbs(image, alpha=alpha, beta=0)\n    return new_image"}
{"nl": "enhances image contrast ", "code": "def Contrast(image):\n    alpha=np.random.uniform(0.2, 1.8)\n    new_image = np.zeros(image.shape, image.dtype)\n    new_image = cv2.convertScaleAbs(image, alpha=alpha, beta=0)\n    return new_image"}
{"nl": "increases image contrast ", "code": "def Contrast(image):\n    alpha=np.random.uniform(0.2, 1.8)\n    new_image = np.zeros(image.shape, image.dtype)\n    new_image = cv2.convertScaleAbs(image, alpha=alpha, beta=0)\n    return new_image"}
{"nl": "improves image contrast ", "code": "def Contrast(image):\n    alpha=np.random.uniform(0.2, 1.8)\n    new_image = np.zeros(image.shape, image.dtype)\n    new_image = cv2.convertScaleAbs(image, alpha=alpha, beta=0)\n    return new_image"}
{"nl": "contrasts the image ", "code": "def Contrast(image):\n    alpha=np.random.uniform(0.2, 1.8)\n    new_image = np.zeros(image.shape, image.dtype)\n    new_image = cv2.convertScaleAbs(image, alpha=alpha, beta=0)\n    return new_image"}
{"nl": "boosts the image's contrast ", "code": "def Contrast(image):\n    alpha=np.random.uniform(0.2, 1.8)\n    new_image = np.zeros(image.shape, image.dtype)\n    new_image = cv2.convertScaleAbs(image, alpha=alpha, beta=0)\n    return new_image"}
{"nl": "changes brightness of image", "code": "def Brightness(image):\n    beta=np.random.uniform(0.2, 1.8)\n    new_image = np.zeros(image.shape, image.dtype)\n    new_image = cv2.convertScaleAbs(image, alpha=1, beta=beta)\n    return new_image"}
{"nl": "alters the image's brightness ", "code": "def Brightness(image):\n    beta=np.random.uniform(0.2, 1.8)\n    new_image = np.zeros(image.shape, image.dtype)\n    new_image = cv2.convertScaleAbs(image, alpha=1, beta=beta)\n    return new_image"}
{"nl": "alterations in picture brightness ", "code": "def Brightness(image):\n    beta=np.random.uniform(0.2, 1.8)\n    new_image = np.zeros(image.shape, image.dtype)\n    new_image = cv2.convertScaleAbs(image, alpha=1, beta=beta)\n    return new_image"}
{"nl": "adjusts the image's brightness ", "code": "def Brightness(image):\n    beta=np.random.uniform(0.2, 1.8)\n    new_image = np.zeros(image.shape, image.dtype)\n    new_image = cv2.convertScaleAbs(image, alpha=1, beta=beta)\n    return new_image"}
{"nl": "Return a sharpened version of the image, using an unsharp mask.", "code": "def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n\n    blurred = cv2.GaussianBlur(image, kernel_size, sigma)\n    sharpened = float(amount + 1) * image - float(amount) * blurred\n    sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))\n    sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))\n    sharpened = sharpened.round().astype(np.uint8)\n    if threshold > 0:\n        low_contrast_mask = np.absolute(image - blurred) < threshold\n        np.copyto(sharpened, image, where=low_contrast_mask)\n    return sharpened"}
{"nl": "Use an unsharp mask to return a sharpened version of the image. ", "code": "def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n\n    blurred = cv2.GaussianBlur(image, kernel_size, sigma)\n    sharpened = float(amount + 1) * image - float(amount) * blurred\n    sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))\n    sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))\n    sharpened = sharpened.round().astype(np.uint8)\n    if threshold > 0:\n        low_contrast_mask = np.absolute(image - blurred) < threshold\n        np.copyto(sharpened, image, where=low_contrast_mask)\n    return sharpened"}
{"nl": "Return the picture with the image sharpened using an unsharp mask. ", "code": "def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n\n    blurred = cv2.GaussianBlur(image, kernel_size, sigma)\n    sharpened = float(amount + 1) * image - float(amount) * blurred\n    sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))\n    sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))\n    sharpened = sharpened.round().astype(np.uint8)\n    if threshold > 0:\n        low_contrast_mask = np.absolute(image - blurred) < threshold\n        np.copyto(sharpened, image, where=low_contrast_mask)\n    return sharpened"}
{"nl": "With the help of an unsharp mask, return a sharpened version of the image. ", "code": "def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n\n    blurred = cv2.GaussianBlur(image, kernel_size, sigma)\n    sharpened = float(amount + 1) * image - float(amount) * blurred\n    sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))\n    sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))\n    sharpened = sharpened.round().astype(np.uint8)\n    if threshold > 0:\n        low_contrast_mask = np.absolute(image - blurred) < threshold\n        np.copyto(sharpened, image, where=low_contrast_mask)\n    return sharpened"}
{"nl": "Return a picture that has been sharpened using an unsharp mask. ", "code": "def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n\n    blurred = cv2.GaussianBlur(image, kernel_size, sigma)\n    sharpened = float(amount + 1) * image - float(amount) * blurred\n    sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))\n    sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))\n    sharpened = sharpened.round().astype(np.uint8)\n    if threshold > 0:\n        low_contrast_mask = np.absolute(image - blurred) < threshold\n        np.copyto(sharpened, image, where=low_contrast_mask)\n    return sharpened"}
{"nl": "Using an unsharp mask, return a sharpened version of the image. ", "code": "def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n\n    blurred = cv2.GaussianBlur(image, kernel_size, sigma)\n    sharpened = float(amount + 1) * image - float(amount) * blurred\n    sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))\n    sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))\n    sharpened = sharpened.round().astype(np.uint8)\n    if threshold > 0:\n        low_contrast_mask = np.absolute(image - blurred) < threshold\n        np.copyto(sharpened, image, where=low_contrast_mask)\n    return sharpened"}
{"nl": "Return an image that has been sharpened by applying an unsharp mask to it", "code": "def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n\n    blurred = cv2.GaussianBlur(image, kernel_size, sigma)\n    sharpened = float(amount + 1) * image - float(amount) * blurred\n    sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))\n    sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))\n    sharpened = sharpened.round().astype(np.uint8)\n    if threshold > 0:\n        low_contrast_mask = np.absolute(image - blurred) < threshold\n        np.copyto(sharpened, image, where=low_contrast_mask)\n    return sharpened"}
{"nl": "Return a version of the image that has been sharpened by employing an unsharp mask", "code": "def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n\n    blurred = cv2.GaussianBlur(image, kernel_size, sigma)\n    sharpened = float(amount + 1) * image - float(amount) * blurred\n    sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))\n    sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))\n    sharpened = sharpened.round().astype(np.uint8)\n    if threshold > 0:\n        low_contrast_mask = np.absolute(image - blurred) < threshold\n        np.copyto(sharpened, image, where=low_contrast_mask)\n    return sharpened"}
{"nl": "Return an unsharp mask-sharpened image", "code": "def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n\n    blurred = cv2.GaussianBlur(image, kernel_size, sigma)\n    sharpened = float(amount + 1) * image - float(amount) * blurred\n    sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))\n    sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))\n    sharpened = sharpened.round().astype(np.uint8)\n    if threshold > 0:\n        low_contrast_mask = np.absolute(image - blurred) < threshold\n        np.copyto(sharpened, image, where=low_contrast_mask)\n    return sharpened"}
{"nl": "Sharpen image using unsharp mask", "code": "def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n\n    blurred = cv2.GaussianBlur(image, kernel_size, sigma)\n    sharpened = float(amount + 1) * image - float(amount) * blurred\n    sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))\n    sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))\n    sharpened = sharpened.round().astype(np.uint8)\n    if threshold > 0:\n        low_contrast_mask = np.absolute(image - blurred) < threshold\n        np.copyto(sharpened, image, where=low_contrast_mask)\n    return sharpened"}
{"nl": "displays an image", "code": "def show_image(img, title='image'):\n    plt.imshow(img)\n    plt.title(title)\n    plt.show()"}
{"nl": "Shows an image", "code": "def show_image(img, title='image'):\n    plt.imshow(img)\n    plt.title(title)\n    plt.show()"}
{"nl": "shows a picture ", "code": "def show_image(img, title='image'):\n    plt.imshow(img)\n    plt.title(title)\n    plt.show()"}
{"nl": "displays a picture ", "code": "def show_image(img, title='image'):\n    plt.imshow(img)\n    plt.title(title)\n    plt.show()"}
{"nl": "a picture is shown ", "code": "def show_image(img, title='image'):\n    plt.imshow(img)\n    plt.title(title)\n    plt.show()"}
{"nl": "show image and mask in one figure with transparent background", "code": "def show_image_and_mask_transparent(img, mask):\n    plt.figure(figsize=(15, 15))\n    plt.subplot(121)\n    plt.imshow(img)\n    plt.imshow(mask, alpha=0.7)\n    plt.show()"}
{"nl": "display picture and mask together in a single figure on a transparent backdrop", "code": "def show_image_and_mask_transparent(img, mask):\n    plt.figure(figsize=(15, 15))\n    plt.subplot(121)\n    plt.imshow(img)\n    plt.imshow(mask, alpha=0.7)\n    plt.show()"}
{"nl": "translucent backdrop with picture and mask combined into one figure ", "code": "def show_image_and_mask_transparent(img, mask):\n    plt.figure(figsize=(15, 15))\n    plt.subplot(121)\n    plt.imshow(img)\n    plt.imshow(mask, alpha=0.7)\n    plt.show()"}
{"nl": "one figure with a transparent backdrop that combines the picture with the mask. ", "code": "def show_image_and_mask_transparent(img, mask):\n    plt.figure(figsize=(15, 15))\n    plt.subplot(121)\n    plt.imshow(img)\n    plt.imshow(mask, alpha=0.7)\n    plt.show()"}
{"nl": "present picture and mask in a single figure with a translucent backdrop. ", "code": "def show_image_and_mask_transparent(img, mask):\n    plt.figure(figsize=(15, 15))\n    plt.subplot(121)\n    plt.imshow(img)\n    plt.imshow(mask, alpha=0.7)\n    plt.show()"}
{"nl": "show image and prediction and label in one figure", "code": "def show_image_and_pred_and_label(img, pred, label):\n    plt.figure(figsize=(15, 15))\n    plt.subplot(131)\n    plt.imshow(img)\n    plt.subplot(132)\n    plt.imshow(pred)\n    plt.subplot(133)\n    plt.imshow(label)\n    plt.show()\n"}
{"nl": "display image, prediction, and label in a single figure", "code": "def show_image_and_pred_and_label(img, pred, label):\n    plt.figure(figsize=(15, 15))\n    plt.subplot(131)\n    plt.imshow(img)\n    plt.subplot(132)\n    plt.imshow(pred)\n    plt.subplot(133)\n    plt.imshow(label)\n    plt.show()\n"}
{"nl": "display the image, prediction, and caption in a single figure ", "code": "def show_image_and_pred_and_label(img, pred, label):\n    plt.figure(figsize=(15, 15))\n    plt.subplot(131)\n    plt.imshow(img)\n    plt.subplot(132)\n    plt.imshow(pred)\n    plt.subplot(133)\n    plt.imshow(label)\n    plt.show()\n"}
{"nl": "show image, prediction, and label in one picture ", "code": "def show_image_and_pred_and_label(img, pred, label):\n    plt.figure(figsize=(15, 15))\n    plt.subplot(131)\n    plt.imshow(img)\n    plt.subplot(132)\n    plt.imshow(pred)\n    plt.subplot(133)\n    plt.imshow(label)\n    plt.show()\n"}
{"nl": "show the picture, the prediction, and the label all in one picture", "code": "def show_image_and_pred_and_label(img, pred, label):\n    plt.figure(figsize=(15, 15))\n    plt.subplot(131)\n    plt.imshow(img)\n    plt.subplot(132)\n    plt.imshow(pred)\n    plt.subplot(133)\n    plt.imshow(label)\n    plt.show()\n"}
{"nl": "use just one figure to illustrate both image and prediction and label ", "code": "def show_image_and_pred_and_label(img, pred, label):\n    plt.figure(figsize=(15, 15))\n    plt.subplot(131)\n    plt.imshow(img)\n    plt.subplot(132)\n    plt.imshow(pred)\n    plt.subplot(133)\n    plt.imshow(label)\n    plt.show()\n"}
{"nl": "image and prediction labelled in a single diagram ", "code": "def show_image_and_pred_and_label(img, pred, label):\n    plt.figure(figsize=(15, 15))\n    plt.subplot(131)\n    plt.imshow(img)\n    plt.subplot(132)\n    plt.imshow(pred)\n    plt.subplot(133)\n    plt.imshow(label)\n    plt.show()\n"}
{"nl": "save an image", "code": "def save_image(path, image):\n    cv2.imwrite(path, image)"}
{"nl": "save a picture ", "code": "def save_image(path, image):\n    cv2.imwrite(path, image)"}
{"nl": "save a photo ", "code": "def save_image(path, image):\n    cv2.imwrite(path, image)"}
{"nl": "convert an image to gray scale", "code": "def convert_to_gray(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)"}
{"nl": "a grayscale conversion of a picture ", "code": "def convert_to_gray(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)"}
{"nl": "a grayscale picture conversion ", "code": "def convert_to_gray(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)"}
{"nl": "picture grayscale conversion ", "code": "def convert_to_gray(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)"}
{"nl": "grayscale an image ", "code": "def convert_to_gray(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)"}
{"nl": "grayscale picture conversion ", "code": "def convert_to_gray(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)"}
{"nl": "Grayscale a picture ", "code": "def convert_to_gray(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)"}
{"nl": "convert an image to hsv", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "convert an image to hsv", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "hsv conversion of a picture", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "hsv conversion of a picture", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "hsv conversion of a picture", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "picture to hsv conversion ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "picture to hsv conversion ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "picture to hsv conversion ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "a picture to hsv conversion ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "a picture to hsv conversion ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "a picture to hsv conversion ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "convert a picture to hsv ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "convert a picture to hsv ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "convert a picture to hsv ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "hsv image conversion ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "hsv image conversion ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "Convert a picture to hsv format", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "Convert a picture to hsv format", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "Image to hsv conversion ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "Image to hsv conversion ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "Image conversion to hsv ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "Image conversion to hsv ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "change a picture to hsv format ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "change a picture to hsv format ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "change an image to hsv ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "change an image to hsv ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "image-to-hsv ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "image-to-hsv ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "image-to-hsv ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "picture-to-hsv converter ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "picture-to-hsv converter ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "You may convert a picture to hsv format", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "You may convert a picture to hsv format", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "converting a picture to hsv format", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "converting a picture to hsv format", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "Perform the conversion of a picture to hsv format", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "Perform the conversion of a picture to hsv format", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "hsv image converter ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "hsv image converter ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "Image to HSV ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "Image to HSV ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "image to hsv ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "image to hsv ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "convert a picture to hsv ", "code": "def convert_to_hsv(image):\n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "convert a picture to hsv ", "code": "def convert_to_hsv(image):\n    \n    \n    return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"}
{"nl": "Convert image to lab", "code": "def to_lab(image):\n    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    return lab_image"}
{"nl": "lab conversion of a picture ", "code": "def to_lab(image):\n  return color.rgb2lab(image)"}
{"nl": "a lab conversion of a picture ", "code": "def to_lab(image):\n    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    return lab_image"}
{"nl": "a lab conversion of a picture ", "code": "def to_lab(image):\n  return color.rgb2lab(image)"}
{"nl": "picture to lab conversion ", "code": "def to_lab(image):\n    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    return lab_image"}
{"nl": "picture to lab conversion ", "code": "def to_lab(image):\n  return color.rgb2lab(image)"}
{"nl": "lab picture conversion ", "code": "def to_lab(image):\n    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    return lab_image"}
{"nl": "lab picture conversion ", "code": "def to_lab(image):\n  return color.rgb2lab(image)"}
{"nl": "convert a picture to lab ", "code": "def to_lab(image):\n    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    return lab_image"}
{"nl": "convert a picture to lab ", "code": "def to_lab(image):\n  return color.rgb2lab(image)"}
{"nl": "lab format picture conversion ", "code": "def to_lab(image):\n    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    return lab_image"}
{"nl": "lab format picture conversion ", "code": "def to_lab(image):\n  return color.rgb2lab(image)"}
{"nl": "convert a picture to lab format ", "code": "def to_lab(image):\n    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    return lab_image"}
{"nl": "convert a picture to lab format ", "code": "def to_lab(image):\n  return color.rgb2lab(image)"}
{"nl": "convert an image to a lab ", "code": "def to_lab(image):\n    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    return lab_image"}
{"nl": "convert an image to a lab ", "code": "def to_lab(image):\n  return color.rgb2lab(image)"}
{"nl": "convert an image to lab format ", "code": "def to_lab(image):\n    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    return lab_image"}
{"nl": "convert an image to lab format ", "code": "def to_lab(image):\n  return color.rgb2lab(image)"}
{"nl": "transform a picture into a lab ", "code": "def to_lab(image):\n    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    return lab_image"}
{"nl": "transform a picture into a lab ", "code": "def to_lab(image):\n  return color.rgb2lab(image)"}
{"nl": "picture to lab format conversion ", "code": "def to_lab(image):\n    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    return lab_image"}
{"nl": "picture to lab format conversion ", "code": "def to_lab(image):\n  return color.rgb2lab(image)"}
{"nl": "converting a picture to lab format ", "code": "def to_lab(image):\n    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    return lab_image"}
{"nl": "converting a picture to lab format ", "code": "def to_lab(image):\n  return color.rgb2lab(image)"}
{"nl": "the process of converting a picture to lab format", "code": "def to_lab(image):\n    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    return lab_image"}
{"nl": "the process of converting a picture to lab format", "code": "def to_lab(image):\n  return color.rgb2lab(image)"}
{"nl": "image-to-lab ", "code": "def to_lab(image):\n    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    return lab_image"}
{"nl": "image-to-lab ", "code": "def to_lab(image):\n  return color.rgb2lab(image)"}
{"nl": "image2lab ", "code": "def to_lab(image):\n    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    return lab_image"}
{"nl": "image2lab ", "code": "def to_lab(image):\n  return color.rgb2lab(image)"}
{"nl": "merge channels into an image", "code": "def merge_image(channels):\n    return cv2.merge(channels)"}
{"nl": "combine channels into a single image ", "code": "def merge_image(channels):\n    return cv2.merge(channels)"}
{"nl": "get a specific channel from an image", "code": "def get_channel(image, channel):\n    return image[:, :, channel]"}
{"nl": "obtain a specific image channel ", "code": "def get_channel(image, channel):\n    return image[:, :, channel]"}
{"nl": "get the histogram of a specific channel", "code": "def get_channel_histogram(image, channel, mask=None):\n    return cv2.calcHist([image], [channel], mask, [256], [0, 256])"}
{"nl": "obtain a specific channel's histogram ", "code": "def get_channel_histogram(image, channel, mask=None):\n    return cv2.calcHist([image], [channel], mask, [256], [0, 256])"}
{"nl": "get the histogram of all channels", "code": "def get_channels_histogram(image, channels, mask=None):\n    histograms = []\n    for channel in channels:\n        histograms.append(get_channel_histogram(image, channel, mask))\n    return histograms"}
{"nl": "obtain a histogram of all channels ", "code": "def get_channels_histogram(image, channels, mask=None):\n    histograms = []\n    for channel in channels:\n        histograms.append(get_channel_histogram(image, channel, mask))\n    return histograms"}
{"nl": "obtain a channel-by-channel histogram ", "code": "def get_channels_histogram(image, channels, mask=None):\n    histograms = []\n    for channel in channels:\n        histograms.append(get_channel_histogram(image, channel, mask))\n    return histograms"}
{"nl": "assemble a histogram for each channel. ", "code": "def get_channels_histogram(image, channels, mask=None):\n    histograms = []\n    for channel in channels:\n        histograms.append(get_channel_histogram(image, channel, mask))\n    return histograms"}
{"nl": "get a channel-by-channel histogram ", "code": "def get_channels_histogram(image, channels, mask=None):\n    histograms = []\n    for channel in channels:\n        histograms.append(get_channel_histogram(image, channel, mask))\n    return histograms"}
{"nl": "make a histogram of all the channels ", "code": "def get_channels_histogram(image, channels, mask=None):\n    histograms = []\n    for channel in channels:\n        histograms.append(get_channel_histogram(image, channel, mask))\n    return histograms"}
{"nl": "get a histogram of all the channels ", "code": "def get_channels_histogram(image, channels, mask=None):\n    histograms = []\n    for channel in channels:\n        histograms.append(get_channel_histogram(image, channel, mask))\n    return histograms"}
{"nl": "get the histogram of an image", "code": "def get_image_histogram(image, mask=None):\n    return cv2.calcHist([image], [0], mask, [256], [0, 256])"}
{"nl": "obtain an image's histogram ", "code": "def get_image_histogram(image, mask=None):\n    return cv2.calcHist([image], [0], mask, [256], [0, 256])"}
{"nl": "obtain an image's histogram ", "code": "def get_image_histogram(image, mask=None):\n    return cv2.calcHist([image], [0], mask, [256], [0, 256])"}
{"nl": "retrieve an image's histogram ", "code": "def get_image_histogram(image, mask=None):\n    return cv2.calcHist([image], [0], mask, [256], [0, 256])"}
{"nl": "to obtain an image's histogram ", "code": "def get_image_histogram(image, mask=None):\n    return cv2.calcHist([image], [0], mask, [256], [0, 256])"}
{"nl": "discover an image's histogram ", "code": "def get_image_histogram(image, mask=None):\n    return cv2.calcHist([image], [0], mask, [256], [0, 256])"}
{"nl": "find an image's histogram ", "code": "def get_image_histogram(image, mask=None):\n    return cv2.calcHist([image], [0], mask, [256], [0, 256])"}
{"nl": "get the cdf of all channels", "code": "def get_channels_cdf(image, channels):\n    cdfs = []\n    for channel in channels:\n        histogram = get_channel_histogram(image, channel)\n        cdf = histogram.cumsum()\n        cdfs.append(cdf)\n    return cdfs"}
{"nl": "obtain the cdf for all channels ", "code": "def get_channels_cdf(image, channels):\n    cdfs = []\n    for channel in channels:\n        histogram = get_channel_histogram(image, channel)\n        cdf = histogram.cumsum()\n        cdfs.append(cdf)\n    return cdfs"}
{"nl": "get the cdf of an image", "code": "def get_image_cdf(image):\n    histogram = get_image_histogram(image)\n    cdf = histogram.cumsum()\n    return cdf"}
{"nl": "obtain an image's cdf ", "code": "def get_image_cdf(image):\n    histogram = get_image_histogram(image)\n    cdf = histogram.cumsum()\n    return cdf"}
{"nl": "equalize an image", "code": "def equalize_image(image, channels):\n    cdfs = get_channels_cdf(image, channels)\n    equalized_image = np.copy(image)\n    for channel, cdf in zip(channels, cdfs):\n        equalized_image[:, :, channel] = cdf[image[:, :, channel]]\n    return equalized_image"}
{"nl": "picture equalisation ", "code": "def equalize_image(image, channels):\n    cdfs = get_channels_cdf(image, channels)\n    equalized_image = np.copy(image)\n    for channel, cdf in zip(channels, cdfs):\n        equalized_image[:, :, channel] = cdf[image[:, :, channel]]\n    return equalized_image"}
{"nl": "image equivalence ", "code": "def equalize_image(image, channels):\n    cdfs = get_channels_cdf(image, channels)\n    equalized_image = np.copy(image)\n    for channel, cdf in zip(channels, cdfs):\n        equalized_image[:, :, channel] = cdf[image[:, :, channel]]\n    return equalized_image"}
{"nl": "Image equalisation ", "code": "def equalize_image(image, channels):\n    cdfs = get_channels_cdf(image, channels)\n    equalized_image = np.copy(image)\n    for channel, cdf in zip(channels, cdfs):\n        equalized_image[:, :, channel] = cdf[image[:, :, channel]]\n    return equalized_image"}
{"nl": "picture equalisation ", "code": "def equalize_image(image, channels):\n    cdfs = get_channels_cdf(image, channels)\n    equalized_image = np.copy(image)\n    for channel, cdf in zip(channels, cdfs):\n        equalized_image[:, :, channel] = cdf[image[:, :, channel]]\n    return equalized_image"}
{"nl": "threshold an image", "code": "def threshold_image(image, threshold):\n    _, thresholded_image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)\n    return thresholded_image"}
{"nl": "thresholding a picture ", "code": "def threshold_image(image, threshold):\n    _, thresholded_image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)\n    return thresholded_image"}
{"nl": "image threshold ", "code": "def threshold_image(image, threshold):\n    _, thresholded_image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)\n    return thresholded_image"}
{"nl": "a picture threshold ", "code": "def threshold_image(image, threshold):\n    _, thresholded_image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)\n    return thresholded_image"}
{"nl": "thresholding an image ", "code": "def threshold_image(image, threshold):\n    _, thresholded_image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)\n    return thresholded_image"}
{"nl": "threshold a photograph ", "code": "def threshold_image(image, threshold):\n    _, thresholded_image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)\n    return thresholded_image"}
{"nl": "threshold a picture ", "code": "def threshold_image(image, threshold):\n    _, thresholded_image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)\n    return thresholded_image"}
{"nl": "threshold an image adaptive", "code": "def threshold_image_adaptive(image, block_size, c):\n    return cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, block_size, c)"}
{"nl": "threshold an image OTSU", "code": "def threshold_image_otsu(image):\n    return cv2.threshold(image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]"}
{"nl": "apply morphological transform to an image", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "apply morphological transform on an image ", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "image morphological transformation ", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "apply morphological transformation to a picture ", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "the transformation of a picture using morphology ", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "perform morphological transformation on an image", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "alter an image using morphological operations ", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "morphologically change an image ", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "perform morphological transformation on a picture ", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "morphological transformation is used on an image", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "transform an image using morphology ", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "Put an image through a morphological transformation", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "morphologically modify an image before using it", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "A morphological transformation should be applied to an image", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "change an image using morphological methods", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "morph image ", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "an image can be transformed using morphological methods ", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "an image can be transformed using morphological techniques ", "code": "def morphological_transform(image, kernel, morph_op):\n    return cv2.morphologyEx(image, morph_op, kernel)"}
{"nl": "erode the image", "code": "def img_erode(img, kernel, iterations):\n    return cv2.erode(img, kernel, iterations = iterations)"}
{"nl": "deteriorate the image ", "code": "def img_erode(img, kernel, iterations):\n    return cv2.erode(img, kernel, iterations = iterations)"}
{"nl": "degrade the image ", "code": "def img_erode(img, kernel, iterations):\n    return cv2.erode(img, kernel, iterations = iterations)"}
{"nl": "destroy the image ", "code": "def img_erode(img, kernel, iterations):\n    return cv2.erode(img, kernel, iterations = iterations)"}
{"nl": "dilate the image", "code": "def img_dilate(img, kernel, iterations):\n    return cv2.dilate(img, kernel, iterations = iterations)"}
{"nl": "canny edge detection", "code": "def img_canny(img, low_threshold, high_threshold):\n    return cv2.Canny(img, low_threshold, high_threshold)"}
{"nl": "sobel edge detection", "code": "def img_sobel(img, x, y, kernel_size):\n    return cv2.Sobel(img, cv2.CV_64F, x, y, ksize = kernel_size)"}
{"nl": "laplacian edge detection", "code": "def img_laplacian(img):\n    return cv2.Laplacian(img, cv2.CV_64F)"}
{"nl": "edge detection using laplacian ", "code": "def img_laplacian(img):\n    return cv2.Laplacian(img, cv2.CV_64F)"}
{"nl": "Laplacian edge recognition ", "code": "def img_laplacian(img):\n    return cv2.Laplacian(img, cv2.CV_64F)"}
{"nl": "Laplacian edge detection ", "code": "def img_laplacian(img):\n    return cv2.Laplacian(img, cv2.CV_64F)"}
{"nl": "median blur filter", "code": "def img_medianBlur(img, kernel_size):\n    return cv2.medianBlur(img, kernel_size)"}
{"nl": "filter for a median blur ", "code": "def img_medianBlur(img, kernel_size):\n    return cv2.medianBlur(img, kernel_size)"}
{"nl": "Use a median blur filter", "code": "def img_medianBlur(img, kernel_size):\n    return cv2.medianBlur(img, kernel_size)"}
{"nl": "Create a median blur filter", "code": "def img_medianBlur(img, kernel_size):\n    return cv2.medianBlur(img, kernel_size)"}
{"nl": "bilateral filter", "code": "def img_bilateralFilter(img, d, sigmaColor, sigmaSpace):\n    return cv2.bilateralFilter(img, d, sigmaColor, sigmaSpace)"}
{"nl": "weighted sum of two images", "code": "def img_addWeighted(img1, w1, img2, w2, gama):\n    return cv2.addWeighted(img1, w1, img2, w2, gama)"}
{"nl": "weighted sum of two photos ", "code": "def img_addWeighted(img1, w1, img2, w2, gama):\n    return cv2.addWeighted(img1, w1, img2, w2, gama)"}
{"nl": "two photos combined, weighted ", "code": "def img_addWeighted(img1, w1, img2, w2, gama):\n    return cv2.addWeighted(img1, w1, img2, w2, gama)"}
{"nl": "find contours", "code": "def img_findContours(img, mode, method):\n    return cv2.findContours(img, mode, method)"}
{"nl": "locate contours ", "code": "def img_findContours(img, mode, method):\n    return cv2.findContours(img, mode, method)"}
{"nl": "look for contours ", "code": "def img_findContours(img, mode, method):\n    return cv2.findContours(img, mode, method)"}
{"nl": "Identify contours ", "code": "def img_findContours(img, mode, method):\n    return cv2.findContours(img, mode, method)"}
{"nl": "discover contours ", "code": "def img_findContours(img, mode, method):\n    return cv2.findContours(img, mode, method)"}
{"nl": "draw contours", "code": "def img_drawContours(img, contours, contourIdx, color, thickness):\n    return cv2.drawContours(img, contours, contourIdx, color, thickness)"}
{"nl": "make contours ", "code": "def img_drawContours(img, contours, contourIdx, color, thickness):\n    return cv2.drawContours(img, contours, contourIdx, color, thickness)"}
{"nl": "create contours ", "code": "def img_drawContours(img, contours, contourIdx, color, thickness):\n    return cv2.drawContours(img, contours, contourIdx, color, thickness)"}
{"nl": "contours should be drawn ", "code": "def img_drawContours(img, contours, contourIdx, color, thickness):\n    return cv2.drawContours(img, contours, contourIdx, color, thickness)"}
{"nl": "sketch contours ", "code": "def img_drawContours(img, contours, contourIdx, color, thickness):\n    return cv2.drawContours(img, contours, contourIdx, color, thickness)"}
{"nl": "produce contours ", "code": "def img_drawContours(img, contours, contourIdx, color, thickness):\n    return cv2.drawContours(img, contours, contourIdx, color, thickness)"}
{"nl": "calculate the contour area", "code": "def img_contourArea(contours):\n    return cv2.contourArea(contours)\n"}
{"nl": "determine the contour area. ", "code": "def img_contourArea(contours):\n    return cv2.contourArea(contours)\n"}
{"nl": "figure out the contour area. ", "code": "def img_contourArea(contours):\n    return cv2.contourArea(contours)\n"}
{"nl": "compute the contour area ", "code": "def img_contourArea(contours):\n    return cv2.contourArea(contours)\n"}
{"nl": "calculate the bounding rectangle", "code": "def img_boundingRect(contours):\n    return cv2.boundingRect(contours)"}
{"nl": "determine the boundary rectangle ", "code": "def img_boundingRect(contours):\n    return cv2.boundingRect(contours)"}
{"nl": "compute the bounding rectangle ", "code": "def img_boundingRect(contours):\n    return cv2.boundingRect(contours)"}
{"nl": "find the enclosing rectangle ", "code": "def img_boundingRect(contours):\n    return cv2.boundingRect(contours)"}
{"nl": "Identify the boundary rectangle", "code": "def img_boundingRect(contours):\n    return cv2.boundingRect(contours)"}
{"nl": "determine the bounded rectangle", "code": "def img_boundingRect(contours):\n    return cv2.boundingRect(contours)"}
{"nl": "calculate the min area rectangle", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "determine the minimum area rectangle", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "the minimum area rectangle, please ", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "the minimum-area rectangle calculation ", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "Determine the minimum area rectangle", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "compute the minimum area rectangle ", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "determine the minimum area rectangle ", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "determine the minimum rectangle area", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "compute the smallest rectangle's area", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "determine the smallest possible rectangle's surface area ", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "Calculate the smallest possible rectangular area ", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "Find the rectangle with the smallest possible area", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "Determine the minimum rectangle's area", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "Find the rectangle with the smallest possible area and calculate it", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "find the rectangle with the smallest possible area", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "minimum rectangular area ", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "rectangle min area ", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "min rectangular area ", "code": "def img_minAreaRect(contours):\n    return cv2.minAreaRect(contours)"}
{"nl": "calculate the moments", "code": "def img_moments(contours):\n    return cv2.moments(contours)"}
{"nl": "compute the moments ", "code": "def img_moments(contours):\n    return cv2.moments(contours)"}
{"nl": "determine the moments ", "code": "def img_moments(contours):\n    return cv2.moments(contours)"}
{"nl": "Determine the moments ", "code": "def img_moments(contours):\n    return cv2.moments(contours)"}
{"nl": "the moments; compute", "code": "def img_moments(contours):\n    return cv2.moments(contours)"}
{"nl": "compute the moments ", "code": "def img_moments(contours):\n    return cv2.moments(contours)"}
{"nl": "calculate the contour perimeter", "code": "def img_contourPerimeter(contours):\n    return cv2.arcLength(contours, True)"}
{"nl": "the contour perimeter to be calculated ", "code": "def img_contourPerimeter(contours):\n    return cv2.arcLength(contours, True)"}
{"nl": "find the contour perimeter", "code": "def img_contourPerimeter(contours):\n    return cv2.arcLength(contours, True)"}
{"nl": "Do the contour perimeter calculation", "code": "def img_contourPerimeter(contours):\n    return cv2.arcLength(contours, True)"}
{"nl": "determine the contour perimeter", "code": "def img_contourPerimeter(contours):\n    return cv2.arcLength(contours, True)"}
{"nl": "compute the contour perimeter ", "code": "def img_contourPerimeter(contours):\n    return cv2.arcLength(contours, True)"}
{"nl": "compute the perimeter of the contour ", "code": "def img_contourPerimeter(contours):\n    return cv2.arcLength(contours, True)"}
{"nl": "the perimeter of the contour ", "code": "def img_contourPerimeter(contours):\n    return cv2.arcLength(contours, True)"}
{"nl": "calculate the perimeter of the contour", "code": "def img_contourPerimeter(contours):\n    return cv2.arcLength(contours, True)"}
{"nl": "Determine the perimeter of the contour", "code": "def img_contourPerimeter(contours):\n    return cv2.arcLength(contours, True)"}
{"nl": "approximate the contour", "code": "def img_approxPolyDP(contours, epsilon, closed):\n    return cv2.approxPolyDP(contours, epsilon, closed)\n"}
{"nl": "a close approximation of the contour ", "code": "def img_approxPolyDP(contours, epsilon, closed):\n    return cv2.approxPolyDP(contours, epsilon, closed)\n"}
{"nl": "approximating the shape of the contour ", "code": "def img_approxPolyDP(contours, epsilon, closed):\n    return cv2.approxPolyDP(contours, epsilon, closed)\n"}
{"nl": "roughly estimate the contour ", "code": "def img_approxPolyDP(contours, epsilon, closed):\n    return cv2.approxPolyDP(contours, epsilon, closed)\n"}
{"nl": "Estimate the contour", "code": "def img_approxPolyDP(contours, epsilon, closed):\n    return cv2.approxPolyDP(contours, epsilon, closed)\n"}
{"nl": "a rough idea of the curve ", "code": "def img_approxPolyDP(contours, epsilon, closed):\n    return cv2.approxPolyDP(contours, epsilon, closed)\n"}
{"nl": "the contour's approximation ", "code": "def img_approxPolyDP(contours, epsilon, closed):\n    return cv2.approxPolyDP(contours, epsilon, closed)\n"}
{"nl": "contour approximation ", "code": "def img_approxPolyDP(contours, epsilon, closed):\n    return cv2.approxPolyDP(contours, epsilon, closed)\n"}
{"nl": "convex hull on contours", "code": "def img_convexHull(contours):\n    return cv2.convexHull(contours)"}
{"nl": "Convex hull on contours ", "code": "def img_convexHull(contours):\n    return cv2.convexHull(contours)"}
{"nl": "contour convex hull ", "code": "def img_convexHull(contours):\n    return cv2.convexHull(contours)"}
{"nl": "Convex Hull", "code": "def img_convexHull(contours):\n    return cv2.convexHull(contours)"}
{"nl": "convexity defects", "code": "def img_convexityDefects(contours):\n    return cv2.convexityDefects(contours)"}
{"nl": "point polygon test", "code": "def img_pointPolygonTest(contours):\n    return cv2.pointPolygonTest(contours)"}
{"nl": "polygon point test ", "code": "def img_pointPolygonTest(contours):\n    return cv2.pointPolygonTest(contours)"}
{"nl": "Test of point polygons ", "code": "def img_pointPolygonTest(contours):\n    return cv2.pointPolygonTest(contours)"}
{"nl": "the point polygon test ", "code": "def img_pointPolygonTest(contours):\n    return cv2.pointPolygonTest(contours)"}
{"nl": "match shapes", "code": "def img_matchShapes(contours):\n    return cv2.matchShapes(contours)"}
{"nl": "Hough lines detection", "code": "def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):\n    return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"}
{"nl": "The detection of Hough lines ", "code": "def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):\n    return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"}
{"nl": "The search for Hough lines ", "code": "def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):\n    return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"}
{"nl": "The discovery of the Hough lines ", "code": "def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):\n    return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"}
{"nl": "detection of Hough lines ", "code": "def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):\n    return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"}
{"nl": "Finding Hough lines ", "code": "def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):\n    return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"}
{"nl": "Recognition of Hough lines ", "code": "def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):\n    return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"}
{"nl": "Detection of Hough lines ", "code": "def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):\n    return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"}
{"nl": "The search for Hough lines ", "code": "def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):\n    return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"}
{"nl": "Detecting Hough lines ", "code": "def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):\n    return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"}
{"nl": "Hough lines finder ", "code": "def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):\n    return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"}
{"nl": "Hough lines P detection", "code": "def img_HoughLinesP(img, rho, theta, threshold, min_line_length, max_line_gap):\n    return cv2.HoughLinesP(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"}
{"nl": "P detection with Hough lines ", "code": "def img_HoughLinesP(img, rho, theta, threshold, min_line_length, max_line_gap):\n    return cv2.HoughLinesP(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"}
{"nl": "Finding Hough lines P ", "code": "def img_HoughLinesP(img, rho, theta, threshold, min_line_length, max_line_gap):\n    return cv2.HoughLinesP(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"}
{"nl": "Hough circles detection", "code": "def img_HoughCircles(img, method, dp, minDist, param1, param2, minRadius, max_radius):\n    return cv2.HoughCircles(img, method, dp, minDist, param1, param2, minRadius, max_radius)\n"}
{"nl": "blob detection", "code": "def img_blobDetection(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio):\n    return cv2.SimpleBlobDetector(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio)"}
{"nl": "detection of blobs ", "code": "def img_blobDetection(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio):\n    return cv2.SimpleBlobDetector(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio)"}
{"nl": "Detection of blobs ", "code": "def img_blobDetection(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio):\n    return cv2.SimpleBlobDetector(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio)"}
{"nl": "A blob detection ", "code": "def img_blobDetection(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio):\n    return cv2.SimpleBlobDetector(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio)"}
{"nl": "Finding blobs ", "code": "def img_blobDetection(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio):\n    return cv2.SimpleBlobDetector(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio)"}
{"nl": "fast feature detection", "code": "def img_fastFeatureDetector(img):\n    return cv2.FastFeatureDetector(img)"}
{"nl": "quickly detecting features ", "code": "def img_fastFeatureDetector(img):\n    return cv2.FastFeatureDetector(img)"}
{"nl": "rapid feature detection ", "code": "def img_fastFeatureDetector(img):\n    return cv2.FastFeatureDetector(img)"}
{"nl": "rapid recognition of features ", "code": "def img_fastFeatureDetector(img):\n    return cv2.FastFeatureDetector(img)"}
{"nl": "rapid feature identification ", "code": "def img_fastFeatureDetector(img):\n    return cv2.FastFeatureDetector(img)"}
{"nl": "rapid identification of features ", "code": "def img_fastFeatureDetector(img):\n    return cv2.FastFeatureDetector(img)"}
{"nl": "quickly identifying features ", "code": "def img_fastFeatureDetector(img):\n    return cv2.FastFeatureDetector(img)"}
{"nl": "SIFT feature detection", "code": "def img_SIFT(img):\n    return cv2.SIFT(img)"}
{"nl": "detection of SIFT features ", "code": "def img_SIFT(img):\n    return cv2.SIFT(img)"}
{"nl": "Finding SIFT features ", "code": "def img_SIFT(img):\n    return cv2.SIFT(img)"}
{"nl": "Recognition of SIFT features ", "code": "def img_SIFT(img):\n    return cv2.SIFT(img)"}
{"nl": "SIFT feature recognition ", "code": "def img_SIFT(img):\n    return cv2.SIFT(img)"}
{"nl": "SURF feature detection", "code": "def img_SURF(img):\n    return cv2.SURF(img)"}
{"nl": "identification of SURF features ", "code": "def img_SURF(img):\n    return cv2.SURF(img)"}
{"nl": "Finding SURF features ", "code": "def img_SURF(img):\n    return cv2.SURF(img)"}
{"nl": "Recognizing SURF features ", "code": "def img_SURF(img):\n    return cv2.SURF(img)"}
{"nl": "SURF feature identification ", "code": "def img_SURF(img):\n    return cv2.SURF(img)"}
{"nl": "Detection of SURF features ", "code": "def img_SURF(img):\n    return cv2.SURF(img)"}
{"nl": "ORB feature detection", "code": "def img_ORB(img):\n    return cv2.ORB(img)"}
{"nl": "identification of ORB features ", "code": "def img_ORB(img):\n    return cv2.ORB(img)"}
{"nl": "Finding ORB features ", "code": "def img_ORB(img):\n    return cv2.ORB(img)"}
{"nl": "Discovering ORB features ", "code": "def img_ORB(img):\n    return cv2.ORB(img)"}
{"nl": "ORB feature recognition ", "code": "def img_ORB(img):\n    return cv2.ORB(img)"}
{"nl": "BRIEF feature descriptor", "code": "def img_brief(img):\n    return cv2.BRIEF(img)"}
{"nl": "Use BRIEF feature descriptor", "code": "def img_brief(img):\n    return cv2.BRIEF(img)"}
{"nl": "Create BRIEF feature descriptor", "code": "def img_brief(img):\n    return cv2.BRIEF(img)"}
{"nl": "BRISK feature descriptor", "code": "def img_brisk(img):\n    return cv2.BRISK(img)"}
{"nl": "Use BRISK feature descriptor", "code": "def img_brisk(img):\n    return cv2.BRISK(img)"}
{"nl": "Create BRISK feature descriptor", "code": "def img_brisk(img):\n    return cv2.BRISK(img)"}
{"nl": "FREAK feature descriptor", "code": "def img_freak(img):\n    return cv2.FREAK(img)"}
{"nl": "Use FREAK feature descriptor", "code": "def img_freak(img):\n    return cv2.FREAK(img)"}
{"nl": "Create FREAK feature descriptor", "code": "def img_freak(img):\n    return cv2.FREAK(img)"}
{"nl": "DAISY feature descriptor", "code": "def img_daisy(img):\n    return cv2.DAISY(img)"}
{"nl": "Use DAISY feature descriptor", "code": "def img_daisy(img):\n    return cv2.DAISY(img)"}
{"nl": "Create DAISY feature descriptor", "code": "def img_daisy(img):\n    return cv2.DAISY(img)"}
{"nl": "fHOG feature descriptor", "code": "def img_fhog(img):\n    return cv2.fHOG(img)"}
{"nl": "Use fHOG feature descriptor", "code": "def img_fhog(img):\n    return cv2.fHOG(img)"}
{"nl": "Create fHOG feature descriptor", "code": "def img_fhog(img):\n    return cv2.fHOG(img)"}
{"nl": "HOG feature descriptor", "code": "def img_hog(img):\n    return cv2.HOGDescriptor(img)"}
{"nl": "Use HOG feature descriptor", "code": "def img_hog(img):\n    return cv2.HOGDescriptor(img)"}
{"nl": "Create HOG feature descriptor", "code": "def img_hog(img):\n    return cv2.HOGDescriptor(img)"}
{"nl": "resize an image to triple its shape", "code": "def resize_image(image):\n    return cv2.resize(image, (image.shape[1]*3, image.shape[0]*3))"}
{"nl": "enlarge a picture to thrice its size ", "code": "def resize_image(image):\n    return cv2.resize(image, (image.shape[1]*3, image.shape[0]*3))"}
{"nl": "triple the size of a picture ", "code": "def resize_image(image):\n    return cv2.resize(image, (image.shape[1]*3, image.shape[0]*3))"}
{"nl": "Triple the size of an image ", "code": "def resize_image(image):\n    return cv2.resize(image, (image.shape[1]*3, image.shape[0]*3))"}
{"nl": "picture three times its original size ", "code": "def resize_image(image):\n    return cv2.resize(image, (image.shape[1]*3, image.shape[0]*3))"}
{"nl": "triple the size of a picture ", "code": "def resize_image(image):\n    return cv2.resize(image, (image.shape[1]*3, image.shape[0]*3))"}
{"nl": "three times as large as a picture ", "code": "def resize_image(image):\n    return cv2.resize(image, (image.shape[1]*3, image.shape[0]*3))"}
{"nl": "picture size increased by three times ", "code": "def resize_image(image):\n    return cv2.resize(image, (image.shape[1]*3, image.shape[0]*3))"}
{"nl": "resize an image to 4 times its shape\n", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image"}
{"nl": "Four times the size of a picture ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image"}
{"nl": "picture resizing to 4 times its original size ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image"}
{"nl": "4 times the original picture size ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image"}
{"nl": "enlarge a picture to four times its original size. ", "code": "def resize_image(image):\n    image = cv2.resize(image, (0,0), fx=4, fy=4)\n    return image"}
{"nl": " Rotate image at an angle", "code": "def rotate_image(image, angle):\n    image_center = tuple(np.array(image.shape[1::-1]) / 2)\n    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n    return result"}
{"nl": " Rotate image at an angle", "code": "def rotate_image(img, angle, center=None, scale=1.0):\n    (h, w) = img.shape[:2]\n    if center is None:\n        center = (w // 2, h // 2)\n\n    M = cv2.getRotationMatrix2D(center, angle, scale)\n    rotated = cv2.warpAffine(img, M, (w, h))\n    return rotated\n"}
{"nl": " Rotate image at an angle", "code": "def rotate_image(image, angle):\n    \n    \n    image_center = tuple(np.array(image.shape[1::-1]) / 2)\n    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n    return result"}
{"nl": " Rotate image at an angle", "code": "def rotate_image(image, angle, scale=1.0):\n    \n    \n    w = image.shape[1]\n    h = image.shape[0]\n    rangle = np.deg2rad(angle)\n    nw = (abs(np.sin(rangle) * h) + abs(np.cos(rangle) * w)) * scale\n    nh = (abs(np.cos(rangle) * h) + abs(np.sin(rangle) * w)) * scale\n    rot_mat = cv2.getRotationMatrix2D((nw * 0.5, nh * 0.5), angle, scale)\n    rot_move = np.dot(rot_mat, np.array([(nw - w) * 0.5, (nh - h) * 0.5, 0]))\n    rot_mat[0, 2] += rot_move[0]\n    rot_mat[1, 2] += rot_move[1]\n    return cv2.warpAffine(image, rot_mat, (int(math.ceil(nw)), int(math.ceil(nh))), flags=cv2.INTER_LANCZOS4)"}
{"nl": " Rotate image at an angle", "code": "def rotate_image(img, angle):\n        rows, cols, _ = img.shape\n        rotation_matrix = cv2.getRotationMatrix2D((cols / 2, rows / 2), angle, 1)\n        return cv2.warpAffine(img, rotation_matrix, (cols, rows))"}
{"nl": " Rotate image at an angle", "code": "def rotate_image(image, angle):\n    (h, w) = image.shape[:2]\n    (cX, cY) = (w // 2, h // 2)\n\n    M = cv2.getRotationMatrix2D((cX, cY), -angle, 1.0)\n    cos = np.abs(M[0, 0])\n    sin = np.abs(M[0, 1])\n\n    nW = int((h * sin) + (w * cos))\n    nH = int((h * cos) + (w * sin))\n\n    M[0, 2] += (nW / 2) - cX\n    M[1, 2] += (nH / 2) - cY\n\n    return cv2.warpAffine(image, M, (nW, nH))"}
{"nl": " Rotate image at an angle", "code": "def rotate_image(img, angle):\n    rows, cols = img.shape[:2]\n    M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)\n    return cv2.warpAffine(img, M, (cols, rows))"}
{"nl": "picture rotation at an angle ", "code": "def rotate_image(image, angle):\n    (h, w) = image.shape[:2]\n    (cX, cY) = (w // 2, h // 2)\n\n    M = cv2.getRotationMatrix2D((cX, cY), -angle, 1.0)\n    cos = np.abs(M[0, 0])\n    sin = np.abs(M[0, 1])\n\n    nW = int((h * sin) + (w * cos))\n    nH = int((h * cos) + (w * sin))\n\n    M[0, 2] += (nW / 2) - cX\n    M[1, 2] += (nH / 2) - cY\n\n    return cv2.warpAffine(image, M, (nW, nH))"}
{"nl": "picture rotation at an angle ", "code": "def rotate_image(image, angle):\n    image_center = tuple(np.array(image.shape[1::-1]) / 2)\n    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n    return result"}
{"nl": "picture rotation at an angle ", "code": "def rotate_image(img, angle, center=None, scale=1.0):\n    (h, w) = img.shape[:2]\n    if center is None:\n        center = (w // 2, h // 2)\n\n    M = cv2.getRotationMatrix2D(center, angle, scale)\n    rotated = cv2.warpAffine(img, M, (w, h))\n    return rotated\n"}
{"nl": "picture rotation at an angle ", "code": "def rotate_image(image, angle):\n    \n    \n    image_center = tuple(np.array(image.shape[1::-1]) / 2)\n    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n    return result"}
{"nl": "picture rotation at an angle ", "code": "def rotate_image(image, angle, scale=1.0):\n    \n    \n    w = image.shape[1]\n    h = image.shape[0]\n    rangle = np.deg2rad(angle)\n    nw = (abs(np.sin(rangle) * h) + abs(np.cos(rangle) * w)) * scale\n    nh = (abs(np.cos(rangle) * h) + abs(np.sin(rangle) * w)) * scale\n    rot_mat = cv2.getRotationMatrix2D((nw * 0.5, nh * 0.5), angle, scale)\n    rot_move = np.dot(rot_mat, np.array([(nw - w) * 0.5, (nh - h) * 0.5, 0]))\n    rot_mat[0, 2] += rot_move[0]\n    rot_mat[1, 2] += rot_move[1]\n    return cv2.warpAffine(image, rot_mat, (int(math.ceil(nw)), int(math.ceil(nh))), flags=cv2.INTER_LANCZOS4)"}
{"nl": "picture rotation at an angle ", "code": "def rotate_image(img, angle):\n        rows, cols, _ = img.shape\n        rotation_matrix = cv2.getRotationMatrix2D((cols / 2, rows / 2), angle, 1)\n        return cv2.warpAffine(img, rotation_matrix, (cols, rows))"}
{"nl": "picture rotation at an angle ", "code": "def rotate_image(image, angle):\n    (h, w) = image.shape[:2]\n    (cX, cY) = (w // 2, h // 2)\n\n    M = cv2.getRotationMatrix2D((cX, cY), -angle, 1.0)\n    cos = np.abs(M[0, 0])\n    sin = np.abs(M[0, 1])\n\n    nW = int((h * sin) + (w * cos))\n    nH = int((h * cos) + (w * sin))\n\n    M[0, 2] += (nW / 2) - cX\n    M[1, 2] += (nH / 2) - cY\n\n    return cv2.warpAffine(image, M, (nW, nH))"}
{"nl": "picture rotation at an angle ", "code": "def rotate_image(img, angle):\n    rows, cols = img.shape[:2]\n    M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)\n    return cv2.warpAffine(img, M, (cols, rows))"}
{"nl": "Picture rotated at an angle", "code": "def rotate_image(img, angle):\n    rows, cols = img.shape[:2]\n    M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)\n    return cv2.warpAffine(img, M, (cols, rows))\n"}
{"nl": "Picture rotated at an angle", "code": "def rotate_image(image, angle):\n    image_center = tuple(np.array(image.shape[1::-1]) / 2)\n    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n    return result"}
{"nl": "Picture rotated at an angle", "code": "def rotate_image(img, angle, center=None, scale=1.0):\n    (h, w) = img.shape[:2]\n    if center is None:\n        center = (w // 2, h // 2)\n\n    M = cv2.getRotationMatrix2D(center, angle, scale)\n    rotated = cv2.warpAffine(img, M, (w, h))\n    return rotated\n"}
{"nl": "Picture rotated at an angle", "code": "def rotate_image(image, angle):\n    \n    \n    image_center = tuple(np.array(image.shape[1::-1]) / 2)\n    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n    return result"}
{"nl": "Picture rotated at an angle", "code": "def rotate_image(image, angle, scale=1.0):\n    \n    \n    w = image.shape[1]\n    h = image.shape[0]\n    rangle = np.deg2rad(angle)\n    nw = (abs(np.sin(rangle) * h) + abs(np.cos(rangle) * w)) * scale\n    nh = (abs(np.cos(rangle) * h) + abs(np.sin(rangle) * w)) * scale\n    rot_mat = cv2.getRotationMatrix2D((nw * 0.5, nh * 0.5), angle, scale)\n    rot_move = np.dot(rot_mat, np.array([(nw - w) * 0.5, (nh - h) * 0.5, 0]))\n    rot_mat[0, 2] += rot_move[0]\n    rot_mat[1, 2] += rot_move[1]\n    return cv2.warpAffine(image, rot_mat, (int(math.ceil(nw)), int(math.ceil(nh))), flags=cv2.INTER_LANCZOS4)"}
{"nl": "Picture rotated at an angle", "code": "def rotate_image(img, angle):\n        rows, cols, _ = img.shape\n        rotation_matrix = cv2.getRotationMatrix2D((cols / 2, rows / 2), angle, 1)\n        return cv2.warpAffine(img, rotation_matrix, (cols, rows))"}
{"nl": "Picture rotated at an angle", "code": "def rotate_image(image, angle):\n    (h, w) = image.shape[:2]\n    (cX, cY) = (w // 2, h // 2)\n\n    M = cv2.getRotationMatrix2D((cX, cY), -angle, 1.0)\n    cos = np.abs(M[0, 0])\n    sin = np.abs(M[0, 1])\n\n    nW = int((h * sin) + (w * cos))\n    nH = int((h * cos) + (w * sin))\n\n    M[0, 2] += (nW / 2) - cX\n    M[1, 2] += (nH / 2) - cY\n\n    return cv2.warpAffine(image, M, (nW, nH))"}
{"nl": "Picture rotated at an angle", "code": "def rotate_image(img, angle):\n    rows, cols = img.shape[:2]\n    M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)\n    return cv2.warpAffine(img, M, (cols, rows))"}
{"nl": "Image should be rotated at an angle", "code": "def rotate_image(img, angle):\n    rows, cols = img.shape[:2]\n    M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)\n    return cv2.warpAffine(img, M, (cols, rows))\n"}
{"nl": "Image should be rotated at an angle", "code": "def rotate_image(image, angle):\n    image_center = tuple(np.array(image.shape[1::-1]) / 2)\n    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n    return result"}
{"nl": "Image should be rotated at an angle", "code": "def rotate_image(img, angle, center=None, scale=1.0):\n    (h, w) = img.shape[:2]\n    if center is None:\n        center = (w // 2, h // 2)\n\n    M = cv2.getRotationMatrix2D(center, angle, scale)\n    rotated = cv2.warpAffine(img, M, (w, h))\n    return rotated\n"}
{"nl": "Image should be rotated at an angle", "code": "def rotate_image(image, angle):\n    \n    \n    image_center = tuple(np.array(image.shape[1::-1]) / 2)\n    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n    return result"}
{"nl": "Image should be rotated at an angle", "code": "def rotate_image(image, angle, scale=1.0):\n    \n    \n    w = image.shape[1]\n    h = image.shape[0]\n    rangle = np.deg2rad(angle)\n    nw = (abs(np.sin(rangle) * h) + abs(np.cos(rangle) * w)) * scale\n    nh = (abs(np.cos(rangle) * h) + abs(np.sin(rangle) * w)) * scale\n    rot_mat = cv2.getRotationMatrix2D((nw * 0.5, nh * 0.5), angle, scale)\n    rot_move = np.dot(rot_mat, np.array([(nw - w) * 0.5, (nh - h) * 0.5, 0]))\n    rot_mat[0, 2] += rot_move[0]\n    rot_mat[1, 2] += rot_move[1]\n    return cv2.warpAffine(image, rot_mat, (int(math.ceil(nw)), int(math.ceil(nh))), flags=cv2.INTER_LANCZOS4)"}
{"nl": "Image should be rotated at an angle", "code": "def rotate_image(img, angle):\n        rows, cols, _ = img.shape\n        rotation_matrix = cv2.getRotationMatrix2D((cols / 2, rows / 2), angle, 1)\n        return cv2.warpAffine(img, rotation_matrix, (cols, rows))"}
{"nl": "Image should be rotated at an angle", "code": "def rotate_image(image, angle):\n    (h, w) = image.shape[:2]\n    (cX, cY) = (w // 2, h // 2)\n\n    M = cv2.getRotationMatrix2D((cX, cY), -angle, 1.0)\n    cos = np.abs(M[0, 0])\n    sin = np.abs(M[0, 1])\n\n    nW = int((h * sin) + (w * cos))\n    nH = int((h * cos) + (w * sin))\n\n    M[0, 2] += (nW / 2) - cX\n    M[1, 2] += (nH / 2) - cY\n\n    return cv2.warpAffine(image, M, (nW, nH))"}
{"nl": "Image should be rotated at an angle", "code": "def rotate_image(img, angle):\n    rows, cols = img.shape[:2]\n    M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)\n    return cv2.warpAffine(img, M, (cols, rows))"}
{"nl": "Rotate picture at an angle", "code": "def rotate_image(img, angle):\n    rows, cols = img.shape[:2]\n    M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)\n    return cv2.warpAffine(img, M, (cols, rows))\n"}
{"nl": "Rotate picture at an angle", "code": "def rotate_image(image, angle):\n    image_center = tuple(np.array(image.shape[1::-1]) / 2)\n    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n    return result"}
{"nl": "Rotate picture at an angle", "code": "def rotate_image(img, angle, center=None, scale=1.0):\n    (h, w) = img.shape[:2]\n    if center is None:\n        center = (w // 2, h // 2)\n\n    M = cv2.getRotationMatrix2D(center, angle, scale)\n    rotated = cv2.warpAffine(img, M, (w, h))\n    return rotated\n"}
{"nl": "Rotate picture at an angle", "code": "def rotate_image(image, angle):\n    \n    \n    image_center = tuple(np.array(image.shape[1::-1]) / 2)\n    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n    return result"}
{"nl": "Rotate picture at an angle", "code": "def rotate_image(image, angle, scale=1.0):\n    \n    \n    w = image.shape[1]\n    h = image.shape[0]\n    rangle = np.deg2rad(angle)\n    nw = (abs(np.sin(rangle) * h) + abs(np.cos(rangle) * w)) * scale\n    nh = (abs(np.cos(rangle) * h) + abs(np.sin(rangle) * w)) * scale\n    rot_mat = cv2.getRotationMatrix2D((nw * 0.5, nh * 0.5), angle, scale)\n    rot_move = np.dot(rot_mat, np.array([(nw - w) * 0.5, (nh - h) * 0.5, 0]))\n    rot_mat[0, 2] += rot_move[0]\n    rot_mat[1, 2] += rot_move[1]\n    return cv2.warpAffine(image, rot_mat, (int(math.ceil(nw)), int(math.ceil(nh))), flags=cv2.INTER_LANCZOS4)"}
{"nl": "Rotate picture at an angle", "code": "def rotate_image(img, angle):\n        rows, cols, _ = img.shape\n        rotation_matrix = cv2.getRotationMatrix2D((cols / 2, rows / 2), angle, 1)\n        return cv2.warpAffine(img, rotation_matrix, (cols, rows))"}
{"nl": "Rotate picture at an angle", "code": "def rotate_image(image, angle):\n    (h, w) = image.shape[:2]\n    (cX, cY) = (w // 2, h // 2)\n\n    M = cv2.getRotationMatrix2D((cX, cY), -angle, 1.0)\n    cos = np.abs(M[0, 0])\n    sin = np.abs(M[0, 1])\n\n    nW = int((h * sin) + (w * cos))\n    nH = int((h * cos) + (w * sin))\n\n    M[0, 2] += (nW / 2) - cX\n    M[1, 2] += (nH / 2) - cY\n\n    return cv2.warpAffine(image, M, (nW, nH))"}
{"nl": "Rotate picture at an angle", "code": "def rotate_image(img, angle):\n    rows, cols = img.shape[:2]\n    M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)\n    return cv2.warpAffine(img, M, (cols, rows))"}
{"nl": "The picture may be rotated at an angle", "code": "def rotate_image(img, angle):\n    rows, cols = img.shape[:2]\n    M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)\n    return cv2.warpAffine(img, M, (cols, rows))\n"}
{"nl": "The picture may be rotated at an angle", "code": "def rotate_image(image, angle):\n    image_center = tuple(np.array(image.shape[1::-1]) / 2)\n    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n    return result"}
{"nl": "The picture may be rotated at an angle", "code": "def rotate_image(img, angle, center=None, scale=1.0):\n    (h, w) = img.shape[:2]\n    if center is None:\n        center = (w // 2, h // 2)\n\n    M = cv2.getRotationMatrix2D(center, angle, scale)\n    rotated = cv2.warpAffine(img, M, (w, h))\n    return rotated\n"}
{"nl": "The picture may be rotated at an angle", "code": "def rotate_image(image, angle):\n    \n    \n    image_center = tuple(np.array(image.shape[1::-1]) / 2)\n    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n    return result"}
{"nl": "The picture may be rotated at an angle", "code": "def rotate_image(image, angle, scale=1.0):\n    \n    \n    w = image.shape[1]\n    h = image.shape[0]\n    rangle = np.deg2rad(angle)\n    nw = (abs(np.sin(rangle) * h) + abs(np.cos(rangle) * w)) * scale\n    nh = (abs(np.cos(rangle) * h) + abs(np.sin(rangle) * w)) * scale\n    rot_mat = cv2.getRotationMatrix2D((nw * 0.5, nh * 0.5), angle, scale)\n    rot_move = np.dot(rot_mat, np.array([(nw - w) * 0.5, (nh - h) * 0.5, 0]))\n    rot_mat[0, 2] += rot_move[0]\n    rot_mat[1, 2] += rot_move[1]\n    return cv2.warpAffine(image, rot_mat, (int(math.ceil(nw)), int(math.ceil(nh))), flags=cv2.INTER_LANCZOS4)"}
{"nl": "The picture may be rotated at an angle", "code": "def rotate_image(img, angle):\n        rows, cols, _ = img.shape\n        rotation_matrix = cv2.getRotationMatrix2D((cols / 2, rows / 2), angle, 1)\n        return cv2.warpAffine(img, rotation_matrix, (cols, rows))"}
{"nl": "The picture may be rotated at an angle", "code": "def rotate_image(image, angle):\n    (h, w) = image.shape[:2]\n    (cX, cY) = (w // 2, h // 2)\n\n    M = cv2.getRotationMatrix2D((cX, cY), -angle, 1.0)\n    cos = np.abs(M[0, 0])\n    sin = np.abs(M[0, 1])\n\n    nW = int((h * sin) + (w * cos))\n    nH = int((h * cos) + (w * sin))\n\n    M[0, 2] += (nW / 2) - cX\n    M[1, 2] += (nH / 2) - cY\n\n    return cv2.warpAffine(image, M, (nW, nH))"}
{"nl": "The picture may be rotated at an angle", "code": "def rotate_image(img, angle):\n    rows, cols = img.shape[:2]\n    M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)\n    return cv2.warpAffine(img, M, (cols, rows))"}
{"nl": "Image rotation ", "code": "def rotate_image(img, angle):\n    rows, cols = img.shape[:2]\n    M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)\n    return cv2.warpAffine(img, M, (cols, rows))"}
{"nl": "Image rotation ", "code": "def rotate_image(image, angle):\n    image_center = tuple(np.array(image.shape[1::-1]) / 2)\n    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n    return result"}
{"nl": "Image rotation ", "code": "def rotate_image(img, angle, center=None, scale=1.0):\n    (h, w) = img.shape[:2]\n    if center is None:\n        center = (w // 2, h // 2)\n\n    M = cv2.getRotationMatrix2D(center, angle, scale)\n    rotated = cv2.warpAffine(img, M, (w, h))\n    return rotated\n"}
{"nl": "Image rotation ", "code": "def rotate_image(image, angle):\n    \n    \n    image_center = tuple(np.array(image.shape[1::-1]) / 2)\n    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)\n    return result"}
{"nl": "Image rotation ", "code": "def rotate_image(image, angle, scale=1.0):\n    \n    \n    w = image.shape[1]\n    h = image.shape[0]\n    rangle = np.deg2rad(angle)\n    nw = (abs(np.sin(rangle) * h) + abs(np.cos(rangle) * w)) * scale\n    nh = (abs(np.cos(rangle) * h) + abs(np.sin(rangle) * w)) * scale\n    rot_mat = cv2.getRotationMatrix2D((nw * 0.5, nh * 0.5), angle, scale)\n    rot_move = np.dot(rot_mat, np.array([(nw - w) * 0.5, (nh - h) * 0.5, 0]))\n    rot_mat[0, 2] += rot_move[0]\n    rot_mat[1, 2] += rot_move[1]\n    return cv2.warpAffine(image, rot_mat, (int(math.ceil(nw)), int(math.ceil(nh))), flags=cv2.INTER_LANCZOS4)"}
{"nl": "Image rotation ", "code": "def rotate_image(img, angle):\n        rows, cols, _ = img.shape\n        rotation_matrix = cv2.getRotationMatrix2D((cols / 2, rows / 2), angle, 1)\n        return cv2.warpAffine(img, rotation_matrix, (cols, rows))"}
{"nl": "Image rotation ", "code": "def rotate_image(image, angle):\n    (h, w) = image.shape[:2]\n    (cX, cY) = (w // 2, h // 2)\n\n    M = cv2.getRotationMatrix2D((cX, cY), -angle, 1.0)\n    cos = np.abs(M[0, 0])\n    sin = np.abs(M[0, 1])\n\n    nW = int((h * sin) + (w * cos))\n    nH = int((h * cos) + (w * sin))\n\n    M[0, 2] += (nW / 2) - cX\n    M[1, 2] += (nH / 2) - cY\n\n    return cv2.warpAffine(image, M, (nW, nH))"}
{"nl": "Image rotation ", "code": "def rotate_image(img, angle):\n    rows, cols = img.shape[:2]\n    M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)\n    return cv2.warpAffine(img, M, (cols, rows))\n"}
{"nl": " Flip an image horizontally", "code": "def flip_image_horizontally(image):\n    return cv2.flip(image, 1)"}
{"nl": " Flip an image horizontally", "code": "def flip_image_horizontally(image):\n    return image[:, ::-1]"}
{"nl": " Flip an image horizontally", "code": "def flip_image_horizontally(img, axis=1):\n    if axis == 0:\n        img = img[:,:,::-1]\n        return img\n    else:\n        img = img[:,::-1,:]\n        return img"}
{"nl": "Flip a picture horizontally", "code": "def flip_image_horizontally(image):\n    return cv2.flip(image, 1)"}
{"nl": "Flip a picture horizontally", "code": "def flip_image_horizontally(image):\n    return image[:, ::-1]"}
{"nl": "Flip a picture horizontally", "code": "def flip_image_horizontally(img, axis=1):\n    if axis == 0:\n        img = img[:,:,::-1]\n        return img\n    else:\n        img = img[:,::-1,:]\n        return img"}
{"nl": "Image flipping horizontally", "code": "def flip_image_horizontally(image):\n    return cv2.flip(image, 1)"}
{"nl": "Image flipping horizontally", "code": "def flip_image_horizontally(image):\n    return image[:, ::-1]"}
{"nl": "Image flipping horizontally", "code": "def flip_image_horizontally(img, axis=1):\n    if axis == 0:\n        img = img[:,:,::-1]\n        return img\n    else:\n        img = img[:,::-1,:]\n        return img"}
{"nl": "Flip a picture over horizontally", "code": "def flip_image_horizontally(image):\n    return cv2.flip(image, 1)"}
{"nl": "Flip a picture over horizontally", "code": "def flip_image_horizontally(image):\n    return image[:, ::-1]"}
{"nl": "Flip a picture over horizontally", "code": "def flip_image_horizontally(img, axis=1):\n    if axis == 0:\n        img = img[:,:,::-1]\n        return img\n    else:\n        img = img[:,::-1,:]\n        return img"}
{"nl": "Image reversal ", "code": "def flip_image_horizontally(image):\n    return cv2.flip(image, 1)"}
{"nl": "Image reversal ", "code": "def flip_image_horizontally(image):\n    return image[:, ::-1]"}
{"nl": "Image reversal ", "code": "def flip_image_horizontally(img, axis=1):\n    if axis == 0:\n        img = img[:,:,::-1]\n        return img\n    else:\n        img = img[:,::-1,:]\n        return img"}
{"nl": "Add noise to the image", "code": "def add_noise(image):\n    row, col, ch = image.shape\n    mean = 5\n    var = 20\n    sigma = var ** 0.5\n    gauss = np.random.normal(mean, sigma, (row, col, ch))\n    gauss = gauss.reshape(row, col, ch)\n    noisy = image + gauss\n    return noisy"}
{"nl": "Add noise to the image", "code": "def add_noise(image,prob):\n    output = np.zeros(image.shape,np.uint8)\n    thres = 1 - prob \n    for i in range(image.shape[0]):\n        for j in range(image.shape[1]):\n            rdn = random.random()\n            if rdn < prob:\n                output[i][j] = 0\n            elif rdn > thres:\n                output[i][j] = 255\n            else:\n                output[i][j] = image[i][j]\n    return output"}
{"nl": "Add noise to the image", "code": "def add_noise(image, mean = 0, var = 0.001, amount = 0.004):\n    row,col,ch= image.shape\n    sigma = var**0.5\n    gauss = np.random.normal(mean,sigma,(row,col,ch))\n    gauss = gauss.reshape(row,col,ch)\n    noisy = image + amount*gauss\n    return noisy\n"}
{"nl": "Add noise to the image", "code": "def add_noise(img):\n    rnd_noise = np.random.normal(0, 1, img.shape)\n    img = img + rnd_noise\n    \n    return img\n"}
{"nl": "Add noise to the image", "code": "def add_noise(image, min_sigma=0.1, max_sigma=0.5):\n    sigma = np.random.uniform(min_sigma, max_sigma)\n    noisy = np.clip(image + np.random.normal(scale=sigma, size=image.shape), 50, 150)\n    return noisy\n"}
{"nl": "Add noise to the image", "code": "def add_noise(img, noiseType, noiseAmplitude):\n    if noiseType == \"gaussian\":\n        row,col,ch= img.shape\n        mean = 0\n        var = 0.1\n        sigma = var**0.5\n        gauss = np.random.normal(mean,sigma,(row,col,ch))\n        gauss = gauss.reshape(row,col,ch)\n        noisy = img + gauss\n\n        return noisy\n\n    if noiseType == \"salt and pepper\":\n        row, col, ch = img.shape\n        s_vs_p = 0.5\n        amount = noiseAmplitude\n        out = np.copy(img)\n        num_salt = np.ceil(amount * img.size * s_vs_p)\n        coords = [np.random.randint(0, i - 1, int(num_salt))\n                  for i in img.shape]\n        out[coords] = 1\n\n        num_pepper = np.ceil(amount * img.size * (1. - s_vs_p))\n        coords = [np.random.randint(0, i - 1, int(num_pepper))\n                  for i in img.shape]\n        out[coords] = 0\n        return out\n\n    if noiseType == \"poisson\":\n        vals = len(np.unique(img))\n        vals = 2 ** np.ceil(np.log2(vals))\n        noisy = np.random.poisson(img * vals) / float(vals)\n        return noisy\n\n    if noiseType == \"speckle\":\n        row, col, ch = img.shape\n        gauss = np.random.randn(row, col, ch)\n        gauss = gauss.reshape(row, col, ch)\n        noisy = img + img * gauss\n        return noisy"}
{"nl": "Add noise to the image", "code": "def add_noise(image,probability):\n    output = np.zeros(image.shape,np.uint8)\n    thres = 1 - probability\n    for i in range(image.shape[0]):\n        for j in range(image.shape[1]):\n            rdn = random.random()\n            if rdn < probability:\n                output[i][j] = 0\n            elif rdn > thres:\n                output[i][j] = 255\n            else:\n                output[i][j] = image[i][j]\n    return output"}
{"nl": "Make the image noisier", "code": "def add_noise(image):\n    row, col, ch = image.shape\n    mean = 0\n    var = 0.1\n    sigma = var ** 0.5\n    gauss = np.random.normal(mean, sigma, (row, col, ch))\n    gauss = gauss.reshape(row, col, ch)\n    noisy = image + gauss\n    return noisy"}
{"nl": "Make the image noisier", "code": "def add_noise(image):\n    row, col, ch = image.shape\n    mean = 5\n    var = 20\n    sigma = var ** 0.5\n    gauss = np.random.normal(mean, sigma, (row, col, ch))\n    gauss = gauss.reshape(row, col, ch)\n    noisy = image + gauss\n    return noisy"}
{"nl": "Make the image noisier", "code": "def add_noise(image,prob):\n    output = np.zeros(image.shape,np.uint8)\n    thres = 1 - prob \n    for i in range(image.shape[0]):\n        for j in range(image.shape[1]):\n            rdn = random.random()\n            if rdn < prob:\n                output[i][j] = 0\n            elif rdn > thres:\n                output[i][j] = 255\n            else:\n                output[i][j] = image[i][j]\n    return output"}
{"nl": "Make the image noisier", "code": "def add_noise(image, mean = 0, var = 0.001, amount = 0.004):\n    row,col,ch= image.shape\n    sigma = var**0.5\n    gauss = np.random.normal(mean,sigma,(row,col,ch))\n    gauss = gauss.reshape(row,col,ch)\n    noisy = image + amount*gauss\n    return noisy\n"}
{"nl": "Make the image noisier", "code": "def add_noise(img):\n    rnd_noise = np.random.normal(0, 1, img.shape)\n    img = img + rnd_noise\n    \n    return img\n"}
{"nl": "Make the image noisier", "code": "def add_noise(image, min_sigma=0.1, max_sigma=0.5):\n    sigma = np.random.uniform(min_sigma, max_sigma)\n    noisy = np.clip(image + np.random.normal(scale=sigma, size=image.shape), 50, 150)\n    return noisy\n"}
{"nl": "Make the image noisier", "code": "def add_noise(img, noiseType, noiseAmplitude):\n    if noiseType == \"gaussian\":\n        row,col,ch= img.shape\n        mean = 0\n        var = 0.1\n        sigma = var**0.5\n        gauss = np.random.normal(mean,sigma,(row,col,ch))\n        gauss = gauss.reshape(row,col,ch)\n        noisy = img + gauss\n\n        return noisy\n\n    if noiseType == \"salt and pepper\":\n        row, col, ch = img.shape\n        s_vs_p = 0.5\n        amount = noiseAmplitude\n        out = np.copy(img)\n        num_salt = np.ceil(amount * img.size * s_vs_p)\n        coords = [np.random.randint(0, i - 1, int(num_salt))\n                  for i in img.shape]\n        out[coords] = 1\n\n        num_pepper = np.ceil(amount * img.size * (1. - s_vs_p))\n        coords = [np.random.randint(0, i - 1, int(num_pepper))\n                  for i in img.shape]\n        out[coords] = 0\n        return out\n\n    if noiseType == \"poisson\":\n        vals = len(np.unique(img))\n        vals = 2 ** np.ceil(np.log2(vals))\n        noisy = np.random.poisson(img * vals) / float(vals)\n        return noisy\n\n    if noiseType == \"speckle\":\n        row, col, ch = img.shape\n        gauss = np.random.randn(row, col, ch)\n        gauss = gauss.reshape(row, col, ch)\n        noisy = img + img * gauss\n        return noisy"}
{"nl": "Make the image noisier", "code": "def add_noise(image,probability):\n    output = np.zeros(image.shape,np.uint8)\n    thres = 1 - probability\n    for i in range(image.shape[0]):\n        for j in range(image.shape[1]):\n            rdn = random.random()\n            if rdn < probability:\n                output[i][j] = 0\n            elif rdn > thres:\n                output[i][j] = 255\n            else:\n                output[i][j] = image[i][j]\n    return output"}
{"nl": "Make the image more noisy", "code": "def add_noise(image):\n    row, col, ch = image.shape\n    mean = 0\n    var = 0.1\n    sigma = var ** 0.5\n    gauss = np.random.normal(mean, sigma, (row, col, ch))\n    gauss = gauss.reshape(row, col, ch)\n    noisy = image + gauss\n    return noisy"}
{"nl": "Make the image more noisy", "code": "def add_noise(image):\n    row, col, ch = image.shape\n    mean = 5\n    var = 20\n    sigma = var ** 0.5\n    gauss = np.random.normal(mean, sigma, (row, col, ch))\n    gauss = gauss.reshape(row, col, ch)\n    noisy = image + gauss\n    return noisy"}
{"nl": "Make the image more noisy", "code": "def add_noise(image,prob):\n    output = np.zeros(image.shape,np.uint8)\n    thres = 1 - prob \n    for i in range(image.shape[0]):\n        for j in range(image.shape[1]):\n            rdn = random.random()\n            if rdn < prob:\n                output[i][j] = 0\n            elif rdn > thres:\n                output[i][j] = 255\n            else:\n                output[i][j] = image[i][j]\n    return output"}
{"nl": "Make the image more noisy", "code": "def add_noise(image, mean = 0, var = 0.001, amount = 0.004):\n    row,col,ch= image.shape\n    sigma = var**0.5\n    gauss = np.random.normal(mean,sigma,(row,col,ch))\n    gauss = gauss.reshape(row,col,ch)\n    noisy = image + amount*gauss\n    return noisy\n"}
{"nl": "Make the image more noisy", "code": "def add_noise(img):\n    rnd_noise = np.random.normal(0, 1, img.shape)\n    img = img + rnd_noise\n    \n    return img\n"}
{"nl": "Make the image more noisy", "code": "def add_noise(image, min_sigma=0.1, max_sigma=0.5):\n    sigma = np.random.uniform(min_sigma, max_sigma)\n    noisy = np.clip(image + np.random.normal(scale=sigma, size=image.shape), 50, 150)\n    return noisy\n"}
{"nl": "Make the image more noisy", "code": "def add_noise(img, noiseType, noiseAmplitude):\n    if noiseType == \"gaussian\":\n        row,col,ch= img.shape\n        mean = 0\n        var = 0.1\n        sigma = var**0.5\n        gauss = np.random.normal(mean,sigma,(row,col,ch))\n        gauss = gauss.reshape(row,col,ch)\n        noisy = img + gauss\n\n        return noisy\n\n    if noiseType == \"salt and pepper\":\n        row, col, ch = img.shape\n        s_vs_p = 0.5\n        amount = noiseAmplitude\n        out = np.copy(img)\n        num_salt = np.ceil(amount * img.size * s_vs_p)\n        coords = [np.random.randint(0, i - 1, int(num_salt))\n                  for i in img.shape]\n        out[coords] = 1\n\n        num_pepper = np.ceil(amount * img.size * (1. - s_vs_p))\n        coords = [np.random.randint(0, i - 1, int(num_pepper))\n                  for i in img.shape]\n        out[coords] = 0\n        return out\n\n    if noiseType == \"poisson\":\n        vals = len(np.unique(img))\n        vals = 2 ** np.ceil(np.log2(vals))\n        noisy = np.random.poisson(img * vals) / float(vals)\n        return noisy\n\n    if noiseType == \"speckle\":\n        row, col, ch = img.shape\n        gauss = np.random.randn(row, col, ch)\n        gauss = gauss.reshape(row, col, ch)\n        noisy = img + img * gauss\n        return noisy"}
{"nl": "Make the image more noisy", "code": "def add_noise(image,probability):\n    output = np.zeros(image.shape,np.uint8)\n    thres = 1 - probability\n    for i in range(image.shape[0]):\n        for j in range(image.shape[1]):\n            rdn = random.random()\n            if rdn < probability:\n                output[i][j] = 0\n            elif rdn > thres:\n                output[i][j] = 255\n            else:\n                output[i][j] = image[i][j]\n    return output"}
{"nl": "Boost the image's noise level", "code": "def add_noise(image):\n    row, col, ch = image.shape\n    mean = 0\n    var = 0.1\n    sigma = var ** 0.5\n    gauss = np.random.normal(mean, sigma, (row, col, ch))\n    gauss = gauss.reshape(row, col, ch)\n    noisy = image + gauss\n    return noisy"}
{"nl": "Boost the image's noise level", "code": "def add_noise(image):\n    row, col, ch = image.shape\n    mean = 5\n    var = 20\n    sigma = var ** 0.5\n    gauss = np.random.normal(mean, sigma, (row, col, ch))\n    gauss = gauss.reshape(row, col, ch)\n    noisy = image + gauss\n    return noisy"}
{"nl": "Boost the image's noise level", "code": "def add_noise(image,prob):\n    output = np.zeros(image.shape,np.uint8)\n    thres = 1 - prob \n    for i in range(image.shape[0]):\n        for j in range(image.shape[1]):\n            rdn = random.random()\n            if rdn < prob:\n                output[i][j] = 0\n            elif rdn > thres:\n                output[i][j] = 255\n            else:\n                output[i][j] = image[i][j]\n    return output"}
{"nl": "Boost the image's noise level", "code": "def add_noise(image, mean = 0, var = 0.001, amount = 0.004):\n    row,col,ch= image.shape\n    sigma = var**0.5\n    gauss = np.random.normal(mean,sigma,(row,col,ch))\n    gauss = gauss.reshape(row,col,ch)\n    noisy = image + amount*gauss\n    return noisy\n"}
{"nl": "Boost the image's noise level", "code": "def add_noise(img):\n    rnd_noise = np.random.normal(0, 1, img.shape)\n    img = img + rnd_noise\n    \n    return img\n"}
{"nl": "Boost the image's noise level", "code": "def add_noise(image, min_sigma=0.1, max_sigma=0.5):\n    sigma = np.random.uniform(min_sigma, max_sigma)\n    noisy = np.clip(image + np.random.normal(scale=sigma, size=image.shape), 50, 150)\n    return noisy\n"}
{"nl": "Boost the image's noise level", "code": "def add_noise(img, noiseType, noiseAmplitude):\n    if noiseType == \"gaussian\":\n        row,col,ch= img.shape\n        mean = 0\n        var = 0.1\n        sigma = var**0.5\n        gauss = np.random.normal(mean,sigma,(row,col,ch))\n        gauss = gauss.reshape(row,col,ch)\n        noisy = img + gauss\n\n        return noisy\n\n    if noiseType == \"salt and pepper\":\n        row, col, ch = img.shape\n        s_vs_p = 0.5\n        amount = noiseAmplitude\n        out = np.copy(img)\n        num_salt = np.ceil(amount * img.size * s_vs_p)\n        coords = [np.random.randint(0, i - 1, int(num_salt))\n                  for i in img.shape]\n        out[coords] = 1\n\n        num_pepper = np.ceil(amount * img.size * (1. - s_vs_p))\n        coords = [np.random.randint(0, i - 1, int(num_pepper))\n                  for i in img.shape]\n        out[coords] = 0\n        return out\n\n    if noiseType == \"poisson\":\n        vals = len(np.unique(img))\n        vals = 2 ** np.ceil(np.log2(vals))\n        noisy = np.random.poisson(img * vals) / float(vals)\n        return noisy\n\n    if noiseType == \"speckle\":\n        row, col, ch = img.shape\n        gauss = np.random.randn(row, col, ch)\n        gauss = gauss.reshape(row, col, ch)\n        noisy = img + img * gauss\n        return noisy"}
{"nl": "Boost the image's noise level", "code": "def add_noise(image,probability):\n    output = np.zeros(image.shape,np.uint8)\n    thres = 1 - probability\n    for i in range(image.shape[0]):\n        for j in range(image.shape[1]):\n            rdn = random.random()\n            if rdn < probability:\n                output[i][j] = 0\n            elif rdn > thres:\n                output[i][j] = 255\n            else:\n                output[i][j] = image[i][j]\n    return output"}
{"nl": "Remove noise from an image", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "Remove noise from a photograph ", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "Remove noise from a picture ", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "Remove image noise ", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "picture noise removal", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "Delete the noise from a picture ", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "Eliminating picture noise", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "Get rid of noise in a picture ", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "Take out noise from an image ", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "Eliminate noise from an image ", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "Eliminate unwanted noise from an image", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "Clean up the image by removing the noise", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "Noise removal ", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "Delete image noise ", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "Noise-free image ", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "a picture's noise can be reduced or eliminated ", "code": "def remove_noise(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.medianBlur(img, 5)\n    img = cv2.GaussianBlur(img, (5, 5), 0)\n    return img"}
{"nl": "Remove horizontal lines from an image", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Remove vertical lines from an image", "code": "def remove_vertical_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    vertical_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 25))\n    remove_vertical = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, vertical_kernel, iterations=2)\n    cnts = cv2.findContours(remove_vertical, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img"}
{"nl": "Remove horizontal lines from a photograph ", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Remove horizontal lines from a picture ", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Remove horizontal lines from an image ", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "How to Remove Horizontal Lines from a Photo ", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Eliminate horizontal lines from a picture", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Delete horizontal lines from a photograph", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Eliminate horizontal lines in a photograph", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Get rid of horizontal lines in a picture ", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Getting rid of horizontal lines in a picture", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Take out horizontal lines from an image ", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Take away horizontal lines from an image ", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Take away any lines that are horizontal in an image", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Getting rid of horizontal lines in an image ", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Take away any lines that are horizontal in a picture", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Remove any lines that are horizontal from an image. ", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Picture horizontal lines removed ", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Remove image horizontal lines ", "code": "def remove_horizontal_lines(image):\n    img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    img = cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Show a list of images using matplotlib in a grid with their histograms", "code": "def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):\n    plt.figure()\n    for i, img in enumerate(imgs):\n        plt.subplot(1, len(imgs), i+1)\n        plt.imshow(img, cmap=cmap)\n        if titles is not None:\n            plt.title(titles[i])\n    plt.show()= cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Using Matplotlib, display a grid of photos with associated histograms.", "code": "def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):\n    plt.figure()\n    for i, img in enumerate(imgs):\n        plt.subplot(1, len(imgs), i+1)\n        plt.imshow(img, cmap=cmap)\n        if titles is not None:\n            plt.title(titles[i])\n    plt.show()= cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Using Matplotlib, display a grid of photos along with the histograms for each one.", "code": "def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):\n    plt.figure()\n    for i, img in enumerate(imgs):\n        plt.subplot(1, len(imgs), i+1)\n        plt.imshow(img, cmap=cmap)\n        if titles is not None:\n            plt.title(titles[i])\n    plt.show()= cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Display the histograms of a grid of photos in a list using the Matplotlib library.", "code": "def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):\n    plt.figure()\n    for i, img in enumerate(imgs):\n        plt.subplot(1, len(imgs), i+1)\n        plt.imshow(img, cmap=cmap)\n        if titles is not None:\n            plt.title(titles[i])\n    plt.show()= cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Using Matplotlib, display a grid of photos together with their histograms.", "code": "def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):\n    plt.figure()\n    for i, img in enumerate(imgs):\n        plt.subplot(1, len(imgs), i+1)\n        plt.imshow(img, cmap=cmap)\n        if titles is not None:\n            plt.title(titles[i])\n    plt.show()= cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Show an image using matplotlib with its histogram and cdf", "code": "def show_image_with_histogram_and_cdf(img, title=None, cmap=None):\n    plt.figure()\n    plt.subplot(131)\n    plt.imshow(img, cmap=cmap)\n    plt.title(title)\n    plt.subplot(132)\n    plt.hist(img.ravel(), 256)\n    plt.subplot(133)\n    plt.hist(img.ravel(), 256, cumulative=True)\n    plt.show()    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Display a picture using the Cdfs and histogram from Matplotlib.", "code": "def show_image_with_histogram_and_cdf(img, title=None, cmap=None):\n    plt.figure()\n    plt.subplot(131)\n    plt.imshow(img, cmap=cmap)\n    plt.title(title)\n    plt.subplot(132)\n    plt.hist(img.ravel(), 256)\n    plt.subplot(133)\n    plt.hist(img.ravel(), 256, cumulative=True)\n    plt.show()    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Display an image using Matplotlib, its histogram, and CDFS", "code": "def show_image_with_histogram_and_cdf(img, title=None, cmap=None):\n    plt.figure()\n    plt.subplot(131)\n    plt.imshow(img, cmap=cmap)\n    plt.title(title)\n    plt.subplot(132)\n    plt.hist(img.ravel(), 256)\n    plt.subplot(133)\n    plt.hist(img.ravel(), 256, cumulative=True)\n    plt.show()    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Display a picture using the Cdfs and histogram from Matplotlib.", "code": "def show_image_with_histogram_and_cdf(img, title=None, cmap=None):\n    plt.figure()\n    plt.subplot(131)\n    plt.imshow(img, cmap=cmap)\n    plt.title(title)\n    plt.subplot(132)\n    plt.hist(img.ravel(), 256)\n    plt.subplot(133)\n    plt.hist(img.ravel(), 256, cumulative=True)\n    plt.show()    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Show an image using matplotlib with its histogram and cdf and equalized histogram", "code": "def show_image_with_histogram_and_cdf_and_equalized_histogram(img, title=None, cmap=None):\n    plt.figure()\n    plt.subplot(141)\n    plt.imshow(img, cmap=cmap)\n    plt.title(title)\n    plt.subplot(142)\n    plt.hist(img.ravel(), 256)\n    plt.subplot(143)\n    plt.hist(img.ravel(), 256, cumulative=True)\n    plt.subplot(144)\n    plt.hist(cv2.equalizeHist(img).ravel(), 256)\n    plt.show()"}
{"nl": "Display an image with the histogram, cdf, and equalised histogram from matplotlib.", "code": "def show_image_with_histogram_and_cdf_and_equalized_histogram(img, title=None, cmap=None):\n    plt.figure()\n    plt.subplot(141)\n    plt.imshow(img, cmap=cmap)\n    plt.title(title)\n    plt.subplot(142)\n    plt.hist(img.ravel(), 256)\n    plt.subplot(143)\n    plt.hist(img.ravel(), 256, cumulative=True)\n    plt.subplot(144)\n    plt.hist(cv2.equalizeHist(img).ravel(), 256)\n    plt.show()"}
{"nl": "Using Matplotlib, display an image with its histogram, cdf, and equalised histogram.", "code": "def show_image_with_histogram_and_cdf_and_equalized_histogram(img, title=None, cmap=None):\n    plt.figure()\n    plt.subplot(141)\n    plt.imshow(img, cmap=cmap)\n    plt.title(title)\n    plt.subplot(142)\n    plt.hist(img.ravel(), 256)\n    plt.subplot(143)\n    plt.hist(img.ravel(), 256, cumulative=True)\n    plt.subplot(144)\n    plt.hist(cv2.equalizeHist(img).ravel(), 256)\n    plt.show()"}
{"nl": "Define a function that takes an image, gradient orientation, and threshold min / max values.", "code": "def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    if orient == 'x':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))\n    if orient == 'y':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))\n    scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))\n    binary_output = np.zeros_like(scaled_sobel)\n    binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Create a function that accepts an image, the gradient's direction, and the threshold's minimum and maximum values.", "code": "def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    if orient == 'x':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))\n    if orient == 'y':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))\n    scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))\n    binary_output = np.zeros_like(scaled_sobel)\n    binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Create a function that accepts an image, the gradient's orientation, and the minimum and maximum values for the threshold.", "code": "def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    if orient == 'x':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))\n    if orient == 'y':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))\n    scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))\n    binary_output = np.zeros_like(scaled_sobel)\n    binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Create a function that accepts an image, the gradient's orientation, and the threshold's minimum and maximum values.", "code": "def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    if orient == 'x':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))\n    if orient == 'y':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))\n    scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))\n    binary_output = np.zeros_like(scaled_sobel)\n    binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Define a function to return the magnitude of the gradient for a given sobel kernel size and threshold values", "code": "def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    gradmag = np.sqrt(sobelx**2 + sobely**2)\n    scale_factor = np.max(gradmag)/255 \n    gradmag = (gradmag/scale_factor).astype(np.uint8) \n    binary_output = np.zeros_like(gradmag)\n    binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1\n    return binary_output"}
{"nl": "Create a function that, given a sobel kernel size and threshold value, returns the gradient's magnitude.", "code": "def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    gradmag = np.sqrt(sobelx**2 + sobely**2)\n    scale_factor = np.max(gradmag)/255 \n    gradmag = (gradmag/scale_factor).astype(np.uint8) \n    binary_output = np.zeros_like(gradmag)\n    binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1\n    return binary_output"}
{"nl": "Create a function that returns the gradient's magnitude for a specified sobel kernel size and threshold value.", "code": "def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    gradmag = np.sqrt(sobelx**2 + sobely**2)\n    scale_factor = np.max(gradmag)/255 \n    gradmag = (gradmag/scale_factor).astype(np.uint8) \n    binary_output = np.zeros_like(gradmag)\n    binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1\n    return binary_output"}
{"nl": "Create a function that returns the gradient's magnitude given the threshold and sobel kernel sizes.", "code": "def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    gradmag = np.sqrt(sobelx**2 + sobely**2)\n    scale_factor = np.max(gradmag)/255 \n    gradmag = (gradmag/scale_factor).astype(np.uint8) \n    binary_output = np.zeros_like(gradmag)\n    binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1\n    return binary_output"}
{"nl": "Define a function to threshold an image for a given range and Sobel kernel", "code": "def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))\n    binary_output =  np.zeros_like(absgraddir)\n    binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Create a function to threshold an image using a Sobel kernel and a defined range.", "code": "def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))\n    binary_output =  np.zeros_like(absgraddir)\n    binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Create a thresholding function for an image using the Sobel kernel and the specified range.", "code": "def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))\n    binary_output =  np.zeros_like(absgraddir)\n    binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Create a function that thresholds a picture based on a given range and Sobel kernel.", "code": "def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))\n    binary_output =  np.zeros_like(absgraddir)\n    binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Define a function that thresholds the S-channel of HLS", "code": "def hls_select(img, thresh=(0, 255)):\n    s_channel = hls[:,:,2]\n    binary_output = np.zeros_like(s_channel)\n    binary_output[(s_channel > thresh[0]) & (s_channel <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Create a function to threshold the HLS S-channel.", "code": "def hls_select(img, thresh=(0, 255)):\n    s_channel = hls[:,:,2]\n    binary_output = np.zeros_like(s_channel)\n    binary_output[(s_channel > thresh[0]) & (s_channel <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Establish a function that thresholds the HLS S-channel.", "code": "def hls_select(img, thresh=(0, 255)):\n    s_channel = hls[:,:,2]\n    binary_output = np.zeros_like(s_channel)\n    binary_output[(s_channel > thresh[0]) & (s_channel <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Display a grid of photos with histograms using matplotlib.", "code": "def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):\n    plt.figure()\n    for i, img in enumerate(imgs):\n        plt.subplot(1, len(imgs), i+1)\n        plt.imshow(img, cmap=cmap)\n        if titles is not None:\n            plt.title(titles[i])\n    plt.show()= cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Use matplotlib to show a list of images in a grid with their histograms.", "code": "def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):\n    plt.figure()\n    for i, img in enumerate(imgs):\n        plt.subplot(1, len(imgs), i+1)\n        plt.imshow(img, cmap=cmap)\n        if titles is not None:\n            plt.title(titles[i])\n    plt.show()= cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Using matplotlib, display a grid of photos with associated histograms.", "code": "def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):\n    plt.figure()\n    for i, img in enumerate(imgs):\n        plt.subplot(1, len(imgs), i+1)\n        plt.imshow(img, cmap=cmap)\n        if titles is not None:\n            plt.title(titles[i])\n    plt.show()= cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Display, in a grid format using matplotlib, a list of images\u00a0along with their respective histograms", "code": "def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):\n    plt.figure()\n    for i, img in enumerate(imgs):\n        plt.subplot(1, len(imgs), i+1)\n        plt.imshow(img, cmap=cmap)\n        if titles is not None:\n            plt.title(titles[i])\n    plt.show()= cv2.bitwise_not(img)\n    thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Display an image with its histogram and CDF using matplotlib.", "code": "def show_image_with_histogram_and_cdf(img, title=None, cmap=None):\n    plt.figure()\n    plt.subplot(131)\n    plt.imshow(img, cmap=cmap)\n    plt.title(title)\n    plt.subplot(132)\n    plt.hist(img.ravel(), 256)\n    plt.subplot(133)\n    plt.hist(img.ravel(), 256, cumulative=True)\n    plt.show()    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Display an image with its histogram and CDF using matplotlib.", "code": "def show_image_with_histogram_and_cdf(img, title=None, cmap=None):\n    plt.figure()\n    plt.subplot(131)\n    plt.imshow(img, cmap=cmap)\n    plt.title(title)\n    plt.subplot(132)\n    plt.hist(img.ravel(), 256)\n    plt.subplot(133)\n    plt.hist(img.ravel(), 256, cumulative=True)\n    plt.show()    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n    remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n    cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n    for c in cnts:\n        cv2.drawContours(img, [c], -1, (255, 255, 255), 5)\n    return img\n\n\n\n"}
{"nl": "Display an image with its histogram, CDF, and equalised histogram using matplotlib.", "code": "def show_image_with_histogram_and_cdf_and_equalized_histogram(img, title=None, cmap=None):\n    plt.figure()\n    plt.subplot(141)\n    plt.imshow(img, cmap=cmap)\n    plt.title(title)\n    plt.subplot(142)\n    plt.hist(img.ravel(), 256)\n    plt.subplot(143)\n    plt.hist(img.ravel(), 256, cumulative=True)\n    plt.subplot(144)\n    plt.hist(cv2.equalizeHist(img).ravel(), 256)\n    plt.show()"}
{"nl": "Using matplotlib, display an image with its histogram, cdf, and equalised histogram.", "code": "def show_image_with_histogram_and_cdf_and_equalized_histogram(img, title=None, cmap=None):\n    plt.figure()\n    plt.subplot(141)\n    plt.imshow(img, cmap=cmap)\n    plt.title(title)\n    plt.subplot(142)\n    plt.hist(img.ravel(), 256)\n    plt.subplot(143)\n    plt.hist(img.ravel(), 256, cumulative=True)\n    plt.subplot(144)\n    plt.hist(cv2.equalizeHist(img).ravel(), 256)\n    plt.show()"}
{"nl": "Use matplotlib to display an image with its cdf and equalised cdf.", "code": "def show_image_with_histogram_and_cdf_and_equalized_histogram(img, title=None, cmap=None):\n    plt.figure()\n    plt.subplot(141)\n    plt.imshow(img, cmap=cmap)\n    plt.title(title)\n    plt.subplot(142)\n    plt.hist(img.ravel(), 256)\n    plt.subplot(143)\n    plt.hist(img.ravel(), 256, cumulative=True)\n    plt.subplot(144)\n    plt.hist(cv2.equalizeHist(img).ravel(), 256)\n    plt.show()"}
{"nl": "Using matplotlib, display an image together with its histogram, CDF, and equalised histogram", "code": "def show_image_with_histogram_and_cdf_and_equalized_histogram(img, title=None, cmap=None):\n    plt.figure()\n    plt.subplot(141)\n    plt.imshow(img, cmap=cmap)\n    plt.title(title)\n    plt.subplot(142)\n    plt.hist(img.ravel(), 256)\n    plt.subplot(143)\n    plt.hist(img.ravel(), 256, cumulative=True)\n    plt.subplot(144)\n    plt.hist(cv2.equalizeHist(img).ravel(), 256)\n    plt.show()"}
{"nl": "Create a function that accepts an image, gradient orientation, and min/max threshold values.", "code": "def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    if orient == 'x':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))\n    if orient == 'y':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))\n    scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))\n    binary_output = np.zeros_like(scaled_sobel)\n    binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Define a function which accepts an image, gradient orientation, and minimum and maximum threshold values.", "code": "def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    if orient == 'x':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))\n    if orient == 'y':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))\n    scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))\n    binary_output = np.zeros_like(scaled_sobel)\n    binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Set up a function that takes an image, the direction of the gradient, and the minimum and maximum threshold values.", "code": "def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    if orient == 'x':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))\n    if orient == 'y':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))\n    scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))\n    binary_output = np.zeros_like(scaled_sobel)\n    binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Create a function that accepts a picture, the gradient orientation, and the threshold min/max value ranges as arguments.", "code": "def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    if orient == 'x':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))\n    if orient == 'y':\n        abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))\n    scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))\n    binary_output = np.zeros_like(scaled_sobel)\n    binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Create a function that returns the gradient magnitude for a specified sobel kernel size and threshold settings.", "code": "def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    gradmag = np.sqrt(sobelx**2 + sobely**2)\n    scale_factor = np.max(gradmag)/255 \n    gradmag = (gradmag/scale_factor).astype(np.uint8) \n    binary_output = np.zeros_like(gradmag)\n    binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1\n    return binary_output"}
{"nl": "Define a function that returns the gradient's magnitude for a given sobel kernel size and threshold settings.", "code": "def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    gradmag = np.sqrt(sobelx**2 + sobely**2)\n    scale_factor = np.max(gradmag)/255 \n    gradmag = (gradmag/scale_factor).astype(np.uint8) \n    binary_output = np.zeros_like(gradmag)\n    binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1\n    return binary_output"}
{"nl": "The gradient magnitude for a particular sobel kernel size and threshold value should be defined as a function.", "code": "def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    gradmag = np.sqrt(sobelx**2 + sobely**2)\n    scale_factor = np.max(gradmag)/255 \n    gradmag = (gradmag/scale_factor).astype(np.uint8) \n    binary_output = np.zeros_like(gradmag)\n    binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1\n    return binary_output"}
{"nl": "Define a function that, given the sobel kernel size and threshold values, will return the magnitude of the gradient.", "code": "def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    gradmag = np.sqrt(sobelx**2 + sobely**2)\n    scale_factor = np.max(gradmag)/255 \n    gradmag = (gradmag/scale_factor).astype(np.uint8) \n    binary_output = np.zeros_like(gradmag)\n    binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1\n    return binary_output"}
{"nl": "Define a function and Sobel kernel to threshold a picture for a particular range.", "code": "def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))\n    binary_output =  np.zeros_like(absgraddir)\n    binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Define a function to threshold an image according to a specified range and Sobel kernel.", "code": "def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))\n    binary_output =  np.zeros_like(absgraddir)\n    binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Set up a function to threshold an image for a given range and Sobel kernel.", "code": "def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))\n    binary_output =  np.zeros_like(absgraddir)\n    binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Define a function to threshold a picture using the Sobel kernel for a certain range.", "code": "def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):\n    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)\n    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)\n    absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))\n    binary_output =  np.zeros_like(absgraddir)\n    binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Create a function that defines the HLS S-channel threshold.", "code": "def hls_select(img, thresh=(0, 255)):\n    s_channel = hls[:,:,2]\n    binary_output = np.zeros_like(s_channel)\n    binary_output[(s_channel > thresh[0]) & (s_channel <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Define a thresholding function for the S-channel of HLS", "code": "def hls_select(img, thresh=(0, 255)):\n    s_channel = hls[:,:,2]\n    binary_output = np.zeros_like(s_channel)\n    binary_output[(s_channel > thresh[0]) & (s_channel <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Set up a function that thresholds the S-channel of HLS.", "code": "def hls_select(img, thresh=(0, 255)):\n    s_channel = hls[:,:,2]\n    binary_output = np.zeros_like(s_channel)\n    binary_output[(s_channel > thresh[0]) & (s_channel <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Set the threshold for the S-channel of HLS using a function.", "code": "def hls_select(img, thresh=(0, 255)):\n    s_channel = hls[:,:,2]\n    binary_output = np.zeros_like(s_channel)\n    binary_output[(s_channel > thresh[0]) & (s_channel <= thresh[1])] = 1\n    return binary_output"}
{"nl": "Crop the image", "code": "def crop_image(img):\n    crop_img = img[0:168, 0:300]\n    return crop_img"}
{"nl": "Crop the image", "code": "def crop_image(image, left=10, top=10, right=100, bottom=100):\n    \n    \n    return image[top: bottom + 1, left:right + 1]"}
{"nl": "Crop the image", "code": "def crop_image(image, y_min, y_max, x_min, x_max):\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Crop the image", "code": "def crop_image(img, size=(64, 64)):\n    h, w, _ = img.shape\n    return img[(h - size[1]) // 2:(h + size[1]) // 2, (w - size[0]) // 2:(w + size[0]) // 2, :]"}
{"nl": "Crop the image", "code": "def crop_image(img):\n    img = img.crop((0, 0, img.width, img.height - 100))\n    return img\n"}
{"nl": "Crop the image", "code": "def crop_image(image, x_min, y_min, x_max, y_max):\n   \n\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Crop the image", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "Crop the image", "code": "def crop_image(image, start_row, start_col, end_row, end_col):\n    \n    \n    return image[start_row:end_row, start_col:end_col]"}
{"nl": "Function to crop the image", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "Function to crop the image", "code": "def crop_image(img):\n    crop_img = img[0:168, 0:300]\n    return crop_img"}
{"nl": "Function to crop the image", "code": "def crop_image(image, left=10, top=10, right=100, bottom=100):\n    \n    \n    return image[top: bottom + 1, left:right + 1]"}
{"nl": "Function to crop the image", "code": "def crop_image(image, y_min, y_max, x_min, x_max):\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Function to crop the image", "code": "def crop_image(img, size=(64, 64)):\n    h, w, _ = img.shape\n    return img[(h - size[1]) // 2:(h + size[1]) // 2, (w - size[0]) // 2:(w + size[0]) // 2, :]"}
{"nl": "Function to crop the image", "code": "def crop_image(img):\n    img = img.crop((0, 0, img.width, img.height - 100))\n    return img\n"}
{"nl": "Function to crop the image", "code": "def crop_image(image, x_min, y_min, x_max, y_max):\n   \n\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Function to crop the image", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "Function to crop the image", "code": "def crop_image(image, start_row, start_col, end_row, end_col):\n    \n    \n    return image[start_row:end_row, start_col:end_col]"}
{"nl": "crop the photo ", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "crop the photo ", "code": "def crop_image(img):\n    crop_img = img[0:168, 0:300]\n    return crop_img"}
{"nl": "crop the photo ", "code": "def crop_image(image, left=10, top=10, right=100, bottom=100):\n    \n    \n    return image[top: bottom + 1, left:right + 1]"}
{"nl": "crop the photo ", "code": "def crop_image(image, y_min, y_max, x_min, x_max):\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "crop the photo ", "code": "def crop_image(img, size=(64, 64)):\n    h, w, _ = img.shape\n    return img[(h - size[1]) // 2:(h + size[1]) // 2, (w - size[0]) // 2:(w + size[0]) // 2, :]"}
{"nl": "crop the photo ", "code": "def crop_image(img):\n    img = img.crop((0, 0, img.width, img.height - 100))\n    return img\n"}
{"nl": "crop the photo ", "code": "def crop_image(image, x_min, y_min, x_max, y_max):\n   \n\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "crop the photo ", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "crop the photo ", "code": "def crop_image(image, start_row, start_col, end_row, end_col):\n    \n    \n    return image[start_row:end_row, start_col:end_col]"}
{"nl": "crop the picture ", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "crop the picture ", "code": "def crop_image(img):\n    crop_img = img[0:168, 0:300]\n    return crop_img"}
{"nl": "crop the picture ", "code": "def crop_image(image, left=10, top=10, right=100, bottom=100):\n    \n    \n    return image[top: bottom + 1, left:right + 1]"}
{"nl": "crop the picture ", "code": "def crop_image(image, y_min, y_max, x_min, x_max):\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "crop the picture ", "code": "def crop_image(img, size=(64, 64)):\n    h, w, _ = img.shape\n    return img[(h - size[1]) // 2:(h + size[1]) // 2, (w - size[0]) // 2:(w + size[0]) // 2, :]"}
{"nl": "crop the picture ", "code": "def crop_image(img):\n    img = img.crop((0, 0, img.width, img.height - 100))\n    return img\n"}
{"nl": "crop the picture ", "code": "def crop_image(image, x_min, y_min, x_max, y_max):\n   \n\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "crop the picture ", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "crop the picture ", "code": "def crop_image(image, start_row, start_col, end_row, end_col):\n    \n    \n    return image[start_row:end_row, start_col:end_col]"}
{"nl": "Image cropping", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "Image cropping", "code": "def crop_image(img):\n    crop_img = img[0:168, 0:300]\n    return crop_img"}
{"nl": "Image cropping", "code": "def crop_image(image, left=10, top=10, right=100, bottom=100):\n    \n    \n    return image[top: bottom + 1, left:right + 1]"}
{"nl": "Image cropping", "code": "def crop_image(image, y_min, y_max, x_min, x_max):\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Image cropping", "code": "def crop_image(img, size=(64, 64)):\n    h, w, _ = img.shape\n    return img[(h - size[1]) // 2:(h + size[1]) // 2, (w - size[0]) // 2:(w + size[0]) // 2, :]"}
{"nl": "Image cropping", "code": "def crop_image(img):\n    img = img.crop((0, 0, img.width, img.height - 100))\n    return img\n"}
{"nl": "Image cropping", "code": "def crop_image(image, x_min, y_min, x_max, y_max):\n   \n\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Image cropping", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "Image cropping", "code": "def crop_image(image, start_row, start_col, end_row, end_col):\n    \n    \n    return image[start_row:end_row, start_col:end_col]"}
{"nl": "The image may be resized by cropping it", "code": "def crop_image(image, left=10, top=10, right=100, bottom=100):\n    \n    \n    return image[top: bottom + 1, left:right + 1]"}
{"nl": "The image may be resized by cropping it", "code": "def crop_image(img):\n    crop_img = img[0:168, 0:300]\n    return crop_img"}
{"nl": "The image may be resized by cropping it", "code": "def crop_image(image, left=10, top=10, right=100, bottom=100):\n    \n    \n    return image[top: bottom + 1, left:right + 1]"}
{"nl": "The image may be resized by cropping it", "code": "def crop_image(image, y_min, y_max, x_min, x_max):\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "The image may be resized by cropping it", "code": "def crop_image(img, size=(64, 64)):\n    h, w, _ = img.shape\n    return img[(h - size[1]) // 2:(h + size[1]) // 2, (w - size[0]) // 2:(w + size[0]) // 2, :]"}
{"nl": "The image may be resized by cropping it", "code": "def crop_image(img):\n    img = img.crop((0, 0, img.width, img.height - 100))\n    return img\n"}
{"nl": "The image may be resized by cropping it", "code": "def crop_image(image, x_min, y_min, x_max, y_max):\n   \n\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "The image may be resized by cropping it", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "The image may be resized by cropping it", "code": "def crop_image(image, start_row, start_col, end_row, end_col):\n    \n    \n    return image[start_row:end_row, start_col:end_col]"}
{"nl": "The image should be cropped", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "The image should be cropped", "code": "def crop_image(img):\n    crop_img = img[0:168, 0:300]\n    return crop_img"}
{"nl": "The image should be cropped", "code": "def crop_image(image, left=10, top=10, right=100, bottom=100):\n    \n    \n    return image[top: bottom + 1, left:right + 1]"}
{"nl": "The image should be cropped", "code": "def crop_image(image, y_min, y_max, x_min, x_max):\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "The image should be cropped", "code": "def crop_image(img, size=(64, 64)):\n    h, w, _ = img.shape\n    return img[(h - size[1]) // 2:(h + size[1]) // 2, (w - size[0]) // 2:(w + size[0]) // 2, :]"}
{"nl": "The image should be cropped", "code": "def crop_image(img):\n    img = img.crop((0, 0, img.width, img.height - 100))\n    return img\n"}
{"nl": "The image should be cropped", "code": "def crop_image(image, x_min, y_min, x_max, y_max):\n   \n\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "The image should be cropped", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "The image should be cropped", "code": "def crop_image(image, start_row, start_col, end_row, end_col):\n    \n    \n    return image[start_row:end_row, start_col:end_col]"}
{"nl": "Modify the image by cropping it", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "Modify the image by cropping it", "code": "def crop_image(img):\n    crop_img = img[0:168, 0:300]\n    return crop_img"}
{"nl": "Modify the image by cropping it", "code": "def crop_image(image, left=10, top=10, right=100, bottom=100):\n    \n    \n    return image[top: bottom + 1, left:right + 1]"}
{"nl": "Modify the image by cropping it", "code": "def crop_image(image, y_min, y_max, x_min, x_max):\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Modify the image by cropping it", "code": "def crop_image(img, size=(64, 64)):\n    h, w, _ = img.shape\n    return img[(h - size[1]) // 2:(h + size[1]) // 2, (w - size[0]) // 2:(w + size[0]) // 2, :]"}
{"nl": "Modify the image by cropping it", "code": "def crop_image(img):\n    img = img.crop((0, 0, img.width, img.height - 100))\n    return img\n"}
{"nl": "Modify the image by cropping it", "code": "def crop_image(image, x_min, y_min, x_max, y_max):\n   \n\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Modify the image by cropping it", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "Modify the image by cropping it", "code": "def crop_image(image, start_row, start_col, end_row, end_col):\n    \n    \n    return image[start_row:end_row, start_col:end_col]"}
{"nl": "Remove unwanted parts of the picture by cropping it", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "Remove unwanted parts of the picture by cropping it", "code": "def crop_image(img):\n    crop_img = img[0:168, 0:300]\n    return crop_img"}
{"nl": "Remove unwanted parts of the picture by cropping it", "code": "def crop_image(image, left=10, top=10, right=100, bottom=100):\n    \n    \n    return image[top: bottom + 1, left:right + 1]"}
{"nl": "Remove unwanted parts of the picture by cropping it", "code": "def crop_image(image, y_min, y_max, x_min, x_max):\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Remove unwanted parts of the picture by cropping it", "code": "def crop_image(img, size=(64, 64)):\n    h, w, _ = img.shape\n    return img[(h - size[1]) // 2:(h + size[1]) // 2, (w - size[0]) // 2:(w + size[0]) // 2, :]"}
{"nl": "Remove unwanted parts of the picture by cropping it", "code": "def crop_image(img):\n    img = img.crop((0, 0, img.width, img.height - 100))\n    return img\n"}
{"nl": "Remove unwanted parts of the picture by cropping it", "code": "def crop_image(image, x_min, y_min, x_max, y_max):\n   \n\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Remove unwanted parts of the picture by cropping it", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "Remove unwanted parts of the picture by cropping it", "code": "def crop_image(image, start_row, start_col, end_row, end_col):\n    \n    \n    return image[start_row:end_row, start_col:end_col]"}
{"nl": "Image-crop ", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "Image-crop ", "code": "def crop_image(img):\n    crop_img = img[0:168, 0:300]\n    return crop_img"}
{"nl": "Image-crop ", "code": "def crop_image(image, left=10, top=10, right=100, bottom=100):\n    \n    \n    return image[top: bottom + 1, left:right + 1]"}
{"nl": "Image-crop ", "code": "def crop_image(image, y_min, y_max, x_min, x_max):\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Image-crop ", "code": "def crop_image(img, size=(64, 64)):\n    h, w, _ = img.shape\n    return img[(h - size[1]) // 2:(h + size[1]) // 2, (w - size[0]) // 2:(w + size[0]) // 2, :]"}
{"nl": "Image-crop ", "code": "def crop_image(img):\n    img = img.crop((0, 0, img.width, img.height - 100))\n    return img\n"}
{"nl": "Image-crop ", "code": "def crop_image(image, x_min, y_min, x_max, y_max):\n   \n\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Image-crop ", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "Image-crop ", "code": "def crop_image(image, start_row, start_col, end_row, end_col):\n    \n    \n    return image[start_row:end_row, start_col:end_col]"}
{"nl": "Image crop ", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "Image crop ", "code": "def crop_image(img):\n    crop_img = img[0:168, 0:300]\n    return crop_img"}
{"nl": "Image crop ", "code": "def crop_image(image, left=10, top=10, right=100, bottom=100):\n    \n    \n    return image[top: bottom + 1, left:right + 1]"}
{"nl": "Image crop ", "code": "def crop_image(image, y_min, y_max, x_min, x_max):\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Image crop ", "code": "def crop_image(img, size=(64, 64)):\n    h, w, _ = img.shape\n    return img[(h - size[1]) // 2:(h + size[1]) // 2, (w - size[0]) // 2:(w + size[0]) // 2, :]"}
{"nl": "Image crop ", "code": "def crop_image(img):\n    img = img.crop((0, 0, img.width, img.height - 100))\n    return img\n"}
{"nl": "Image crop ", "code": "def crop_image(image, x_min, y_min, x_max, y_max):\n   \n\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Image crop ", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "Image crop ", "code": "def crop_image(image, start_row, start_col, end_row, end_col):\n    \n    \n    return image[start_row:end_row, start_col:end_col]"}
{"nl": "Crop the picture ", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "Crop the picture ", "code": "def crop_image(img):\n    crop_img = img[0:168, 0:300]\n    return crop_img"}
{"nl": "Crop the picture ", "code": "def crop_image(image, left=10, top=10, right=100, bottom=100):\n    \n    \n    return image[top: bottom + 1, left:right + 1]"}
{"nl": "Crop the picture ", "code": "def crop_image(image, y_min, y_max, x_min, x_max):\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Crop the picture ", "code": "def crop_image(img, size=(64, 64)):\n    h, w, _ = img.shape\n    return img[(h - size[1]) // 2:(h + size[1]) // 2, (w - size[0]) // 2:(w + size[0]) // 2, :]"}
{"nl": "Crop the picture ", "code": "def crop_image(img):\n    img = img.crop((0, 0, img.width, img.height - 100))\n    return img\n"}
{"nl": "Crop the picture ", "code": "def crop_image(image, x_min, y_min, x_max, y_max):\n   \n\n    return image[y_min:y_max, x_min:x_max]\n"}
{"nl": "Crop the picture ", "code": "def crop(input_img, x, y, w, h):\n    \n    \n    return input_img[y:y+h, x:x+w]"}
{"nl": "Crop the picture ", "code": "def crop_image(image, start_row, start_col, end_row, end_col):\n    \n    \n    return image[start_row:end_row, start_col:end_col]"}
{"nl": "calculate the aspect ratio of each contour", "code": "def aspect_ratio(contour):\n    x, y, w, h = cv2.boundingRect(contour)\n    aspect_ratio = float(w)/h\n    return aspect_ratio"}
{"nl": "Calculate each contour's aspect ratio.", "code": "def aspect_ratio(contour):\n    x, y, w, h = cv2.boundingRect(contour)\n    aspect_ratio = float(w)/h\n    return aspect_ratio"}
{"nl": "Each contour's aspect ratio should be calculated.", "code": "def aspect_ratio(contour):\n    x, y, w, h = cv2.boundingRect(contour)\n    aspect_ratio = float(w)/h\n    return aspect_ratio"}
{"nl": "Determine each contour's aspect ratio using the formula.", "code": "def aspect_ratio(contour):\n    x, y, w, h = cv2.boundingRect(contour)\n    aspect_ratio = float(w)/h\n    return aspect_ratio"}
{"nl": "contour aspect ratios", "code": "def aspect_ratio(contour):\n    x, y, w, h = cv2.boundingRect(contour)\n    aspect_ratio = float(w)/h\n    return aspect_ratio"}
{"nl": "Calculate each contour's aspect ratio.", "code": "def aspect_ratio(cnts):\n    aspect_ratios = []\n    for c in cnts:\n        x,y,w,h = cv2.boundingRect(c)\n        aspect_ratios.append(float(w)/h)\n    return aspect_ratios"}
{"nl": "Calculate each contour's aspect ratio.", "code": "def aspect_ratio(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    for cnt in contours:\n        x, y, w, h = cv2.boundingRect(cnt)\n        aspect_ratio = float(w)/h\n        print(aspect_ratio)\n        if aspect_ratio >= 0.95 and aspect_ratio <= 1.05:\n            cv2.drawContours(img, [cnt], 0, (0, 255, 0), 2)\n        else:\n            cv2.drawContours(img, [cnt], 0, (0, 0, 255), 2)\n        return aspect_ratio"}
{"nl": "Each contour's aspect ratio should be calculated.", "code": "def aspect_ratio(cnts):\n    aspect_ratios = []\n    for c in cnts:\n        x,y,w,h = cv2.boundingRect(c)\n        aspect_ratios.append(float(w)/h)\n    return aspect_ratios"}
{"nl": "Each contour's aspect ratio should be calculated.", "code": "def aspect_ratio(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    for cnt in contours:\n        x, y, w, h = cv2.boundingRect(cnt)\n        aspect_ratio = float(w)/h\n        print(aspect_ratio)\n        if aspect_ratio >= 0.95 and aspect_ratio <= 1.05:\n            cv2.drawContours(img, [cnt], 0, (0, 255, 0), 2)\n        else:\n            cv2.drawContours(img, [cnt], 0, (0, 0, 255), 2)\n        return aspect_ratio"}
{"nl": "Determine each contour's aspect ratio using the formula.", "code": "def aspect_ratio(cnts):\n    aspect_ratios = []\n    for c in cnts:\n        x,y,w,h = cv2.boundingRect(c)\n        aspect_ratios.append(float(w)/h)\n    return aspect_ratios"}
{"nl": "Determine each contour's aspect ratio using the formula.", "code": "def aspect_ratio(contours):\n    for c in contours:\n        (x, y, w, h) = cv2.boundingRect(c)\n        aspectRatio = w / float(h)\n        return aspectRatio"}
{"nl": "Determine each contour's aspect ratio using the formula.", "code": "def aspect_ratio(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    for cnt in contours:\n        x, y, w, h = cv2.boundingRect(cnt)\n        aspect_ratio = float(w)/h\n        print(aspect_ratio)\n        if aspect_ratio >= 0.95 and aspect_ratio <= 1.05:\n            cv2.drawContours(img, [cnt], 0, (0, 255, 0), 2)\n        else:\n            cv2.drawContours(img, [cnt], 0, (0, 0, 255), 2)\n        return aspect_ratio"}
{"nl": "contour aspect ratios", "code": "def aspect_ratio(cnts):\n    aspect_ratios = []\n    for c in cnts:\n        x,y,w,h = cv2.boundingRect(c)\n        aspect_ratios.append(float(w)/h)\n    return aspect_ratios"}
{"nl": "contour aspect ratios", "code": "def aspect_ratio(contours):\n    for c in contours:\n        (x, y, w, h) = cv2.boundingRect(c)\n        aspectRatio = w / float(h)\n        return aspectRatio"}
{"nl": "contour aspect ratios", "code": "def aspect_ratio(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    for cnt in contours:\n        x, y, w, h = cv2.boundingRect(cnt)\n        aspect_ratio = float(w)/h\n        print(aspect_ratio)\n        if aspect_ratio >= 0.95 and aspect_ratio <= 1.05:\n            cv2.drawContours(img, [cnt], 0, (0, 255, 0), 2)\n        else:\n            cv2.drawContours(img, [cnt], 0, (0, 0, 255), 2)\n        return aspect_ratio"}
{"nl": "get the center of the bounding rectangle", "code": "def get_center(rect):\n    x = rect[0] + rect[2]/2\n    y = rect[1] + rect[3]/2\n    return (x, y)"}
{"nl": "find the bounding rectangle's centre.", "code": "def find_centre(rect):\n    x, y, w, h = rect\n    return (x + w/2, y + h/2)"}
{"nl": "obtain the bounding rectangle's centre", "code": "def get_centre(rect):\n    x, y, w, h = rect\n    return (x + w/2, y + h/2)"}
{"nl": "find the centre of the rectangle that bounds", "code": "def find_centre(rect):\n    \"\"\"\n    Find the centre of a rectangle.\n\n    Parameters\n    ----------\n    rect : list\n        A list of 4 values (x1, y1, x2, y2) defining the bounding\n        rectangle.\n\n    Returns\n    -------\n    centre : tuple\n        A tuple of 2 values (x, y) defining the centre of the rectangle.\n    \"\"\"\n    x1, y1, x2, y2 = rect\n    x = (x1 + x2) / 2\n    y = (y1 + y2) / 2\n    return (x, y)"}
{"nl": "determine the location of the centre of the bounding rectangle.", "code": "def get_center(cnt):\n    x, y, w, h = cv2.boundingRect(cnt)\n    center = (x + w / 2, y + h / 2)"}
{"nl": "get the center of the bounding rectangle", "code": "\"def find_centre(rect):\n    x, y, w, h = rect\n    return (x + w/2, y + h/2)\""}
{"nl": "get the center of the bounding rectangle", "code": "\"def get_centre(rect):\n    x, y, w, h = rect\n    return (x + w/2, y + h/2)\""}
{"nl": "get the center of the bounding rectangle", "code": "\"def get_center(cnt):\n    x, y, w, h = cv2.boundingRect(cnt)\n    center = (x + w / 2, y + h / 2)\""}
{"nl": "find the bounding rectangle's centre.", "code": "\"def get_center(rect):\n    x = rect[0] + rect[2]/2\n    y = rect[1] + rect[3]/2\n    return (x, y)\""}
{"nl": "find the bounding rectangle's centre.", "code": "\"def get_centre(rect):\n    x, y, w, h = rect\n    return (x + w/2, y + h/2)\""}
{"nl": "find the bounding rectangle's centre.", "code": "\"def find_centre(rect):\n   \n    Find the centre of a rectangle.\n\n    Parameters\n    ----------\n    rect : list\n        A list of 4 values (x1, y1, x2, y2) defining the bounding\n        rectangle.\n\n    Returns\n    -------\n    centre : tuple\n        A tuple of 2 values (x, y) defining the centre of the rectangle.\n   \n    x1, y1, x2, y2 = rect\n    x = (x1 + x2) / 2\n    y = (y1 + y2) / 2\n    return (x, y)\""}
{"nl": "find the bounding rectangle's centre.", "code": "\"def find_centre(rect):\n   \n    Find the centre of a rectangle.\n\n    Parameters\n    ----------\n    rect : list\n        A list of 4 values (x1, y1, x2, y2) defining the bounding\n        rectangle.\n\n    Returns\n    -------\n    centre : tuple\n        A tuple of 2 values (x, y) defining the centre of the rectangle.\n   \n    x1, y1, x2, y2 = rect\n    x = (x1 + x2) / 2\n    y = (y1 + y2) / 2\n    return (x, y)\""}
{"nl": "obtain the bounding rectangle's centre", "code": "\"def get_center(rect):\n    x = rect[0] + rect[2]/2\n    y = rect[1] + rect[3]/2\n    return (x, y)\""}
{"nl": "obtain the bounding rectangle's centre", "code": "\"def find_centre(rect):\n    x, y, w, h = rect\n    return (x + w/2, y + h/2)\""}
{"nl": "obtain the bounding rectangle's centre", "code": "\"def find_centre(rect):\n   \n    Find the centre of a rectangle.\n\n    Parameters\n    ----------\n    rect : list\n        A list of 4 values (x1, y1, x2, y2) defining the bounding\n        rectangle.\n\n    Returns\n    -------\n    centre : tuple\n        A tuple of 2 values (x, y) defining the centre of the rectangle.\n   \n    x1, y1, x2, y2 = rect\n    x = (x1 + x2) / 2\n    y = (y1 + y2) / 2\n    return (x, y)\""}
{"nl": "obtain the bounding rectangle's centre", "code": "\"def get_center(cnt):\n    x, y, w, h = cv2.boundingRect(cnt)\n    center = (x + w / 2, y + h / 2)\""}
{"nl": "find the centre of the rectangle that bounds", "code": "\"def get_center(rect):\n    x = rect[0] + rect[2]/2\n    y = rect[1] + rect[3]/2\n    return (x, y)\""}
{"nl": "find the centre of the rectangle that bounds", "code": "\"def find_centre(rect):\n    x, y, w, h = rect\n    return (x + w/2, y + h/2)\""}
{"nl": "find the centre of the rectangle that bounds", "code": "\"def get_centre(rect):\n    x, y, w, h = rect\n    return (x + w/2, y + h/2)\""}
{"nl": "find the centre of the rectangle that bounds", "code": "\"def get_center(cnt):\n    x, y, w, h = cv2.boundingRect(cnt)\n    center = (x + w / 2, y + h / 2)\""}
{"nl": "determine the location of the centre of the bounding rectangle.", "code": "\"def get_center(rect):\n    x = rect[0] + rect[2]/2\n    y = rect[1] + rect[3]/2\n    return (x, y)\""}
{"nl": "determine the location of the centre of the bounding rectangle.", "code": "\"def find_centre(rect):\n    x, y, w, h = rect\n    return (x + w/2, y + h/2)\""}
{"nl": "determine the location of the centre of the bounding rectangle.", "code": "\"def get_centre(rect):\n    x, y, w, h = rect\n    return (x + w/2, y + h/2)\""}
{"nl": "determine the location of the centre of the bounding rectangle.", "code": "\"def find_centre(rect):\n   \n    Find the centre of a rectangle.\n\n    Parameters\n    ----------\n    rect : list\n        A list of 4 values (x1, y1, x2, y2) defining the bounding\n        rectangle.\n\n    Returns\n    -------\n    centre : tuple\n        A tuple of 2 values (x, y) defining the centre of the rectangle.\n   \n    x1, y1, x2, y2 = rect\n    x = (x1 + x2) / 2\n    y = (y1 + y2) / 2\n    return (x, y)\""}
{"nl": "determine the location of the centre of the bounding rectangle.", "code": "\"def get_center(cnt):\n    x, y, w, h = cv2.boundingRect(cnt)\n    center = (x + w / 2, y + h / 2)\""}
{"nl": "Get minimum enclosing circle of a contour", "code": "def get_contour_min_enclosing_circle(contour):\n   \n    (x, y), radius = cv2.minEnclosingCircle(contour)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get a contour's smallest possible enclosing circle", "code": "def get_minimum_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get the contour's smallest enclosing circle.", "code": "def get_minimum_enclosing_circle(c):\n    (x, y), radius = cv2.minEnclosingCircle(c)\n    center = (int(x), int(y))\n    radius = int(radius)\n    cv2.circle(img, center, radius, (0, 255, 0), 2)\n    return center, radius"}
{"nl": "Get the smallest circumscribing circle of a contour", "code": "def get_minimum_enclosing_circle(image):\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n    blurred = cv2.GaussianBlur(gray, (5, 5), 0)\n\n    thresh = cv2.threshold(blurred, 60, 255, cv2.THRESH_BINARY)[1]\n\n    contours = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    contours = contours[0] if len(contours) == 2 else contours[1]\n\n    for c in contours:\n        ((x, y), radius) = cv2.minEnclosingCircle(c)\n        cv2.circle(image, (int(x), int(y)), int(radius), (0, 255, 0), 2)\n        return x, y, radius"}
{"nl": "Get the smallest possible enclosing circle for a contour.", "code": "def get_min_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get minimum enclosing circle of a contour", "code": "def get_min_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get minimum enclosing circle of a contour", "code": "def get_contour_min_enclosing_circle(contour):\n   \n    (x, y), radius = cv2.minEnclosingCircle(contour)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get minimum enclosing circle of a contour", "code": "def get_minimum_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get minimum enclosing circle of a contour", "code": "def get_minimum_enclosing_circle(c):\n    (x, y), radius = cv2.minEnclosingCircle(c)\n    center = (int(x), int(y))\n    radius = int(radius)\n    cv2.circle(img, center, radius, (0, 255, 0), 2)\n    return center, radius"}
{"nl": "Get minimum enclosing circle of a contour", "code": "def get_minimum_enclosing_circle(image):\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n    blurred = cv2.GaussianBlur(gray, (5, 5), 0)\n\n    thresh = cv2.threshold(blurred, 60, 255, cv2.THRESH_BINARY)[1]\n\n    contours = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    contours = contours[0] if len(contours) == 2 else contours[1]\n\n    for c in contours:\n        ((x, y), radius) = cv2.minEnclosingCircle(c)\n        cv2.circle(image, (int(x), int(y)), int(radius), (0, 255, 0), 2)\n        return x, y, radius"}
{"nl": "Get minimum enclosing circle of a contour", "code": "def get_min_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get a contour's smallest possible enclosing circle", "code": "def get_min_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get a contour's smallest possible enclosing circle", "code": "def get_contour_min_enclosing_circle(contour):\n   \n    (x, y), radius = cv2.minEnclosingCircle(contour)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get a contour's smallest possible enclosing circle", "code": "def get_minimum_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get a contour's smallest possible enclosing circle", "code": "def get_minimum_enclosing_circle(c):\n    (x, y), radius = cv2.minEnclosingCircle(c)\n    center = (int(x), int(y))\n    radius = int(radius)\n    cv2.circle(img, center, radius, (0, 255, 0), 2)\n    return center, radius"}
{"nl": "Get a contour's smallest possible enclosing circle", "code": "def get_minimum_enclosing_circle(image):\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n    blurred = cv2.GaussianBlur(gray, (5, 5), 0)\n\n    thresh = cv2.threshold(blurred, 60, 255, cv2.THRESH_BINARY)[1]\n\n    contours = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    contours = contours[0] if len(contours) == 2 else contours[1]\n\n    for c in contours:\n        ((x, y), radius) = cv2.minEnclosingCircle(c)\n        cv2.circle(image, (int(x), int(y)), int(radius), (0, 255, 0), 2)\n        return x, y, radius"}
{"nl": "Get a contour's smallest possible enclosing circle", "code": "def get_min_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get the contour's smallest enclosing circle.", "code": "def get_contour_min_enclosing_circle(contour):\n   \n    (x, y), radius = cv2.minEnclosingCircle(contour)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get the contour's smallest enclosing circle.", "code": "def get_minimum_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get the contour's smallest enclosing circle.", "code": "def get_minimum_enclosing_circle(c):\n    (x, y), radius = cv2.minEnclosingCircle(c)\n    center = (int(x), int(y))\n    radius = int(radius)\n    cv2.circle(img, center, radius, (0, 255, 0), 2)\n    return center, radius"}
{"nl": "Get the contour's smallest enclosing circle.", "code": "def get_minimum_enclosing_circle(image):\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n    blurred = cv2.GaussianBlur(gray, (5, 5), 0)\n\n    thresh = cv2.threshold(blurred, 60, 255, cv2.THRESH_BINARY)[1]\n\n    contours = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    contours = contours[0] if len(contours) == 2 else contours[1]\n\n    for c in contours:\n        ((x, y), radius) = cv2.minEnclosingCircle(c)\n        cv2.circle(image, (int(x), int(y)), int(radius), (0, 255, 0), 2)\n        return x, y, radius"}
{"nl": "Get the contour's smallest enclosing circle.", "code": "def get_min_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get the smallest circumscribing circle of a contour", "code": "def get_contour_min_enclosing_circle(contour):\n   \n    (x, y), radius = cv2.minEnclosingCircle(contour)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get the smallest circumscribing circle of a contour", "code": "def get_minimum_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get the smallest circumscribing circle of a contour", "code": "def get_minimum_enclosing_circle(c):\n    (x, y), radius = cv2.minEnclosingCircle(c)\n    center = (int(x), int(y))\n    radius = int(radius)\n    cv2.circle(img, center, radius, (0, 255, 0), 2)\n    return center, radius"}
{"nl": "Get the smallest circumscribing circle of a contour", "code": "def get_minimum_enclosing_circle(image):\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n    blurred = cv2.GaussianBlur(gray, (5, 5), 0)\n\n    thresh = cv2.threshold(blurred, 60, 255, cv2.THRESH_BINARY)[1]\n\n    contours = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    contours = contours[0] if len(contours) == 2 else contours[1]\n\n    for c in contours:\n        ((x, y), radius) = cv2.minEnclosingCircle(c)\n        cv2.circle(image, (int(x), int(y)), int(radius), (0, 255, 0), 2)\n        return x, y, radius"}
{"nl": "Get the smallest circumscribing circle of a contour", "code": "def get_min_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get the smallest possible enclosing circle for a contour.", "code": "def get_contour_min_enclosing_circle(contour):\n   \n    (x, y), radius = cv2.minEnclosingCircle(contour)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get the smallest possible enclosing circle for a contour.", "code": "def get_minimum_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get the smallest possible enclosing circle for a contour.", "code": "def get_minimum_enclosing_circle(c):\n    (x, y), radius = cv2.minEnclosingCircle(c)\n    center = (int(x), int(y))\n    radius = int(radius)\n    cv2.circle(img, center, radius, (0, 255, 0), 2)\n    return center, radius"}
{"nl": "Get the smallest possible enclosing circle for a contour.", "code": "def get_minimum_enclosing_circle(image):\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n    blurred = cv2.GaussianBlur(gray, (5, 5), 0)\n\n    thresh = cv2.threshold(blurred, 60, 255, cv2.THRESH_BINARY)[1]\n\n    contours = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    contours = contours[0] if len(contours) == 2 else contours[1]\n\n    for c in contours:\n        ((x, y), radius) = cv2.minEnclosingCircle(c)\n        cv2.circle(image, (int(x), int(y)), int(radius), (0, 255, 0), 2)\n        return x, y, radius"}
{"nl": "Get the smallest possible enclosing circle for a contour.", "code": "def get_min_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Minimum contour enclosing circle", "code": "def get_contour_min_enclosing_circle(contour):\n   \n    (x, y), radius = cv2.minEnclosingCircle(contour)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Minimum contour enclosing circle", "code": "def get_minimum_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Minimum contour enclosing circle", "code": "def get_minimum_enclosing_circle(c):\n    (x, y), radius = cv2.minEnclosingCircle(c)\n    center = (int(x), int(y))\n    radius = int(radius)\n    cv2.circle(img, center, radius, (0, 255, 0), 2)\n    return center, radius"}
{"nl": "Minimum contour enclosing circle", "code": "def get_minimum_enclosing_circle(image):\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n    blurred = cv2.GaussianBlur(gray, (5, 5), 0)\n\n    thresh = cv2.threshold(blurred, 60, 255, cv2.THRESH_BINARY)[1]\n\n    contours = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    contours = contours[0] if len(contours) == 2 else contours[1]\n\n    for c in contours:\n        ((x, y), radius) = cv2.minEnclosingCircle(c)\n        cv2.circle(image, (int(x), int(y)), int(radius), (0, 255, 0), 2)\n        return x, y, radius"}
{"nl": "Minimum contour enclosing circle", "code": "def get_min_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Find the smallest circle that fits the\u00a0contour", "code": "def get_contour_min_enclosing_circle(contour):\n   \n    (x, y), radius = cv2.minEnclosingCircle(contour)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Find the smallest circle that fits the\u00a0contour", "code": "def get_minimum_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Find the smallest circle that fits the\u00a0contour", "code": "def get_minimum_enclosing_circle(c):\n    (x, y), radius = cv2.minEnclosingCircle(c)\n    center = (int(x), int(y))\n    radius = int(radius)\n    cv2.circle(img, center, radius, (0, 255, 0), 2)\n    return center, radius"}
{"nl": "Find the smallest circle that fits the\u00a0contour", "code": "def get_minimum_enclosing_circle(image):\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n    blurred = cv2.GaussianBlur(gray, (5, 5), 0)\n\n    thresh = cv2.threshold(blurred, 60, 255, cv2.THRESH_BINARY)[1]\n\n    contours = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    contours = contours[0] if len(contours) == 2 else contours[1]\n\n    for c in contours:\n        ((x, y), radius) = cv2.minEnclosingCircle(c)\n        cv2.circle(image, (int(x), int(y)), int(radius), (0, 255, 0), 2)\n        return x, y, radius"}
{"nl": "Find the smallest circle that fits the\u00a0contour", "code": "def get_min_enclosing_circle(img):\n    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(img_gray, 127, 255, 0)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    cnt = contours[0]\n\n    (x, y), radius = cv2.minEnclosingCircle(cnt)\n    center = (int(x), int(y))\n    radius = int(radius)\n    return center, radius"}
{"nl": "Get convex defects of a contour", "code": "def get_contour_convex_defects(contour):\n   \n    hull = cv2.convexHull(contour, returnPoints=False)\n    defects = cv2.convexityDefects(contour, hull)\n    return defects"}
{"nl": "Get orientation of a contour", "code": "def get_contour_orientation(contour):\n   \n    (x, y), (MA, ma), angle = cv2.fitEllipse(contour)\n    return angle"}
{"nl": "Get hull mask of a contour", "code": "def get_contour_hull_mask(img, contour):\n   \n    hull = cv2.convexHull(contour)\n    mask = np.zeros(img.shape, np.uint8)\n    cv2.drawContours(mask, [hull], 0, 255, -1)\n    return mask"}
{"nl": " Get hull defects of a contour", "code": "def get_contour_hull_defects(contour):\n   \n    hull = cv2.convexHull(contour, returnPoints=False)\n    defects = cv2.convexityDefects(contour, hull)\n    return defects"}
{"nl": "Get convex defects of a contour", "code": "\"def get_contour_convex_defects(contour):\n   \n    hull = cv2.convexHull(contour, returnPoints=False)\n    defects = cv2.convexityDefects(contour, hull)\n    return defects\""}
{"nl": "Obtain a contour's convex defects.", "code": "def show_defects(contours):\n    cnt = contours[0]\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(cnt[s][0])\n        end = tuple(cnt[e][0])\n        far = tuple(cnt[f][0])\n        cv2.line(img, start, end, [0, 255, 0], 2)\n        cv2.circle(img, far, 5, [0, 0, 255], -1)\n    return defects"}
{"nl": "Obtain the convex defects of a contour.", "code": "def show_defects(contours):\n    cnt = contours[0]\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n    return defects"}
{"nl": "Determine the convex defects in a contour.", "code": "def get_contour_defects(img):\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(gray, 127, 255, 0)\n\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    img = cv2.drawContours(img, contours, -1, (0, 255, 0), 3)\n\n    hull = [cv2.convexHull(c) for c in contours]\n\n    img = cv2.drawContours(img, hull, -1, (0, 0, 255), 3)\n\n    defects = [cv2.convexityDefects(c, h) for c, h in zip(contours, hull)]\n    return defects"}
{"nl": "Get convex defects of a contour", "code": "def get_contour_defects(img):\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(gray, 127, 255, 0)\n\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    img = cv2.drawContours(img, contours, -1, (0, 255, 0), 3)\n\n    hull = [cv2.convexHull(c) for c in contours]\n\n    img = cv2.drawContours(img, hull, -1, (0, 0, 255), 3)\n\n    defects = [cv2.convexityDefects(c, h) for c, h in zip(contours, hull)]\n    return defects"}
{"nl": "Get convex defects of a contour", "code": "def show_defects(contours):\n    cnt = contours[0]\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n    return defects"}
{"nl": "Obtain a contour's convex defects.", "code": "def show_defects(contours):\n    cnt = contours[0]\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n    return defects"}
{"nl": "Obtain a contour's convex defects.", "code": "def get_contour_defects(img):\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(gray, 127, 255, 0)\n\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    img = cv2.drawContours(img, contours, -1, (0, 255, 0), 3)\n\n    hull = [cv2.convexHull(c) for c in contours]\n\n    img = cv2.drawContours(img, hull, -1, (0, 0, 255), 3)\n\n    defects = [cv2.convexityDefects(c, h) for c, h in zip(contours, hull)]\n    return defects"}
{"nl": "Obtain a contour's convex defects.", "code": "def get_contour_defects(img):\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(gray, 127, 255, 0)\n\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    img = cv2.drawContours(img, contours, -1, (0, 255, 0), 3)\n\n    hull = [cv2.convexHull(c) for c in contours]\n\n    img = cv2.drawContours(img, hull, -1, (0, 0, 255), 3)\n\n    defects = [cv2.convexityDefects(c, h) for c, h in zip(contours, hull)]\n    return defects"}
{"nl": "Obtain the convex defects of a contour.", "code": "\"def show_defects(contours):\n    cnt = contours[0]\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(cnt[s][0])\n        end = tuple(cnt[e][0])\n        far = tuple(cnt[f][0])\n        cv2.line(img, start, end, [0, 255, 0], 2)\n        cv2.circle(img, far, 5, [0, 0, 255], -1)\n    return defects\""}
{"nl": "Obtain the convex defects of a contour.", "code": "def get_contour_defects(img):\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(gray, 127, 255, 0)\n\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    img = cv2.drawContours(img, contours, -1, (0, 255, 0), 3)\n\n    hull = [cv2.convexHull(c) for c in contours]\n\n    img = cv2.drawContours(img, hull, -1, (0, 0, 255), 3)\n\n    defects = [cv2.convexityDefects(c, h) for c, h in zip(contours, hull)]\n    return defects"}
{"nl": "Determine the convex defects in a contour.", "code": "\"def show_defects(contours):\n    cnt = contours[0]\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(cnt[s][0])\n        end = tuple(cnt[e][0])\n        far = tuple(cnt[f][0])\n        cv2.line(img, start, end, [0, 255, 0], 2)\n        cv2.circle(img, far, 5, [0, 0, 255], -1)\n    return defects\""}
{"nl": "Determine the convex defects in a contour.", "code": "def show_defects(contours):\n    cnt = contours[0]\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n    return defects"}
{"nl": "Determine the convex defects in a contour.", "code": "def show_defects(contours):\n    cnt = contours[0]\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n    return defects"}
{"nl": "get contour defects", "code": "def show_defects(contours):\n    cnt = contours[0]\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(cnt[s][0])\n        end = tuple(cnt[e][0])\n        far = tuple(cnt[f][0])\n        cv2.line(img, start, end, [0, 255, 0], 2)\n        cv2.circle(img, far, 5, [0, 0, 255], -1)\n    return defects"}
{"nl": "get contour defects", "code": "def show_defects(contours):\n    cnt = contours[0]\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n    return defects"}
{"nl": "Get convex defects in a contour.", "code": "def show_defects(contours):\n    cnt = contours[0]\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(cnt[s][0])\n        end = tuple(cnt[e][0])\n        far = tuple(cnt[f][0])\n        cv2.line(img, start, end, [0, 255, 0], 2)\n        cv2.circle(img, far, 5, [0, 0, 255], -1)\n    return defects"}
{"nl": "Get convex defects in a contour.", "code": "def get_contour_defects(img):\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(gray, 127, 255, 0)\n\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    img = cv2.drawContours(img, contours, -1, (0, 255, 0), 3)\n\n    hull = [cv2.convexHull(c) for c in contours]\n\n    img = cv2.drawContours(img, hull, -1, (0, 0, 255), 3)\n\n    defects = [cv2.convexityDefects(c, h) for c, h in zip(contours, hull)]\n    return defects"}
{"nl": "Get convex defects in a contour.", "code": "def get_contour_defects(img):\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(gray, 127, 255, 0)\n\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    img = cv2.drawContours(img, contours, -1, (0, 255, 0), 3)\n\n    hull = [cv2.convexHull(c) for c in contours]\n\n    img = cv2.drawContours(img, hull, -1, (0, 0, 255), 3)\n\n    defects = [cv2.convexityDefects(c, h) for c, h in zip(contours, hull)]\n    return defects"}
{"nl": "Get convex defects in a contour.", "code": "def get_contour_defects(img):\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    ret, thresh = cv2.threshold(gray, 127, 255, 0)\n\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    img = cv2.drawContours(img, contours, -1, (0, 255, 0), 3)\n\n    hull = [cv2.convexHull(c) for c in contours]\n\n    img = cv2.drawContours(img, hull, -1, (0, 0, 255), 3)\n\n    defects = [cv2.convexityDefects(c, h) for c, h in zip(contours, hull)]\n    return defects"}
{"nl": "Get hull defects depth of a contour", "code": "def get_contour_hull_defects_depth(contour):\n   \n    hull = cv2.convexHull(contour, returnPoints=False)\n    defects = cv2.convexityDefects(contour, hull)\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        return d"}
{"nl": "Get hull defects angle of a contour", "code": "def get_contour_hull_defects_angle(contour):\n   \n    hull = cv2.convexHull(contour, returnPoints=False)\n    defects = cv2.convexityDefects(contour, hull)\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(contour[s][0])\n        end = tuple(contour[e][0])\n        far = tuple(contour[f][0])\n        a = math.sqrt((end[0] - start[0]) ** 2 + (end[1] - start[1]) ** 2)\n        b = math.sqrt((far[0] - start[0]) ** 2 + (far[1] - start[1]) ** 2)\n        c = math.sqrt((end[0] - far[0]) ** 2 + (end[1] - far[1]) ** 2)\n        angle = math.acos((b ** 2 + c ** 2 - a ** 2) / (2 * b * c)) * 57\n        return angle"}
{"nl": "Get hull defects count of a contour", "code": "def get_contour_hull_defects_count(contour):\n   \n    hull = cv2.convexHull(contour, returnPoints=False)\n    defects = cv2.convexityDefects(contour, hull)\n    return defects.shape[0]"}
{"nl": "Get hull defects points of a contour", "code": "\"def get_contour_hull_defects_points(contour):\n   \n    hull = cv2.convexHull(contour, returnPoints=False)\n    defects = cv2.convexityDefects(contour, hull)\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(contour[s][0])\n        end = tuple(contour[e][0])\n        far = tuple(contour[f][0])\n        return start, end, far\""}
{"nl": "Identify hull defects in a contour.", "code": "def find_hull_defects(contours):\n    cnt = contours[0]\n\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n    return defects"}
{"nl": "Obtain the hull defects points of a contour", "code": "def get_hull_defects(contour, hull):\n    hull_defects = cv2.convexityDefects(contour, hull)\n    hull_defects_points = []\n    for i in range(hull_defects.shape[0]):\n        s, e, f, d = hull_defects[i, 0]\n        start = tuple(contour[s][0])\n        end = tuple(contour[e][0])\n        far = tuple(contour[f][0])\n        hull_defects_points.append([start, end, far])\n    return hull_defects_points"}
{"nl": "Obtain hull defect locations along a contour.", "code": "def get_hull_defects(contours):\n    \n    hull = [cv2.convexHull(c) for c in contours]\n\n    drawing = np.zeros((thresh.shape[0], thresh.shape[1], 3), dtype=np.uint8)\n\n    for i in range(len(contours)):\n        color_contours = (0, 255, 0) # green - color for contours\n        color = (255, 0, 0) # blue - color for convex hull\n        cv2.drawContours(drawing, contours, i, color_contours, 1, 8, hierarchy)\n        cv2.drawContours(drawing, hull, i, color, 1, 8)\n\n    cv2.imshow('Output', drawing)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()"}
{"nl": "Find out the\u00a0hull defects on a contour", "code": "def get_hull_defects(contours):\n    cnt = contours[0]\n\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(cnt[s][0])\n        end = tuple(cnt[e][0])\n        far = tuple(cnt[f][0])\n        cv2.line(img, start, end, [0, 255, 0], 2)\n        cv2.circle(img, far, 5, [0, 0, 255], -1)\n\n    cv2.imshow('img', img)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()"}
{"nl": "Find contour hull defects", "code": "\"\"\"def find_hull_defects(contours):\n    cnt = contours[0]\n\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n    return defects\"\"\""}
{"nl": "Find contour hull defects", "code": "\"\"\"def get_hull_defects(contour, hull):\n    hull_defects = cv2.convexityDefects(contour, hull)\n    hull_defects_points = []\n    for i in range(hull_defects.shape[0]):\n        s, e, f, d = hull_defects[i, 0]\n        start = tuple(contour[s][0])\n        end = tuple(contour[e][0])\n        far = tuple(contour[f][0])\n        hull_defects_points.append([start, end, far])\n    return hull_defects_points\"\"\""}
{"nl": "Find contour hull defects", "code": "\"\"\"def get_hull_defects(contours):\n    \n    hull = [cv2.convexHull(c) for c in contours]\n\n    drawing = np.zeros((thresh.shape[0], thresh.shape[1], 3), dtype=np.uint8)\n\n    for i in range(len(contours)):\n        color_contours = (0, 255, 0) # green - color for contours\n        color = (255, 0, 0) # blue - color for convex hull\n        cv2.drawContours(drawing, contours, i, color_contours, 1, 8, hierarchy)\n        cv2.drawContours(drawing, hull, i, color, 1, 8)\n\n    cv2.imshow('Output', drawing)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\"\"\""}
{"nl": "Find contour hull defects", "code": "\"\"\"def get_hull_defects(contours):\n    cnt = contours[0]\n\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(cnt[s][0])\n        end = tuple(cnt[e][0])\n        far = tuple(cnt[f][0])\n        cv2.line(img, start, end, [0, 255, 0], 2)\n        cv2.circle(img, far, 5, [0, 0, 255], -1)\n\n    cv2.imshow('img', img)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\"\"\""}
{"nl": "Find contour hull defects", "code": "\"\"\"def get_hull_defects(contour, hull):\n    hull_defects = cv2.convexityDefects(contour, hull)\n    hull_defects_points = []\n    for i in range(hull_defects.shape[0]):\n        s, e, f, d = hull_defects[i, 0]\n        start = tuple(contour[s][0])\n        end = tuple(contour[e][0])\n        far = tuple(contour[f][0])\n        hull_defects_points.append([start, end, far])\n    return hull_defects_points\"\"\""}
{"nl": "Get hull defects points of a contour", "code": "\"def find_hull_defects(contours):\n    cnt = contours[0]\n\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n    return defects\""}
{"nl": "Get hull defects points of a contour", "code": "\"def get_hull_defects(contour, hull):\n    hull_defects = cv2.convexityDefects(contour, hull)\n    hull_defects_points = []\n    for i in range(hull_defects.shape[0]):\n        s, e, f, d = hull_defects[i, 0]\n        start = tuple(contour[s][0])\n        end = tuple(contour[e][0])\n        far = tuple(contour[f][0])\n        hull_defects_points.append([start, end, far])\n    return hull_defects_points\""}
{"nl": "Get hull defects points of a contour", "code": "\"def get_hull_defects(contours):\n    \n    hull = [cv2.convexHull(c) for c in contours]\n\n    drawing = np.zeros((thresh.shape[0], thresh.shape[1], 3), dtype=np.uint8)\n\n    for i in range(len(contours)):\n        color_contours = (0, 255, 0) # green - color for contours\n        color = (255, 0, 0) # blue - color for convex hull\n        cv2.drawContours(drawing, contours, i, color_contours, 1, 8, hierarchy)\n        cv2.drawContours(drawing, hull, i, color, 1, 8)\n\n    cv2.imshow('Output', drawing)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\""}
{"nl": "Get hull defects points of a contour", "code": "\"def get_hull_defects(contours):\n    cnt = contours[0]\n\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(cnt[s][0])\n        end = tuple(cnt[e][0])\n        far = tuple(cnt[f][0])\n        cv2.line(img, start, end, [0, 255, 0], 2)\n        cv2.circle(img, far, 5, [0, 0, 255], -1)\n\n    cv2.imshow('img', img)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\""}
{"nl": "Identify hull defects in a contour.", "code": "\"\"\"def get_contour_hull_defects_points(contour):\n   \n    hull = cv2.convexHull(contour, returnPoints=False)\n    defects = cv2.convexityDefects(contour, hull)\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(contour[s][0])\n        end = tuple(contour[e][0])\n        far = tuple(contour[f][0])\n        return start, end, far\"\"\""}
{"nl": "Identify hull defects in a contour.", "code": "\"def get_hull_defects(contour, hull):\n    hull_defects = cv2.convexityDefects(contour, hull)\n    hull_defects_points = []\n    for i in range(hull_defects.shape[0]):\n        s, e, f, d = hull_defects[i, 0]\n        start = tuple(contour[s][0])\n        end = tuple(contour[e][0])\n        far = tuple(contour[f][0])\n        hull_defects_points.append([start, end, far])\n    return hull_defects_points\""}
{"nl": "Identify hull defects in a contour.", "code": "\"def get_hull_defects(contours):\n    \n    hull = [cv2.convexHull(c) for c in contours]\n\n    drawing = np.zeros((thresh.shape[0], thresh.shape[1], 3), dtype=np.uint8)\n\n    for i in range(len(contours)):\n        color_contours = (0, 255, 0) # green - color for contours\n        color = (255, 0, 0) # blue - color for convex hull\n        cv2.drawContours(drawing, contours, i, color_contours, 1, 8, hierarchy)\n        cv2.drawContours(drawing, hull, i, color, 1, 8)\n\n    cv2.imshow('Output', drawing)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\""}
{"nl": "Identify hull defects in a contour.", "code": "\"def get_hull_defects(contours):\n    cnt = contours[0]\n\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(cnt[s][0])\n        end = tuple(cnt[e][0])\n        far = tuple(cnt[f][0])\n        cv2.line(img, start, end, [0, 255, 0], 2)\n        cv2.circle(img, far, 5, [0, 0, 255], -1)\n\n    cv2.imshow('img', img)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\""}
{"nl": "Obtain the hull defects points of a contour", "code": "\"\"\"def get_contour_hull_defects_points(contour):\n   \n    hull = cv2.convexHull(contour, returnPoints=False)\n    defects = cv2.convexityDefects(contour, hull)\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(contour[s][0])\n        end = tuple(contour[e][0])\n        far = tuple(contour[f][0])\n        return start, end, far\"\"\""}
{"nl": "Obtain the hull defects points of a contour", "code": "\"def find_hull_defects(contours):\n    cnt = contours[0]\n\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n    return defects\""}
{"nl": "Obtain the hull defects points of a contour", "code": "\"def get_hull_defects(contours):\n    \n    hull = [cv2.convexHull(c) for c in contours]\n\n    drawing = np.zeros((thresh.shape[0], thresh.shape[1], 3), dtype=np.uint8)\n\n    for i in range(len(contours)):\n        color_contours = (0, 255, 0) # green - color for contours\n        color = (255, 0, 0) # blue - color for convex hull\n        cv2.drawContours(drawing, contours, i, color_contours, 1, 8, hierarchy)\n        cv2.drawContours(drawing, hull, i, color, 1, 8)\n\n    cv2.imshow('Output', drawing)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\""}
{"nl": "Obtain the hull defects points of a contour", "code": "\"def get_hull_defects(contours):\n    cnt = contours[0]\n\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(cnt[s][0])\n        end = tuple(cnt[e][0])\n        far = tuple(cnt[f][0])\n        cv2.line(img, start, end, [0, 255, 0], 2)\n        cv2.circle(img, far, 5, [0, 0, 255], -1)\n\n    cv2.imshow('img', img)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\""}
{"nl": "Obtain hull defect locations along a contour.", "code": "def get_contour_hull_defects_points(contour):\n\n    hull = cv2.convexHull(contour, returnPoints=False)\n    defects = cv2.convexityDefects(contour, hull)\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(contour[s][0])\n        end = tuple(contour[e][0])\n        far = tuple(contour[f][0])\n        return start, end, far"}
{"nl": "Obtain hull defect locations along a contour.", "code": "\"def find_hull_defects(contours):\n    cnt = contours[0]\n\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n    return defects\""}
{"nl": "Obtain hull defect locations along a contour.", "code": "\"def get_hull_defects(contour, hull):\n    hull_defects = cv2.convexityDefects(contour, hull)\n    hull_defects_points = []\n    for i in range(hull_defects.shape[0]):\n        s, e, f, d = hull_defects[i, 0]\n        start = tuple(contour[s][0])\n        end = tuple(contour[e][0])\n        far = tuple(contour[f][0])\n        hull_defects_points.append([start, end, far])\n    return hull_defects_points\""}
{"nl": "Obtain hull defect locations along a contour.", "code": "\"def get_hull_defects(contours):\n    cnt = contours[0]\n\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(cnt[s][0])\n        end = tuple(cnt[e][0])\n        far = tuple(cnt[f][0])\n        cv2.line(img, start, end, [0, 255, 0], 2)\n        cv2.circle(img, far, 5, [0, 0, 255], -1)\n\n    cv2.imshow('img', img)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\""}
{"nl": "Find out the\u00a0hull defects on a contour", "code": "def get_contour_hull_defects_points(contour):\n\n    hull = cv2.convexHull(contour, returnPoints=False)\n    defects = cv2.convexityDefects(contour, hull)\n    for i in range(defects.shape[0]):\n        s, e, f, d = defects[i, 0]\n        start = tuple(contour[s][0])\n        end = tuple(contour[e][0])\n        far = tuple(contour[f][0])\n        return start, end, far\"\"\""}
{"nl": "Find out the\u00a0hull defects on a contour", "code": "def find_hull_defects(contours):\n    cnt = contours[0]\n\n    hull = cv2.convexHull(cnt, returnPoints=False)\n    defects = cv2.convexityDefects(cnt, hull)\n    return defects"}
{"nl": "Find out the\u00a0hull defects on a contour", "code": "def get_hull_defects(contour, hull):\n    hull_defects = cv2.convexityDefects(contour, hull)\n    hull_defects_points = []\n    for i in range(hull_defects.shape[0]):\n        s, e, f, d = hull_defects[i, 0]\n        start = tuple(contour[s][0])\n        end = tuple(contour[e][0])\n        far = tuple(contour[f][0])\n        hull_defects_points.append([start, end, far])\n    return hull_defects_points"}
{"nl": "Find out the\u00a0hull defects on a contour", "code": "def get_hull_defects(contours):\n    \n    hull = [cv2.convexHull(c) for c in contours]\n\n    drawing = np.zeros((thresh.shape[0], thresh.shape[1], 3), dtype=np.uint8)\n\n    for i in range(len(contours)):\n        color_contours = (0, 255, 0) # green - color for contours\n        color = (255, 0, 0) # blue - color for convex hull\n        cv2.drawContours(drawing, contours, i, color_contours, 1, 8, hierarchy)\n        cv2.drawContours(drawing, hull, i, color, 1, 8)\n\n    cv2.imshow('Output', drawing)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()"}
{"nl": "Shift the channels randomly", "code": "def random_channel_shift(image, intensity, channel_axis=2, u=0.5):\n    if np.random.random() < u:\n        image = np.rollaxis(image, channel_axis, 0)\n        min_x, max_x = np.min(image), np.max(image)\n        channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n                          for x_channel in image]\n        image = np.stack(channel_images, axis=0)\n        image = np.rollaxis(image, 0, channel_axis + 1)\n    return image"}
{"nl": "Change the saturation of image randomly", "code": "def random_saturation(self, image, lower=0.5, upper=1.5):\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n        image[:, :, 1] *= random.uniform(lower, upper)\n        image = cv2.cvtColor(image, cv2.COLOR_HSV2BGR)\n        return image"}
{"nl": "Add random noise to an image", "code": "def add_noise(img, noise_type, sigma):\n    if noise_type == \"gauss\":\n        row, col, ch = img.shape\n        mean = 0\n        gauss = np.random.normal(mean, sigma, (row, col, ch))\n        gauss = gauss.reshape(row, col, ch)\n        noisy = img + gauss\n        return noisy\n    elif noise_type == \"s&p\":\n        row, col, ch = img.shape\n        s_vs_p = 0.5\n        amount = 0.004\n        out = np.copy(img)\n        num_salt = np.ceil(amount * img.size * s_vs_p)\n        coords = [np.random.randint(0, i - 1, int(num_salt))\n                  for i in img.shape]\n        out[coords] = 1\n\n        num_pepper = np.ceil(amount * img.size * (1. - s_vs_p))\n        coords = [np.random.randint(0, i - 1, int(num_pepper))\n                  for i in img.shape]\n        out[coords] = 0\n        return out\n    elif noise_type == \"poisson\":\n        vals = len(np.unique(img))\n        vals = 2 ** np.ceil(np.log2(vals))\n        noisy = np.random.poisson(img * vals) / float(vals)\n        return noisy\n    elif noise_type == \"speckle\":\n        row, col, ch = img.shape\n        gauss = np.random.randn(row, col, ch)\n        gauss = gauss.reshape(row, col, ch)\n        noisy = img + img * gauss\n        return noisy"}
{"nl": "Image horizontal flipping at random", "code": "def random_flip_horizontal(image):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 1)\n    return image"}
{"nl": "Randomly flip an image horizontally", "code": "def horizontal_flip(image, mask):\n    if np.random.random() < 0.5:\n        image = image[:, ::-1]\n        mask = mask[:, ::-1]\n    return image, mask"}
{"nl": "Randomly flip an image horizontally", "code": "def random_flip_image(image, mask):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 1)\n        mask = cv2.flip(mask, 1)\n    return image, mask"}
{"nl": "Image horizontal flipping at random", "code": "def random_flip_horizontal(image):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 1)\n    return image"}
{"nl": "Image horizontal flipping at random", "code": "def random_flip_horizontal(image):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 1)\n    return image"}
{"nl": "Randomly flip an image in the horizontal direction.", "code": "def random_flip_horizontal(image):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 1)\n    return image"}
{"nl": "Randomly flip an image horizontally", "code": "def flip_image(image, label):\n    if random.random() < 0.5:\n        image = cv2.flip(image, 1)\n        label = cv2.flip(label, 1)\n    return image, label\n"}
{"nl": "Randomly flip an image horizontally", "code": "def random_flip_horizontal(image):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 1)\n    return image"}
{"nl": "Image horizontal flipping at random", "code": "def horizontal_flip(image, mask):\n    if np.random.random() < 0.5:\n        image = image[:, ::-1]\n        mask = mask[:, ::-1]\n    return image, mask"}
{"nl": "Image horizontal flipping at random", "code": "def random_flip_image(image, mask):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 1)\n        mask = cv2.flip(mask, 1)\n    return image, mask"}
{"nl": "Image horizontal flipping at random", "code": "def random_flip_horizontal(image):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 1)\n    return image"}
{"nl": "Randomly flip an image in the horizontal direction.", "code": "def horizontal_flip(image, mask):\n    if np.random.random() < 0.5:\n        image = image[:, ::-1]\n        mask = mask[:, ::-1]\n    return image, mask"}
{"nl": "Randomly flip an image in the horizontal direction.", "code": "def random_flip_image(image, mask):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 1)\n        mask = cv2.flip(mask, 1)\n    return image, mask"}
{"nl": "Randomly flip an image in the horizontal direction.", "code": "def flip_image(image, label):\n    if random.random() < 0.5:\n        image = cv2.flip(image, 1)\n        label = cv2.flip(label, 1)\n    return image, label\n"}
{"nl": "Horizontally flip an image randomly", "code": "def horizontal_flip(image, mask):\n    if np.random.random() < 0.5:\n        image = image[:, ::-1]\n        mask = mask[:, ::-1]\n    return image, mask"}
{"nl": "Horizontally flip an image randomly", "code": "def random_flip_image(image, mask):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 1)\n        mask = cv2.flip(mask, 1)\n    return image, mask"}
{"nl": "Horizontally flip an image randomly", "code": "def flip_image(image, label):\n    if random.random() < 0.5:\n        image = cv2.flip(image, 1)\n        label = cv2.flip(label, 1)\n    return image, label\n"}
{"nl": "Horizontally flip an image randomly", "code": "def random_flip_horizontal(image):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 1)\n    return image"}
{"nl": "Flip an image horizontally at random", "code": "def horizontal_flip(image, mask):\n    if np.random.random() < 0.5:\n        image = image[:, ::-1]\n        mask = mask[:, ::-1]\n    return image, mask"}
{"nl": "Flip an image horizontally at random", "code": "def random_flip_image(image, mask):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 1)\n        mask = cv2.flip(mask, 1)\n    return image, mask"}
{"nl": "Flip an image horizontally at random", "code": "def flip_image(image, label):\n    if random.random() < 0.5:\n        image = cv2.flip(image, 1)\n        label = cv2.flip(label, 1)\n    return image, label\n"}
{"nl": "Flip an image horizontally at random", "code": "def random_flip_horizontal(image):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 1)\n    return image"}
{"nl": "Randomly flip an image vertically", "code": "def vertical_flip(image, mask):\n    if np.random.random() < 0.5:\n        image = image[::-1, :]\n        mask = mask[::-1, :]\n    return image, mask"}
{"nl": "Randomly flip an image vertically", "code": "def random_flip_vertical(image, mask):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 0)\n        mask = cv2.flip(mask, 0)\n    return image, mask"}
{"nl": "Vertically flip an image at random", "code": "def vertical_flip(image, mask):\n    if np.random.random() < 0.5:\n        image = image[::-1, :]\n        mask = mask[::-1, :]\n    return image, mask"}
{"nl": "Flip an image vertically at random.", "code": "def vertical_flip(image, mask):\n    if np.random.random() < 0.5:\n        image = image[::-1, :]\n        mask = mask[::-1, :]\n    return image, mask"}
{"nl": "Vertically flip an image randomly", "code": "def vertical_flip(image, mask):\n    if np.random.random() < 0.5:\n        image = image[::-1, :]\n        mask = mask[::-1, :]\n    return image, mask"}
{"nl": "Randomly flip an image in the vertical direction", "code": "def random_flip_vertical(image):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 0)\n    return image"}
{"nl": "Image vertial flipping at random", "code": "def random_flip_vertical(image):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 0)\n    return image"}
{"nl": "Vertically flip an image at random", "code": "def vertical_flip(image, mask):\n    if np.random.random() < 0.5:\n        image = image[::-1, :]\n        mask = mask[::-1, :]\n    return image, mask"}
{"nl": "Flip an image vertically at random.", "code": "def vertical_flip(image, mask):\n    if np.random.random() < 0.5:\n        image = image[::-1, :]\n        mask = mask[::-1, :]\n    return image, mask"}
{"nl": "Vertically flip an image randomly", "code": "def random_flip_vertical(image, mask):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 0)\n        mask = cv2.flip(mask, 0)\n    return image, mask"}
{"nl": "Randomly flip an image in the vertical direction", "code": "def vertical_flip(image, mask):\n    if np.random.random() < 0.5:\n        image = image[::-1, :]\n        mask = mask[::-1, :]\n    return image, mask"}
{"nl": "Randomly flip an image in the vertical direction", "code": "def random_flip_vertical(image, mask):\n    if np.random.rand() < 0.5:\n        image = cv2.flip(image, 0)\n        mask = cv2.flip(mask, 0)\n    return image, mask"}
{"nl": "Randomly crop image", "code": "def random_crop(image, mask, crop_shape):\n    if image.shape[0] > crop_shape[0] and image.shape[1] > crop_shape[1]:\n        x = np.random.randint(0, image.shape[1] - crop_shape[1])\n        y = np.random.randint(0, image.shape[0] - crop_shape[0])\n        image = image[y: y + crop_shape[0], x: x + crop_shape[1]]\n        mask = mask[y: y + crop_shape[0], x: x + crop_shape[1]]\n    return image, mask"}
{"nl": "Randomly crop image", "code": "def random_crop(image, crop_size):\n    h, w = image.shape[:2]\n    top = np.random.randint(0, h - crop_size[0])\n    left = np.random.randint(0, w - crop_size[1])\n    bottom = top + crop_size[0]\n    right = left + crop_size[1]\n    return image[top:bottom, left:right, :]"}
{"nl": "random image crop", "code": "def random_crop(img, crop_size):\n    h, w, c = img.shape\n    x = random.randint(0, w - crop_size)\n    y = random.randint(0, h - crop_size)\n    return img[y:y+crop_size, x:x+crop_size, :]"}
{"nl": "Crop an image at random", "code": "def random_crop(img, random_crop_size):\n    assert img.shape[2] == 3\n    height, width = img.shape[0], img.shape[1]\n    dy, dx = random_crop_size\n    x = np.random.randint(0, width - dx + 1)\n    y = np.random.randint(0, height - dy + 1)\n    return img[y:(y+dy), x:(x+dx), :]\n"}
{"nl": "Image cropped at random", "code": "def crop_image(img, crop_size):\n    h, w, _ = img.shape\n    x = random.randint(0, w - crop_size)\n    y = random.randint(0, h - crop_size)\n    return img[y:y+crop_size, x:x+crop_size, :]"}
{"nl": "Crop the image randomly with given crop size", "code": "\"def random_crop(image, mask, crop_shape):\n    if image.shape[0] > crop_shape[0] and image.shape[1] > crop_shape[1]:\n        x = np.random.randint(0, image.shape[1] - crop_shape[1])\n        y = np.random.randint(0, image.shape[0] - crop_shape[0])\n        image = image[y: y + crop_shape[0], x: x + crop_shape[1]]\n        mask = mask[y: y + crop_shape[0], x: x + crop_shape[1]]\n    return image, mask\""}
{"nl": "Image cropped in a random way", "code": "def random_crop(image, mask, crop_shape):\n    if image.shape[0] > crop_shape[0] and image.shape[1] > crop_shape[1]:\n        x = np.random.randint(0, image.shape[1] - crop_shape[1])\n        y = np.random.randint(0, image.shape[0] - crop_shape[0])\n        image = image[y: y + crop_shape[0], x: x + crop_shape[1]]\n        mask = mask[y: y + crop_shape[0], x: x + crop_shape[1]]\n    return image, mask"}
{"nl": "Crop image randomly", "code": "def crop_image(img, crop_size):\n    h, w, _ = img.shape\n    top = np.random.randint(0, h - crop_size[0])\n    left = np.random.randint(0, w - crop_size[1])\n    bottom = top + crop_size[0]\n    right = left + crop_size[1]\n    return img[top:bottom, left:right, :]"}
{"nl": "Randomly crop image", "code": "def random_crop(img, crop_size):\n    h, w, c = img.shape\n    x = random.randint(0, w - crop_size)\n    y = random.randint(0, h - crop_size)\n    return img[y:y+crop_size, x:x+crop_size, :]"}
{"nl": "Randomly crop image", "code": "def random_crop(img, random_crop_size):\n    assert img.shape[2] == 3\n    height, width = img.shape[0], img.shape[1]\n    dy, dx = random_crop_size\n    x = np.random.randint(0, width - dx + 1)\n    y = np.random.randint(0, height - dy + 1)\n    return img[y:(y+dy), x:(x+dx), :]\n"}
{"nl": "Randomly crop image", "code": "def random_crop(img, random_crop_size):\n    assert img.shape[2] == 3\n    height, width = img.shape[0], img.shape[1]\n    dy, dx = random_crop_size\n    x = np.random.randint(0, width - dx + 1)\n    y = np.random.randint(0, height - dy + 1)\n    return img[y:(y+dy), x:(x+dx), :]\n"}
{"nl": "Randomly crop image", "code": "def crop_image(img, crop_size):\n    h, w, _ = img.shape\n    x = random.randint(0, w - crop_size)\n    y = random.randint(0, h - crop_size)\n    return img[y:y+crop_size, x:x+crop_size, :]"}
{"nl": "random image crop", "code": "def random_crop(image, mask, crop_shape):\n    if image.shape[0] > crop_shape[0] and image.shape[1] > crop_shape[1]:\n        x = np.random.randint(0, image.shape[1] - crop_shape[1])\n        y = np.random.randint(0, image.shape[0] - crop_shape[0])\n        image = image[y: y + crop_shape[0], x: x + crop_shape[1]]\n        mask = mask[y: y + crop_shape[0], x: x + crop_shape[1]]\n    return image, mask"}
{"nl": "random image crop", "code": "def random_crop(image, crop_size):\n    h, w = image.shape[:2]\n    top = np.random.randint(0, h - crop_size[0])\n    left = np.random.randint(0, w - crop_size[1])\n    bottom = top + crop_size[0]\n    right = left + crop_size[1]\n    return image[top:bottom, left:right, :]"}
{"nl": "random image crop", "code": "def random_crop(img, random_crop_size):\n    assert img.shape[2] == 3\n    height, width = img.shape[0], img.shape[1]\n    dy, dx = random_crop_size\n    x = np.random.randint(0, width - dx + 1)\n    y = np.random.randint(0, height - dy + 1)\n    return img[y:(y+dy), x:(x+dx), :]\n"}
{"nl": "random image crop", "code": "def random_crop(img, random_crop_size):\n    assert img.shape[2] == 3\n    height, width = img.shape[0], img.shape[1]\n    dy, dx = random_crop_size\n    x = np.random.randint(0, width - dx + 1)\n    y = np.random.randint(0, height - dy + 1)\n    return img[y:(y+dy), x:(x+dx), :]\n"}
{"nl": "random image crop", "code": "def crop_image(img, crop_size):\n    h, w, _ = img.shape\n    x = random.randint(0, w - crop_size)\n    y = random.randint(0, h - crop_size)\n    return img[y:y+crop_size, x:x+crop_size, :]"}
{"nl": "Crop an image at random", "code": "def random_crop(image, mask, crop_shape):\n    if image.shape[0] > crop_shape[0] and image.shape[1] > crop_shape[1]:\n        x = np.random.randint(0, image.shape[1] - crop_shape[1])\n        y = np.random.randint(0, image.shape[0] - crop_shape[0])\n        image = image[y: y + crop_shape[0], x: x + crop_shape[1]]\n        mask = mask[y: y + crop_shape[0], x: x + crop_shape[1]]\n    return image, mask"}
{"nl": "Crop an image at random", "code": "def random_crop(image, crop_size):\n    h, w = image.shape[:2]\n    top = np.random.randint(0, h - crop_size[0])\n    left = np.random.randint(0, w - crop_size[1])\n    bottom = top + crop_size[0]\n    right = left + crop_size[1]\n    return image[top:bottom, left:right, :]"}
{"nl": "Crop an image at random", "code": "def random_crop(img, crop_size):\n    h, w, c = img.shape\n    x = random.randint(0, w - crop_size)\n    y = random.randint(0, h - crop_size)\n    return img[y:y+crop_size, x:x+crop_size, :]"}
{"nl": "Crop an image at random", "code": "def crop_image(img, crop_size):\n    h, w, _ = img.shape\n    x = random.randint(0, w - crop_size)\n    y = random.randint(0, h - crop_size)\n    return img[y:y+crop_size, x:x+crop_size, :]"}
{"nl": "Crop an image at random", "code": "def crop_image(img, crop_size):\n    h, w, _ = img.shape\n    top = np.random.randint(0, h - crop_size[0])\n    left = np.random.randint(0, w - crop_size[1])\n    bottom = top + crop_size[0]\n    right = left + crop_size[1]\n    return img[top:bottom, left:right, :]"}
{"nl": "Image cropped at random", "code": "def random_crop(image, mask, crop_shape):\n    if image.shape[0] > crop_shape[0] and image.shape[1] > crop_shape[1]:\n        x = np.random.randint(0, image.shape[1] - crop_shape[1])\n        y = np.random.randint(0, image.shape[0] - crop_shape[0])\n        image = image[y: y + crop_shape[0], x: x + crop_shape[1]]\n        mask = mask[y: y + crop_shape[0], x: x + crop_shape[1]]\n    return image, mask"}
{"nl": "Image cropped at random", "code": "def random_crop(img, crop_size):\n    h, w, c = img.shape\n    x = random.randint(0, w - crop_size)\n    y = random.randint(0, h - crop_size)\n    return img[y:y+crop_size, x:x+crop_size, :]"}
{"nl": "Image cropped at random", "code": "def random_crop(img, random_crop_size):\n    assert img.shape[2] == 3\n    height, width = img.shape[0], img.shape[1]\n    dy, dx = random_crop_size\n    x = np.random.randint(0, width - dx + 1)\n    y = np.random.randint(0, height - dy + 1)\n    return img[y:(y+dy), x:(x+dx), :]\n"}
{"nl": "Image cropped at random", "code": "def random_crop(img, random_crop_size):\n    assert img.shape[2] == 3\n    height, width = img.shape[0], img.shape[1]\n    dy, dx = random_crop_size\n    x = np.random.randint(0, width - dx + 1)\n    y = np.random.randint(0, height - dy + 1)\n    return img[y:(y+dy), x:(x+dx), :]\n"}
{"nl": "Image cropped at random", "code": "def crop_image(img, crop_size):\n    h, w, _ = img.shape\n    top = np.random.randint(0, h - crop_size[0])\n    left = np.random.randint(0, w - crop_size[1])\n    bottom = top + crop_size[0]\n    right = left + crop_size[1]\n    return img[top:bottom, left:right, :]"}
{"nl": "Crop the image randomly with given crop size", "code": "def random_crop(image, crop_size):\n    h, w = image.shape[:2]\n    top = np.random.randint(0, h - crop_size[0])\n    left = np.random.randint(0, w - crop_size[1])\n    bottom = top + crop_size[0]\n    right = left + crop_size[1]\n    return image[top:bottom, left:right, :]"}
{"nl": "Crop the image randomly with given crop size", "code": "def random_crop(img, crop_size):\n    h, w, c = img.shape\n    x = random.randint(0, w - crop_size)\n    y = random.randint(0, h - crop_size)\n    return img[y:y+crop_size, x:x+crop_size, :]"}
{"nl": "Crop the image randomly with given crop size", "code": "def random_crop(img, random_crop_size):\n    assert img.shape[2] == 3\n    height, width = img.shape[0], img.shape[1]\n    dy, dx = random_crop_size\n    x = np.random.randint(0, width - dx + 1)\n    y = np.random.randint(0, height - dy + 1)\n    return img[y:(y+dy), x:(x+dx), :]\n"}
{"nl": "Crop the image randomly with given crop size", "code": "def crop_image(img, crop_size):\n    h, w, _ = img.shape\n    x = random.randint(0, w - crop_size)\n    y = random.randint(0, h - crop_size)\n    return img[y:y+crop_size, x:x+crop_size, :]"}
{"nl": "Crop the image randomly with given crop size", "code": "def crop_image(img, crop_size):\n    h, w, _ = img.shape\n    top = np.random.randint(0, h - crop_size[0])\n    left = np.random.randint(0, w - crop_size[1])\n    bottom = top + crop_size[0]\n    right = left + crop_size[1]\n    return img[top:bottom, left:right, :]"}
{"nl": "Image cropped in a random way", "code": "def random_crop(image, crop_size):\n    h, w = image.shape[:2]\n    top = np.random.randint(0, h - crop_size[0])\n    left = np.random.randint(0, w - crop_size[1])\n    bottom = top + crop_size[0]\n    right = left + crop_size[1]\n    return image[top:bottom, left:right, :]"}
{"nl": "Image cropped in a random way", "code": "def random_crop(img, crop_size):\n    h, w, c = img.shape\n    x = random.randint(0, w - crop_size)\n    y = random.randint(0, h - crop_size)\n    return img[y:y+crop_size, x:x+crop_size, :]"}
{"nl": "Image cropped in a random way", "code": "def random_crop(img, random_crop_size):\n    assert img.shape[2] == 3\n    height, width = img.shape[0], img.shape[1]\n    dy, dx = random_crop_size\n    x = np.random.randint(0, width - dx + 1)\n    y = np.random.randint(0, height - dy + 1)\n    return img[y:(y+dy), x:(x+dx), :]"}
{"nl": "Image cropped in a random way", "code": "def crop_image(img, crop_size):\n    h, w, _ = img.shape\n    x = random.randint(0, w - crop_size)\n    y = random.randint(0, h - crop_size)\n    return img[y:y+crop_size, x:x+crop_size, :]"}
{"nl": "Image cropped in a random way", "code": "def crop_image(img, crop_size):\n    h, w, _ = img.shape\n    top = np.random.randint(0, h - crop_size[0])\n    left = np.random.randint(0, w - crop_size[1])\n    bottom = top + crop_size[0]\n    right = left + crop_size[1]\n    return img[top:bottom, left:right, :]"}
{"nl": "Crop image randomly", "code": "def random_crop(image, crop_size):\n    h, w = image.shape[:2]\n    top = np.random.randint(0, h - crop_size[0])\n    left = np.random.randint(0, w - crop_size[1])\n    bottom = top + crop_size[0]\n    right = left + crop_size[1]\n    return image[top:bottom, left:right, :]"}
{"nl": "Crop image randomly", "code": "def random_crop(img, crop_size):\n    h, w, c = img.shape\n    x = random.randint(0, w - crop_size)\n    y = random.randint(0, h - crop_size)\n    return img[y:y+crop_size, x:x+crop_size, :]"}
{"nl": "Crop image randomly", "code": "def random_crop(img, random_crop_size):\n    assert img.shape[2] == 3\n    height, width = img.shape[0], img.shape[1]\n    dy, dx = random_crop_size\n    x = np.random.randint(0, width - dx + 1)\n    y = np.random.randint(0, height - dy + 1)\n    return img[y:(y+dy), x:(x+dx), :]"}
{"nl": "Crop image randomly", "code": "def crop_image(img, crop_size):\n    h, w, _ = img.shape\n    x = random.randint(0, w - crop_size)\n    y = random.randint(0, h - crop_size)\n    return img[y:y+crop_size, x:x+crop_size, :]"}
{"nl": "Crop image randomly", "code": "def random_crop(img, random_crop_size):\n    assert img.shape[2] == 3\n    height, width = img.shape[0], img.shape[1]\n    dy, dx = random_crop_size\n    x = np.random.randint(0, width - dx + 1)\n    y = np.random.randint(0, height - dy + 1)\n    return img[y:(y+dy), x:(x+dx), :]\n"}
{"nl": "Randomly shear an image", "code": "def random_shear(image, mask, intensity):\n    shear = np.random.uniform(-intensity, intensity)\n    shear_matrix = np.array([[1, -np.sin(shear), 0], [0, np.cos(shear), 0], [0, 0, 1]])\n    h, w = image.shape[0], image.shape[1]\n    transform_matrix = transform.AffineTransform(shear_matrix)\n    image = transform.warp(image, transform_matrix, mode='edge')\n    mask = transform.warp(mask, transform_matrix, mode='edge')\n    return image, mask"}
{"nl": "random image shearing", "code": "def random_shear(img, shear_range):\n    rows, cols, ch = img.shape\n    dx = np.random.randint(-shear_range, shear_range + 1)\n    random_point = [cols / 2 + dx, rows / 2]\n    pts1 = np.float32([[0, rows], [cols, rows], [cols / 2, rows / 2]])\n    pts2 = np.float32([[0, rows], [cols, rows], random_point])\n    dsteering = dx / (rows / 2) * 360 / (2 * np.pi * 25.0) / 6.0\n    M = cv2.getAffineTransform(pts1, pts2)\n    img = cv2.warpAffine(img, M, (cols, rows), borderMode=1)\n    return img, dsteering"}
{"nl": "Shear an image randomly", "code": "def random_shear(image, mask, intensity):\n    shear = np.random.uniform(-intensity, intensity)\n    shear_matrix = np.array([[1, -np.sin(shear), 0], [0, np.cos(shear), 0], [0, 0, 1]])\n    h, w = image.shape[0], image.shape[1]\n    transform_matrix = transform.AffineTransform(shear_matrix)\n    image = transform.warp(image, transform_matrix, mode='edge')\n    mask = transform.warp(mask, transform_matrix, mode='edge')\n    return image, mask"}
{"nl": "Image shear randomly", "code": "def random_shear(img, shear_range):\n    rows, cols, ch = img.shape\n    dx = np.random.randint(-shear_range, shear_range + 1)\n    random_point = [cols / 2 + dx, rows / 2]\n    pts1 = np.float32([[0, rows], [cols, rows], [cols / 2, rows / 2]])\n    pts2 = np.float32([[0, rows], [cols, rows], random_point])\n    dsteering = dx / (rows / 2) * 360 / (2 * np.pi * 25.0) / 6.0\n    M = cv2.getAffineTransform(pts1, pts2)\n    img = cv2.warpAffine(img, M, (cols, rows), borderMode=1)\n    return img, dsteering"}
{"nl": "Randomly shear an image", "code": "def random_shear(img, shear_range):\n    rows, cols, ch = img.shape\n    dx = np.random.randint(-shear_range, shear_range + 1)\n    random_point = [cols / 2 + dx, rows / 2]\n    pts1 = np.float32([[0, rows], [cols, rows], [cols / 2, rows / 2]])\n    pts2 = np.float32([[0, rows], [cols, rows], random_point])\n    dsteering = dx / (rows / 2) * 360 / (2 * np.pi * 25.0) / 6.0\n    M = cv2.getAffineTransform(pts1, pts2)\n    img = cv2.warpAffine(img, M, (cols, rows), borderMode=1)\n    return img, dsteering"}
{"nl": "random image shearing", "code": "def random_shear(img, shear_range):\n    rows, cols, ch = img.shape\n    dx = np.random.randint(-shear_range, shear_range + 1)\n    random_point = [cols / 2 + dx, rows / 2]\n    pts1 = np.float32([[0, rows], [cols, rows], [cols / 2, rows / 2]])\n    pts2 = np.float32([[0, rows], [cols, rows], random_point])\n    dsteering = dx / (rows / 2) * 360 / (2 * np.pi * 25.0) / 6.0\n    M = cv2.getAffineTransform(pts1, pts2)\n    img = cv2.warpAffine(img, M, (cols, rows), borderMode=1)\n    return img, dsteering"}
{"nl": "Shear an image randomly", "code": "def random_shear(image, mask, intensity):\n    shear = np.random.uniform(-intensity, intensity)\n    shear_matrix = np.array([[1, -np.sin(shear), 0], [0, np.cos(shear), 0], [0, 0, 1]])\n    h, w = image.shape[0], image.shape[1]\n    transform_matrix = transform.AffineTransform(shear_matrix)\n    image = transform.warp(image, transform_matrix, mode='edge')\n    mask = transform.warp(mask, transform_matrix, mode='edge')\n    return image, mask"}
{"nl": "Image shear randomly", "code": "def random_shear(image, mask, intensity):\n    shear = np.random.uniform(-intensity, intensity)\n    shear_matrix = np.array([[1, -np.sin(shear), 0], [0, np.cos(shear), 0], [0, 0, 1]])\n    h, w = image.shape[0], image.shape[1]\n    transform_matrix = transform.AffineTransform(shear_matrix)\n    image = transform.warp(image, transform_matrix, mode='edge')\n    mask = transform.warp(mask, transform_matrix, mode='edge')\n    return image, mask"}
{"nl": "Randomly zoom an image", "code": "def random_zoom(image, mask, zoom_range=(0.9, 1.1), row_axis=0, col_axis=1, channel_axis=2,\n                fill_mode='nearest', cval=0., u=0.5):\n    if np.random.random() < u:\n        zx, zy = np.random.uniform(zoom_range[0], zoom_range[1], 2)\n        zoom_matrix = np.array([[zx, 0, 0],\n                                [0, zy, 0],\n                                [0, 0, 1]])\n\n        h, w = image.shape[row_axis], image.shape[col_axis]\n        transform_matrix = transform_matrix_offset_center(zoom_matrix, h, w)\n        image = apply_transform(image, transform_matrix, channel_axis, fill_mode, cval)\n        mask = apply_transform(mask, transform_matrix, channel_axis, fill_mode, cval)\n\n    return image, mask"}
{"nl": "Randomly zoom an image", "code": "def random_zoom(img):\n    zoom_scale = np.random.uniform(1.0, 2.0)\n    height, width = img.shape[:2]\n    M = np.float32([[zoom_scale, 0, 0], [0, zoom_scale, 0]])\n    img_zoom = cv2.warpAffine(img, M, (width, height))\n    return img_zoom"}
{"nl": "Zoom an image randomly", "code": "def random_zoom(image, mask, zoom_range=(0.9, 1.1), row_axis=0, col_axis=1, channel_axis=2,\n                fill_mode='nearest', cval=0., u=0.5):\n    if np.random.random() < u:\n        zx, zy = np.random.uniform(zoom_range[0], zoom_range[1], 2)\n        zoom_matrix = np.array([[zx, 0, 0],\n                                [0, zy, 0],\n                                [0, 0, 1]])\n\n        h, w = image.shape[row_axis], image.shape[col_axis]\n        transform_matrix = transform_matrix_offset_center(zoom_matrix, h, w)\n        image = apply_transform(image, transform_matrix, channel_axis, fill_mode, cval)\n        mask = apply_transform(mask, transform_matrix, channel_axis, fill_mode, cval)\n\n    return image, mask"}
{"nl": "Zoom in on an image at random", "code": "def random_zoom(image, mask, zoom_range=(0.9, 1.1), row_axis=0, col_axis=1, channel_axis=2,\n                fill_mode='nearest', cval=0., u=0.5):\n    if np.random.random() < u:\n        zx, zy = np.random.uniform(zoom_range[0], zoom_range[1], 2)\n        zoom_matrix = np.array([[zx, 0, 0],\n                                [0, zy, 0],\n                                [0, 0, 1]])\n\n        h, w = image.shape[row_axis], image.shape[col_axis]\n        transform_matrix = transform_matrix_offset_center(zoom_matrix, h, w)\n        image = apply_transform(image, transform_matrix, channel_axis, fill_mode, cval)\n        mask = apply_transform(mask, transform_matrix, channel_axis, fill_mode, cval)\n\n    return image, mask"}
{"nl": "Create a random zoom effect on an image", "code": "def random_zoom(image, mask, zoom_range=(0.9, 1.1), row_axis=0, col_axis=1, channel_axis=2,\n                fill_mode='nearest', cval=0., u=0.5):\n    if np.random.random() < u:\n        zx, zy = np.random.uniform(zoom_range[0], zoom_range[1], 2)\n        zoom_matrix = np.array([[zx, 0, 0],\n                                [0, zy, 0],\n                                [0, 0, 1]])\n\n        h, w = image.shape[row_axis], image.shape[col_axis]\n        transform_matrix = transform_matrix_offset_center(zoom_matrix, h, w)\n        image = apply_transform(image, transform_matrix, channel_axis, fill_mode, cval)\n        mask = apply_transform(mask, transform_matrix, channel_axis, fill_mode, cval)\n\n    return image, mask"}
{"nl": "Zoom randomly", "code": "def random_zoom(img, zoom_range):\n    if random.random() < 0.5:\n        zoom_factor = random.uniform(1, zoom_range)\n        img = zoom(img, zoom_factor)\n    return img"}
{"nl": "Zoom randomly", "code": "def zoom(img, zoom_factor):\n    height, width = img.shape[:2]\n    new_height, new_width = int(height * zoom_factor), int(width * zoom_factor)\n    y1, x1 = random.randint(0, height - new_height), random.randint(0, width - new_width)\n    y2, x2 = y1 + new_height, x1 + new_width\n    bbox = np.array([y1, x1, y2, x2])\n    bbox = bbox.astype(np.float32)\n    return img[y1:y2, x1:x2], bbox"}
{"nl": "Randomly zoom an image", "code": "def random_zoom(img, zoom_range):\n    if random.random() < 0.5:\n        zoom_factor = random.uniform(1, zoom_range)\n        img = zoom(img, zoom_factor)\n    return img"}
{"nl": "Randomly zoom an image", "code": "def zoom(img, zoom_factor):\n    height, width = img.shape[:2]\n    new_height, new_width = int(height * zoom_factor), int(width * zoom_factor)\n    y1, x1 = random.randint(0, height - new_height), random.randint(0, width - new_width)\n    y2, x2 = y1 + new_height, x1 + new_width\n    bbox = np.array([y1, x1, y2, x2])\n    bbox = bbox.astype(np.float32)\n    return img[y1:y2, x1:x2], bbox"}
{"nl": "Zoom an image randomly", "code": "def random_zoom(image, mask, zoom_range=(0.9, 1.1), row_axis=0, col_axis=1, channel_axis=2,\n                fill_mode='nearest', cval=0., u=0.5):\n    if np.random.random() < u:\n        zx, zy = np.random.uniform(zoom_range[0], zoom_range[1], 2)\n        zoom_matrix = np.array([[zx, 0, 0],\n                                [0, zy, 0],\n                                [0, 0, 1]])\n\n        h, w = image.shape[row_axis], image.shape[col_axis]\n        transform_matrix = transform_matrix_offset_center(zoom_matrix, h, w)\n        image = apply_transform(image, transform_matrix, channel_axis, fill_mode, cval)\n        mask = apply_transform(mask, transform_matrix, channel_axis, fill_mode, cval)\n\n    return image, mask"}
{"nl": "Zoom an image randomly", "code": "def random_zoom(img, zoom_range):\n    if random.random() < 0.5:\n        zoom_factor = random.uniform(1, zoom_range)\n        img = zoom(img, zoom_factor)\n    return img"}
{"nl": "Zoom an image randomly", "code": "def zoom(img, zoom_factor):\n    height, width = img.shape[:2]\n    new_height, new_width = int(height * zoom_factor), int(width * zoom_factor)\n    y1, x1 = random.randint(0, height - new_height), random.randint(0, width - new_width)\n    y2, x2 = y1 + new_height, x1 + new_width\n    bbox = np.array([y1, x1, y2, x2])\n    bbox = bbox.astype(np.float32)\n    return img[y1:y2, x1:x2], bbox"}
{"nl": "Zoom in on an image at random", "code": "def zoom(img, zoom_factor):\n    height, width = img.shape[:2]\n    new_height, new_width = int(height * zoom_factor), int(width * zoom_factor)\n    y1, x1 = random.randint(0, height - new_height), random.randint(0, width - new_width)\n    y2, x2 = y1 + new_height, x1 + new_width\n    bbox = np.array([y1, x1, y2, x2])\n    bbox = bbox.astype(np.float32)\n    return img[y1:y2, x1:x2], bbox"}
{"nl": "Zoom in on an image at random", "code": "def random_zoom(img, zoom_range):\n    if random.random() < 0.5:\n        zoom_factor = random.uniform(1, zoom_range)\n        img = zoom(img, zoom_factor)\n    return img"}
{"nl": "Zoom in on an image at random", "code": "def zoom(img, zoom_factor):\n    height, width = img.shape[:2]\n    new_height, new_width = int(height * zoom_factor), int(width * zoom_factor)\n    y1, x1 = random.randint(0, height - new_height), random.randint(0, width - new_width)\n    y2, x2 = y1 + new_height, x1 + new_width\n    bbox = np.array([y1, x1, y2, x2])\n    bbox = bbox.astype(np.float32)\n    return img[y1:y2, x1:x2], bbox"}
{"nl": "Create a random zoom effect on an image", "code": "def zoom(img, zoom_factor):\n    height, width = img.shape[:2]\n    new_height, new_width = int(height * zoom_factor), int(width * zoom_factor)\n    y1, x1 = random.randint(0, height - new_height), random.randint(0, width - new_width)\n    y2, x2 = y1 + new_height, x1 + new_width\n    bbox = np.array([y1, x1, y2, x2])\n    bbox = bbox.astype(np.float32)\n    return img[y1:y2, x1:x2], bbox"}
{"nl": "Create a random zoom effect on an image", "code": "def random_zoom(img, zoom_range):\n    if random.random() < 0.5:\n        zoom_factor = random.uniform(1, zoom_range)\n        img = zoom(img, zoom_factor)\n    return img"}
{"nl": "Create a random zoom effect on an image", "code": "def zoom(img, zoom_factor):\n    height, width = img.shape[:2]\n    new_height, new_width = int(height * zoom_factor), int(width * zoom_factor)\n    y1, x1 = random.randint(0, height - new_height), random.randint(0, width - new_width)\n    y2, x2 = y1 + new_height, x1 + new_width\n    bbox = np.array([y1, x1, y2, x2])\n    bbox = bbox.astype(np.float32)\n    return img[y1:y2, x1:x2], bbox"}
{"nl": "Zoom randomly", "code": "def random_zoom(image, mask, zoom_range=(0.9, 1.1), row_axis=0, col_axis=1, channel_axis=2,\n                fill_mode='nearest', cval=0., u=0.5):\n    if np.random.random() < u:\n        zx, zy = np.random.uniform(zoom_range[0], zoom_range[1], 2)\n        zoom_matrix = np.array([[zx, 0, 0],\n                                [0, zy, 0],\n                                [0, 0, 1]])\n\n        h, w = image.shape[row_axis], image.shape[col_axis]\n        transform_matrix = transform_matrix_offset_center(zoom_matrix, h, w)\n        image = apply_transform(image, transform_matrix, channel_axis, fill_mode, cval)\n        mask = apply_transform(mask, transform_matrix, channel_axis, fill_mode, cval)\n\n    return image, mask"}
{"nl": "Zoom randomly", "code": "def zoom(img, zoom_factor):\n    height, width = img.shape[:2]\n    new_height, new_width = int(height * zoom_factor), int(width * zoom_factor)\n    y1, x1 = random.randint(0, height - new_height), random.randint(0, width - new_width)\n    y2, x2 = y1 + new_height, x1 + new_width\n    bbox = np.array([y1, x1, y2, x2])\n    bbox = bbox.astype(np.float32)\n    return img[y1:y2, x1:x2], bbox"}
{"nl": "Change the brighntess of image randomly", "code": "def random_brightness(image, mask, brightness_range=(-0.5, 0.5), u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(brightness_range[0], brightness_range[1]))\n        y = random_channel_shift(mask, np.random.uniform(brightness_range[0], brightness_range[1]))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomly alter the brightness of the image", "code": "def random_brightness(image):\n    hsv = cv2.cvtColor(image,cv2.COLOR_BGR2HSV)\n    rand = random.uniform(0.3,1.0)\n    hsv[:,:,2] = rand*hsv[:,:,2]\n    new_img = cv2.cvtColor(hsv,cv2.COLOR_HSV2BGR)\n    return new_img"}
{"nl": "Alter the image's brighntess at random", "code": "def random_brightness(image):\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    ratio = 1.0 + 0.4 * (np.random.rand() - 0.5)\n    hsv[:,:,2] =  hsv[:,:,2] * ratio\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Randomly change the brightness of an image", "code": "def increase_brightness(img):\n    M = np.ones(img.shape, dtype=\"uint8\") * 100\n    added = cv2.add(img, M)\n    return added"}
{"nl": "Randomly change the brightness of an image", "code": "def decrease_brightness(img):\n    M = np.ones(img.shape, dtype=\"uint8\") * 100\n    subtracted = cv2.subtract(img, M)\n    return subtracted"}
{"nl": "Randomly adjust the image's brightness", "code": "def random_brightness(image, mask, brightness_range=(-0.5, 0.5), u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(brightness_range[0], brightness_range[1]))\n        y = random_channel_shift(mask, np.random.uniform(brightness_range[0], brightness_range[1]))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomly tweak the brightness of the image", "code": "def random_brightness(image, mask, brightness_range=(-0.5, 0.5), u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(brightness_range[0], brightness_range[1]))\n        y = random_channel_shift(mask, np.random.uniform(brightness_range[0], brightness_range[1]))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomize image brightness", "code": "def random_brightness(image, mask, brightness_range=(-0.5, 0.5), u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(brightness_range[0], brightness_range[1]))\n        y = random_channel_shift(mask, np.random.uniform(brightness_range[0], brightness_range[1]))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Change the brighntess of image randomly", "code": "def random_brightness(image):\n    hsv = cv2.cvtColor(image,cv2.COLOR_BGR2HSV)\n    rand = random.uniform(0.3,1.0)\n    hsv[:,:,2] = rand*hsv[:,:,2]\n    new_img = cv2.cvtColor(hsv,cv2.COLOR_HSV2BGR)\n    return new_img"}
{"nl": "Change the brighntess of image randomly", "code": "def random_brightness(image):\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    ratio = 1.0 + 0.4 * (np.random.rand() - 0.5)\n    hsv[:,:,2] =  hsv[:,:,2] * ratio\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Change the brighntess of image randomly", "code": "def increase_brightness(img):\n    M = np.ones(img.shape, dtype=\"uint8\") * 100\n    added = cv2.add(img, M)\n    return added"}
{"nl": "Change the brighntess of image randomly", "code": "def decrease_brightness(img):\n    M = np.ones(img.shape, dtype=\"\"uint8\"\") * 100\n    subtracted = cv2.subtract(img, M)\n    return subtracted"}
{"nl": "Randomly alter the brightness of the image", "code": "def random_brightness(image, mask, brightness_range=(-0.5, 0.5), u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(brightness_range[0], brightness_range[1]))\n        y = random_channel_shift(mask, np.random.uniform(brightness_range[0], brightness_range[1]))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomly alter the brightness of the image", "code": "def random_brightness(image):\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    ratio = 1.0 + 0.4 * (np.random.rand() - 0.5)\n    hsv[:,:,2] =  hsv[:,:,2] * ratio\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Randomly alter the brightness of the image", "code": "def increase_brightness(img):\n    M = np.ones(img.shape, dtype=\"uint8\") * 100\n    added = cv2.add(img, M)\n    return added"}
{"nl": "Randomly alter the brightness of the image", "code": "def decrease_brightness(img):\n    M = np.ones(img.shape, dtype=\"uint8\") * 100\n    subtracted = cv2.subtract(img, M)\n    return subtracted"}
{"nl": "Alter the image's brighntess at random", "code": "def random_brightness(image, mask, brightness_range=(-0.5, 0.5), u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(brightness_range[0], brightness_range[1]))\n        y = random_channel_shift(mask, np.random.uniform(brightness_range[0], brightness_range[1]))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Alter the image's brighntess at random", "code": "def random_brightness(image):\n    hsv = cv2.cvtColor(image,cv2.COLOR_BGR2HSV)\n    rand = random.uniform(0.3,1.0)\n    hsv[:,:,2] = rand*hsv[:,:,2]\n    new_img = cv2.cvtColor(hsv,cv2.COLOR_HSV2BGR)\n    return new_img"}
{"nl": "Alter the image's brighntess at random", "code": "def increase_brightness(img):\n    M = np.ones(img.shape, dtype=\"uint8\") * 100\n    added = cv2.add(img, M)\n    return added"}
{"nl": "Alter the image's brighntess at random", "code": "def decrease_brightness(img):\n    M = np.ones(img.shape, dtype=\"uint8\") * 100\n    subtracted = cv2.subtract(img, M)\n    return subtracted"}
{"nl": "Randomly change the brightness of an image", "code": "def random_brightness(image, mask, brightness_range=(-0.5, 0.5), u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(brightness_range[0], brightness_range[1]))\n        y = random_channel_shift(mask, np.random.uniform(brightness_range[0], brightness_range[1]))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomly change the brightness of an image", "code": "def random_brightness(image):\n    hsv = cv2.cvtColor(image,cv2.COLOR_BGR2HSV)\n    rand = random.uniform(0.3,1.0)\n    hsv[:,:,2] = rand*hsv[:,:,2]\n    new_img = cv2.cvtColor(hsv,cv2.COLOR_HSV2BGR)\n    return new_img"}
{"nl": "Randomly change the brightness of an image", "code": "def random_brightness(image):\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    ratio = 1.0 + 0.4 * (np.random.rand() - 0.5)\n    hsv[:,:,2] =  hsv[:,:,2] * ratio\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Randomly adjust the image's brightness", "code": "def random_brightness(image):\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    ratio = 1.0 + 0.4 * (np.random.rand() - 0.5)\n    hsv[:,:,2] =  hsv[:,:,2] * ratio\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Randomly adjust the image's brightness", "code": "def random_brightness(image):\n    hsv = cv2.cvtColor(image,cv2.COLOR_BGR2HSV)\n    rand = random.uniform(0.3,1.0)\n    hsv[:,:,2] = rand*hsv[:,:,2]\n    new_img = cv2.cvtColor(hsv,cv2.COLOR_HSV2BGR)\n    return new_img"}
{"nl": "Randomly adjust the image's brightness", "code": "def increase_brightness(img):\n    M = np.ones(img.shape, dtype=\"uint8\") * 100\n    added = cv2.add(img, M)\n    return added"}
{"nl": "Randomly adjust the image's brightness", "code": "def decrease_brightness(img):\n    M = np.ones(img.shape, dtype=\"\"uint8\"\") * 100\n    subtracted = cv2.subtract(img, M)\n    return subtracted"}
{"nl": "Randomly tweak the brightness of the image", "code": "def random_brightness(image):\n    hsv = cv2.cvtColor(image,cv2.COLOR_BGR2HSV)\n    rand = random.uniform(0.3,1.0)\n    hsv[:,:,2] = rand*hsv[:,:,2]\n    new_img = cv2.cvtColor(hsv,cv2.COLOR_HSV2BGR)\n    return new_img"}
{"nl": "Randomly tweak the brightness of the image", "code": "def random_brightness(image):\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    ratio = 1.0 + 0.4 * (np.random.rand() - 0.5)\n    hsv[:,:,2] =  hsv[:,:,2] * ratio\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Randomly tweak the brightness of the image", "code": "def increase_brightness(img):\n    M = np.ones(img.shape, dtype=\"uint8\") * 100\n    added = cv2.add(img, M)\n    return added"}
{"nl": "Randomly tweak the brightness of the image", "code": "def decrease_brightness(img):\n    M = np.ones(img.shape, dtype=\"uint8\") * 100\n    subtracted = cv2.subtract(img, M)\n    return subtracted"}
{"nl": "Randomize image brightness", "code": "def random_brightness(image):\n    hsv = cv2.cvtColor(image,cv2.COLOR_BGR2HSV)\n    rand = random.uniform(0.3,1.0)\n    hsv[:,:,2] = rand*hsv[:,:,2]\n    new_img = cv2.cvtColor(hsv,cv2.COLOR_HSV2BGR)\n    return new_img"}
{"nl": "Randomize image brightness", "code": "def random_brightness(image):\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    ratio = 1.0 + 0.4 * (np.random.rand() - 0.5)\n    hsv[:,:,2] =  hsv[:,:,2] * ratio\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Randomize image brightness", "code": "def increase_brightness(img):\n    M = np.ones(img.shape, dtype=\"uint8\") * 100\n    added = cv2.add(img, M)\n    return added"}
{"nl": "Randomize image brightness", "code": "def decrease_brightness(img):\n    M = np.ones(img.shape, dtype=\"uint8\") * 100\n    subtracted = cv2.subtract(img, M)\n    return subtracted"}
{"nl": "Shift the channels randomly", "code": "def random_channel_shift(image, intensity, channel_axis=2, u=0.5):\n    if np.random.random() < u:\n        image = np.rollaxis(image, channel_axis, 0)\n        min_x, max_x = np.min(image), np.max(image)\n        channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n                          for x_channel in image]\n        image = np.stack(channel_images, axis=0)\n        image = np.rollaxis(image, 0, channel_axis + 1)\n    return image"}
{"nl": "Shift the channels randomly", "code": "def random_channel_shift(x, intensity, channel_index=0):\n    x = np.rollaxis(x, channel_index, 0)\n    min_x, max_x = np.min(x), np.max(x)\n    channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n                      for x_channel in x]\n    x = np.stack(channel_images, axis=0)\n    x = np.rollaxis(x, 0, channel_index+1)\n    return x"}
{"nl": "Shift the channels of image randomly", "code": "def random_shift_channels(img):\n    img_copy = img.copy()\n    channels = cv2.split(img_copy)\n    random.shuffle(channels)\n    return cv2.merge(channels)"}
{"nl": "Randomly shift\u00a0the image channels", "code": "def random_channel_shift(image, intensity, channel_axis=2, u=0.5):\n    if np.random.random() < u:\n        image = np.rollaxis(image, channel_axis, 0)\n        min_x, max_x = np.min(image), np.max(image)\n        channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n                          for x_channel in image]\n        image = np.stack(channel_images, axis=0)\n        image = np.rollaxis(image, 0, channel_axis + 1)\n    return image"}
{"nl": "Randomly shift the channels of an image", "code": "def random_channel_shift(image, intensity, channel_axis=2, u=0.5):\n    if np.random.random() < u:\n        image = np.rollaxis(image, channel_axis, 0)\n        min_x, max_x = np.min(image), np.max(image)\n        channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n                          for x_channel in image]\n        image = np.stack(channel_images, axis=0)\n        image = np.rollaxis(image, 0, channel_axis + 1)\n    return image"}
{"nl": "randomise the image channel shift", "code": "def random_channel_shift(image, intensity, channel_axis=2, u=0.5):\n    if np.random.random() < u:\n        image = np.rollaxis(image, channel_axis, 0)\n        min_x, max_x = np.min(image), np.max(image)\n        channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n                          for x_channel in image]\n        image = np.stack(channel_images, axis=0)\n        image = np.rollaxis(image, 0, channel_axis + 1)\n    return image"}
{"nl": "Randomise the shift of the image channels", "code": "def random_channel_shift(image, intensity, channel_axis=2, u=0.5):\n    if np.random.random() < u:\n        image = np.rollaxis(image, channel_axis, 0)\n        min_x, max_x = np.min(image), np.max(image)\n        channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n                          for x_channel in image]\n        image = np.stack(channel_images, axis=0)\n        image = np.rollaxis(image, 0, channel_axis + 1)\n    return image"}
{"nl": "Shift the channels randomly", "code": "def random_shift_channels(img):\n    img_copy = img.copy()\n    channels = cv2.split(img_copy)\n    random.shuffle(channels)\n    return cv2.merge(channels)"}
{"nl": "Shift the channels of image randomly", "code": "def random_channel_shift(image, intensity, channel_axis=2, u=0.5):\n    if np.random.random() < u:\n        image = np.rollaxis(image, channel_axis, 0)\n        min_x, max_x = np.min(image), np.max(image)\n        channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n                          for x_channel in image]\n        image = np.stack(channel_images, axis=0)\n        image = np.rollaxis(image, 0, channel_axis + 1)\n    return image"}
{"nl": "Shift the channels of image randomly", "code": "def random_channel_shift(x, intensity, channel_index=0):\n    x = np.rollaxis(x, channel_index, 0)\n    min_x, max_x = np.min(x), np.max(x)\n    channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n                      for x_channel in x]\n    x = np.stack(channel_images, axis=0)\n    x = np.rollaxis(x, 0, channel_index+1)\n    return x"}
{"nl": "Randomly shift\u00a0the image channels", "code": "def random_channel_shift(x, intensity, channel_index=0):\n    x = np.rollaxis(x, channel_index, 0)\n    min_x, max_x = np.min(x), np.max(x)\n    channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n                      for x_channel in x]\n    x = np.stack(channel_images, axis=0)\n    x = np.rollaxis(x, 0, channel_index+1)\n    return x"}
{"nl": "Randomly shift\u00a0the image channels", "code": "def random_shift_channels(img):\n    img_copy = img.copy()\n    channels = cv2.split(img_copy)\n    random.shuffle(channels)\n    return cv2.merge(channels)"}
{"nl": "Randomly shift the channels of an image", "code": "def random_channel_shift(x, intensity, channel_index=0):\n    x = np.rollaxis(x, channel_index, 0)\n    min_x, max_x = np.min(x), np.max(x)\n    channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n                      for x_channel in x]\n    x = np.stack(channel_images, axis=0)\n    x = np.rollaxis(x, 0, channel_index+1)\n    return x"}
{"nl": "Randomly shift the channels of an image", "code": "def random_shift_channels(img):\n    img_copy = img.copy()\n    channels = cv2.split(img_copy)\n    random.shuffle(channels)\n    return cv2.merge(channels)"}
{"nl": "randomise the image channel shift", "code": "def random_channel_shift(x, intensity, channel_index=0):\n    x = np.rollaxis(x, channel_index, 0)\n    min_x, max_x = np.min(x), np.max(x)\n    channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n                      for x_channel in x]\n    x = np.stack(channel_images, axis=0)\n    x = np.rollaxis(x, 0, channel_index+1)\n    return x"}
{"nl": "randomise the image channel shift", "code": "def random_shift_channels(img):\n    img_copy = img.copy()\n    channels = cv2.split(img_copy)\n    random.shuffle(channels)\n    return cv2.merge(channels)"}
{"nl": "Randomise the shift of the image channels", "code": "def random_channel_shift(x, intensity, channel_index=0):\n    x = np.rollaxis(x, channel_index, 0)\n    min_x, max_x = np.min(x), np.max(x)\n    channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n                      for x_channel in x]\n    x = np.stack(channel_images, axis=0)\n    x = np.rollaxis(x, 0, channel_index+1)\n    return x"}
{"nl": "Randomise the shift of the image channels", "code": "def random_shift_channels(img):\n    img_copy = img.copy()\n    channels = cv2.split(img_copy)\n    random.shuffle(channels)\n    return cv2.merge(channels)"}
{"nl": "Change the contrast of image randomly", "code": "def random_contrast(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomly change the image's contrast", "code": "def _random_contrast_3d_nd(image, lower, upper):\n    factor = np.random.uniform(lower, upper)\n    return np.clip(factor * image, 0, 255).astype(np.uint8)"}
{"nl": "Change the image's contrast at random", "code": "def random_contrast(image, lower=0.5, upper=1.5):\n    eigval = cv2.PCA(image, None, cv2.CV_64F).eigenvalues\n    eigval = eigval.flatten().astype(np.float32)\n    alpha = np.random.uniform(lower, upper)\n    gray = image * alpha\n    gray = np.clip(gray, 0, 255).astype(np.uint8)\n    return gray"}
{"nl": "Change the image's contrast in a random way.", "code": "def change_contrast(img, contrast_factor):\n    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img_hsv[:, :, 2] = img_hsv[:, :, 2] * contrast_factor\n    img_bgr = cv2.cvtColor(img_hsv, cv2.COLOR_HSV2BGR)\n    return img_bgr"}
{"nl": "Alter the image's contrast at random", "code": "def random_contrast(img, lower=0.5, upper=1.5):\n    e = np.random.uniform(lower, upper)\n    img = img * e\n    return img"}
{"nl": "Randomize image contrast", "code": "def randomize_contrast(image, min_factor=0.5, max_factor=1.5):\n    factor = np.random.uniform(min_factor, max_factor)\n    image = image.astype(np.float32)\n    image *= factor\n    return image"}
{"nl": "Randomly alter the image's contrast", "code": "def random_contrast(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomly alter the image's contrast", "code": "def _random_contrast_3d_nd(image, lower, upper):\n    factor = np.random.uniform(lower, upper)\n    return np.clip(factor * image, 0, 255).astype(np.uint8)"}
{"nl": "Randomly alter the image's contrast", "code": "def random_contrast(image, lower=0.5, upper=1.5):\n    eigval = cv2.PCA(image, None, cv2.CV_64F).eigenvalues\n    eigval = eigval.flatten().astype(np.float32)\n    alpha = np.random.uniform(lower, upper)\n    gray = image * alpha\n    gray = np.clip(gray, 0, 255).astype(np.uint8)\n    return gray"}
{"nl": "Randomly alter the image's contrast", "code": "def random_contrast(img, lower=0.5, upper=1.5):\n    e = np.random.uniform(lower, upper)\n    img = img * e\n    return img"}
{"nl": "Randomly alter the image's contrast", "code": "def change_contrast(img, contrast_factor):\n    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img_hsv[:, :, 2] = img_hsv[:, :, 2] * contrast_factor\n    img_bgr = cv2.cvtColor(img_hsv, cv2.COLOR_HSV2BGR)\n    return img_bgr"}
{"nl": "Randomly alter the image's contrast", "code": "def randomize_contrast(image, min_factor=0.5, max_factor=1.5):\n    factor = np.random.uniform(min_factor, max_factor)\n    image = image.astype(np.float32)\n    image *= factor\n    return image"}
{"nl": "Change the contrast of image randomly", "code": "def _random_contrast_3d_nd(image, lower, upper):\n    factor = np.random.uniform(lower, upper)\n    return np.clip(factor * image, 0, 255).astype(np.uint8)"}
{"nl": "Change the contrast of image randomly", "code": "def random_contrast(image, lower=0.5, upper=1.5):\n    eigval = cv2.PCA(image, None, cv2.CV_64F).eigenvalues\n    eigval = eigval.flatten().astype(np.float32)\n    alpha = np.random.uniform(lower, upper)\n    gray = image * alpha\n    gray = np.clip(gray, 0, 255).astype(np.uint8)\n    return gray"}
{"nl": "Change the contrast of image randomly", "code": "def random_contrast(img, lower=0.5, upper=1.5):\n    e = np.random.uniform(lower, upper)\n    img = img * e\n    return img"}
{"nl": "Change the contrast of image randomly", "code": "def change_contrast(img, contrast_factor):\n    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img_hsv[:, :, 2] = img_hsv[:, :, 2] * contrast_factor\n    img_bgr = cv2.cvtColor(img_hsv, cv2.COLOR_HSV2BGR)\n    return img_bgr"}
{"nl": "Change the contrast of image randomly", "code": "def randomize_contrast(image, min_factor=0.5, max_factor=1.5):\n    factor = np.random.uniform(min_factor, max_factor)\n    image = image.astype(np.float32)\n    image *= factor\n    return image"}
{"nl": "Randomly change the image's contrast", "code": "def random_contrast(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomly change the image's contrast", "code": "def random_contrast(image, lower=0.5, upper=1.5):\n    eigval = cv2.PCA(image, None, cv2.CV_64F).eigenvalues\n    eigval = eigval.flatten().astype(np.float32)\n    alpha = np.random.uniform(lower, upper)\n    gray = image * alpha\n    gray = np.clip(gray, 0, 255).astype(np.uint8)\n    return gray"}
{"nl": "Randomly change the image's contrast", "code": "def random_contrast(img, lower=0.5, upper=1.5):\n    e = np.random.uniform(lower, upper)\n    img = img * e\n    return img"}
{"nl": "Randomly change the image's contrast", "code": "def change_contrast(img, contrast_factor):\n    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img_hsv[:, :, 2] = img_hsv[:, :, 2] * contrast_factor\n    img_bgr = cv2.cvtColor(img_hsv, cv2.COLOR_HSV2BGR)\n    return img_bgr"}
{"nl": "Randomly change the image's contrast", "code": "def randomize_contrast(image, min_factor=0.5, max_factor=1.5):\n    factor = np.random.uniform(min_factor, max_factor)\n    image = image.astype(np.float32)\n    image *= factor\n    return image"}
{"nl": "Change the image's contrast at random", "code": "def random_contrast(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Change the image's contrast at random", "code": "def _random_contrast_3d_nd(image, lower, upper):\n    factor = np.random.uniform(lower, upper)\n    return np.clip(factor * image, 0, 255).astype(np.uint8)"}
{"nl": "Change the image's contrast at random", "code": "def random_contrast(img, lower=0.5, upper=1.5):\n    e = np.random.uniform(lower, upper)\n    img = img * e\n    return img"}
{"nl": "Change the image's contrast at random", "code": "def change_contrast(img, contrast_factor):\n    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img_hsv[:, :, 2] = img_hsv[:, :, 2] * contrast_factor\n    img_bgr = cv2.cvtColor(img_hsv, cv2.COLOR_HSV2BGR)\n    return img_bgr"}
{"nl": "Change the image's contrast at random", "code": "def randomize_contrast(image, min_factor=0.5, max_factor=1.5):\n    factor = np.random.uniform(min_factor, max_factor)\n    image = image.astype(np.float32)\n    image *= factor\n    return image"}
{"nl": "Change the image's contrast in a random way.", "code": "def random_contrast(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Change the image's contrast in a random way.", "code": "def _random_contrast_3d_nd(image, lower, upper):\n    factor = np.random.uniform(lower, upper)\n    return np.clip(factor * image, 0, 255).astype(np.uint8)"}
{"nl": "Change the image's contrast in a random way.", "code": "def random_contrast(image, lower=0.5, upper=1.5):\n    eigval = cv2.PCA(image, None, cv2.CV_64F).eigenvalues\n    eigval = eigval.flatten().astype(np.float32)\n    alpha = np.random.uniform(lower, upper)\n    gray = image * alpha\n    gray = np.clip(gray, 0, 255).astype(np.uint8)\n    return gray"}
{"nl": "Change the image's contrast in a random way.", "code": "def random_contrast(img, lower=0.5, upper=1.5):\n    e = np.random.uniform(lower, upper)\n    img = img * e\n    return img"}
{"nl": "Change the image's contrast in a random way.", "code": "def randomize_contrast(image, min_factor=0.5, max_factor=1.5):\n    factor = np.random.uniform(min_factor, max_factor)\n    image = image.astype(np.float32)\n    image *= factor\n    return image"}
{"nl": "Alter the image's contrast at random", "code": "def random_contrast(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Alter the image's contrast at random", "code": "def _random_contrast_3d_nd(image, lower, upper):\n    factor = np.random.uniform(lower, upper)\n    return np.clip(factor * image, 0, 255).astype(np.uint8)"}
{"nl": "Alter the image's contrast at random", "code": "def random_contrast(image, lower=0.5, upper=1.5):\n    eigval = cv2.PCA(image, None, cv2.CV_64F).eigenvalues\n    eigval = eigval.flatten().astype(np.float32)\n    alpha = np.random.uniform(lower, upper)\n    gray = image * alpha\n    gray = np.clip(gray, 0, 255).astype(np.uint8)\n    return gray"}
{"nl": "Alter the image's contrast at random", "code": "def change_contrast(img, contrast_factor):\n    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img_hsv[:, :, 2] = img_hsv[:, :, 2] * contrast_factor\n    img_bgr = cv2.cvtColor(img_hsv, cv2.COLOR_HSV2BGR)\n    return img_bgr"}
{"nl": "Alter the image's contrast at random", "code": "def randomize_contrast(image, min_factor=0.5, max_factor=1.5):\n    factor = np.random.uniform(min_factor, max_factor)\n    image = image.astype(np.float32)\n    image *= factor\n    return image"}
{"nl": "Randomize image contrast", "code": "def random_contrast(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomize image contrast", "code": "def _random_contrast_3d_nd(image, lower, upper):\n    factor = np.random.uniform(lower, upper)\n    return np.clip(factor * image, 0, 255).astype(np.uint8)"}
{"nl": "Randomize image contrast", "code": "def random_contrast(image, lower=0.5, upper=1.5):\n    eigval = cv2.PCA(image, None, cv2.CV_64F).eigenvalues\n    eigval = eigval.flatten().astype(np.float32)\n    alpha = np.random.uniform(lower, upper)\n    gray = image * alpha\n    gray = np.clip(gray, 0, 255).astype(np.uint8)\n    return gray"}
{"nl": "Randomize image contrast", "code": "def random_contrast(img, lower=0.5, upper=1.5):\n    e = np.random.uniform(lower, upper)\n    img = img * e\n    return img"}
{"nl": "Randomize image contrast", "code": "def change_contrast(img, contrast_factor):\n    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img_hsv[:, :, 2] = img_hsv[:, :, 2] * contrast_factor\n    img_bgr = cv2.cvtColor(img_hsv, cv2.COLOR_HSV2BGR)\n    return img_bgr"}
{"nl": "Change the saturation of image randomly", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Adjust the saturation of image randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    saturation = np.random.uniform(lower, upper)\n    image[:, :, 1] = image[:, :, 1] * saturation\n\n    return cv2.cvtColor(image, cv2.COLOR_HSV2BGR)"}
{"nl": "Randomly alter the image's saturation", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = tf.image.random_saturation(image, lower, upper)\n    return image"}
{"nl": "Randomly change the image's saturation", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    if not _is_numpy_image(image):\n        raise TypeError('Input image should be 3D array.')\n\n    saturation_factor = np.random.uniform(lower, upper)\n\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    hsv[:, :, 1] = hsv[:, :, 1] * saturation_factor\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Randomly set the image's saturation", "code": "def randomize_saturation(image, lower=0.5, upper=1.5):\n    img = image.astype(np.float32)\n    img = img * np.random.uniform(lower, upper)\n    img = img.clip(0, 255).astype(np.uint8)\n    return img"}
{"nl": "Randomly adjust the image's saturation", "code": "def random_saturation(image):\n    image = np.array(image, dtype=np.float64)\n    random_scale = np.random.uniform(low=0.5, high=1.5)\n    image[:, :, 1] *= random_scale\n    image[image[:, :, 1] > 255] = 255\n    image = np.array(image, dtype=np.uint8)\n    return image"}
{"nl": "Change\u00a0the saturation of an image at random", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    saturation = np.random.uniform(lower, upper)\n    image[:, :, 1] = image[:, :, 1] * saturation\n    image = cv2.cvtColor(image, cv2.COLOR_HSV2BGR)\n    return image"}
{"nl": "Randomize image saturation", "code": "def saturation(image):\n    saturation_factor = np.random.uniform(low=0.5, high=1.5)\n    image_HLS = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)\n    image_HLS[:, :, 1] = image_HLS[:, :, 1] * saturation_factor\n    image_RGB = cv2.cvtColor(image_HLS, cv2.COLOR_HLS2RGB)\n    return image_RGB"}
{"nl": "Alter the image saturation randomly", "code": "def random_saturation(img, lower=0.5, upper=1.5):\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img = np.array(img, dtype=np.float32)\n    random_scale = np.random.uniform(lower, upper)\n    img[:, :, 1] = img[:, :, 1] * random_scale\n    img[:, :, 1][img[:, :, 1] > 255] = 255\n    img = np.array(img, dtype=np.uint8)\n    img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)\n    return img"}
{"nl": "Alter the saturation of image randomly", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Set the image saturation randomly", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Set the saturation of image randomly", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Adjust the image saturation randomly", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Change the saturation of image randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = tf.image.random_saturation(image, lower, upper)\n    return image"}
{"nl": "Change the saturation of image randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    if not _is_numpy_image(image):\n        raise TypeError('Input image should be 3D array.')\n\n    saturation_factor = np.random.uniform(lower, upper)\n\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    hsv[:, :, 1] = hsv[:, :, 1] * saturation_factor\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Change the saturation of image randomly", "code": "def randomize_saturation(image, lower=0.5, upper=1.5):\n    img = image.astype(np.float32)\n    img = img * np.random.uniform(lower, upper)\n    img = img.clip(0, 255).astype(np.uint8)\n    return img"}
{"nl": "Change the saturation of image randomly", "code": "def random_saturation(image):\n    image = np.array(image, dtype=np.float64)\n    random_scale = np.random.uniform(low=0.5, high=1.5)\n    image[:, :, 1] *= random_scale\n    image[image[:, :, 1] > 255] = 255\n    image = np.array(image, dtype=np.uint8)\n    return image"}
{"nl": "Change the saturation of image randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    saturation = np.random.uniform(lower, upper)\n    image[:, :, 1] = image[:, :, 1] * saturation\n    image = cv2.cvtColor(image, cv2.COLOR_HSV2BGR)\n    return image"}
{"nl": "Change the saturation of image randomly", "code": "def saturation(image):\n    saturation_factor = np.random.uniform(low=0.5, high=1.5)\n    image_HLS = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)\n    image_HLS[:, :, 1] = image_HLS[:, :, 1] * saturation_factor\n    image_RGB = cv2.cvtColor(image_HLS, cv2.COLOR_HLS2RGB)\n    return image_RGB"}
{"nl": "Change the saturation of image randomly", "code": "def random_saturation(img, lower=0.5, upper=1.5):\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img = np.array(img, dtype=np.float32)\n    random_scale = np.random.uniform(lower, upper)\n    img[:, :, 1] = img[:, :, 1] * random_scale\n    img[:, :, 1][img[:, :, 1] > 255] = 255\n    img = np.array(img, dtype=np.uint8)\n    img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)\n    return img"}
{"nl": "Change the saturation of image randomly", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Adjust the saturation of image randomly", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Adjust the saturation of image randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = tf.image.random_saturation(image, lower, upper)\n    return image"}
{"nl": "Adjust the saturation of image randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    if not _is_numpy_image(image):\n        raise TypeError('Input image should be 3D array.')\n\n    saturation_factor = np.random.uniform(lower, upper)\n\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    hsv[:, :, 1] = hsv[:, :, 1] * saturation_factor\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Adjust the saturation of image randomly", "code": "def randomize_saturation(image, lower=0.5, upper=1.5):\n    img = image.astype(np.float32)\n    img = img * np.random.uniform(lower, upper)\n    img = img.clip(0, 255).astype(np.uint8)\n    return img"}
{"nl": "Adjust the saturation of image randomly", "code": "def random_saturation(image):\n    image = np.array(image, dtype=np.float64)\n    random_scale = np.random.uniform(low=0.5, high=1.5)\n    image[:, :, 1] *= random_scale\n    image[image[:, :, 1] > 255] = 255\n    image = np.array(image, dtype=np.uint8)\n    return image"}
{"nl": "Adjust the saturation of image randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    saturation = np.random.uniform(lower, upper)\n    image[:, :, 1] = image[:, :, 1] * saturation\n    image = cv2.cvtColor(image, cv2.COLOR_HSV2BGR)\n    return image"}
{"nl": "Adjust the saturation of image randomly", "code": "def saturation(image):\n    saturation_factor = np.random.uniform(low=0.5, high=1.5)\n    image_HLS = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)\n    image_HLS[:, :, 1] = image_HLS[:, :, 1] * saturation_factor\n    image_RGB = cv2.cvtColor(image_HLS, cv2.COLOR_HLS2RGB)\n    return image_RGB"}
{"nl": "Adjust the saturation of image randomly", "code": "def random_saturation(img, lower=0.5, upper=1.5):\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img = np.array(img, dtype=np.float32)\n    random_scale = np.random.uniform(lower, upper)\n    img[:, :, 1] = img[:, :, 1] * random_scale\n    img[:, :, 1][img[:, :, 1] > 255] = 255\n    img = np.array(img, dtype=np.uint8)\n    img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)\n    return img"}
{"nl": "Randomly alter the image's saturation", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomly alter the image's saturation", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    if not _is_numpy_image(image):\n        raise TypeError('Input image should be 3D array.')\n\n    saturation_factor = np.random.uniform(lower, upper)\n\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    hsv[:, :, 1] = hsv[:, :, 1] * saturation_factor\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Randomly alter the image's saturation", "code": "def randomize_saturation(image, lower=0.5, upper=1.5):\n    img = image.astype(np.float32)\n    img = img * np.random.uniform(lower, upper)\n    img = img.clip(0, 255).astype(np.uint8)\n    return img"}
{"nl": "Randomly alter the image's saturation", "code": "def random_saturation(image):\n    image = np.array(image, dtype=np.float64)\n    random_scale = np.random.uniform(low=0.5, high=1.5)\n    image[:, :, 1] *= random_scale\n    image[image[:, :, 1] > 255] = 255\n    image = np.array(image, dtype=np.uint8)\n    return image"}
{"nl": "Randomly alter the image's saturation", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    saturation = np.random.uniform(lower, upper)\n    image[:, :, 1] = image[:, :, 1] * saturation\n    image = cv2.cvtColor(image, cv2.COLOR_HSV2BGR)\n    return image"}
{"nl": "Randomly alter the image's saturation", "code": "def saturation(image):\n    saturation_factor = np.random.uniform(low=0.5, high=1.5)\n    image_HLS = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)\n    image_HLS[:, :, 1] = image_HLS[:, :, 1] * saturation_factor\n    image_RGB = cv2.cvtColor(image_HLS, cv2.COLOR_HLS2RGB)\n    return image_RGB"}
{"nl": "Randomly alter the image's saturation", "code": "def random_saturation(img, lower=0.5, upper=1.5):\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img = np.array(img, dtype=np.float32)\n    random_scale = np.random.uniform(lower, upper)\n    img[:, :, 1] = img[:, :, 1] * random_scale\n    img[:, :, 1][img[:, :, 1] > 255] = 255\n    img = np.array(img, dtype=np.uint8)\n    img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)\n    return img"}
{"nl": "Randomly alter the image's saturation", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomly change the image's saturation", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomly change the image's saturation", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = tf.image.random_saturation(image, lower, upper)\n    return image"}
{"nl": "Randomly change the image's saturation", "code": "def randomize_saturation(image, lower=0.5, upper=1.5):\n    img = image.astype(np.float32)\n    img = img * np.random.uniform(lower, upper)\n    img = img.clip(0, 255).astype(np.uint8)\n    return img"}
{"nl": "Randomly change the image's saturation", "code": "def random_saturation(image):\n    image = np.array(image, dtype=np.float64)\n    random_scale = np.random.uniform(low=0.5, high=1.5)\n    image[:, :, 1] *= random_scale\n    image[image[:, :, 1] > 255] = 255\n    image = np.array(image, dtype=np.uint8)\n    return image"}
{"nl": "Randomly change the image's saturation", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    saturation = np.random.uniform(lower, upper)\n    image[:, :, 1] = image[:, :, 1] * saturation\n    image = cv2.cvtColor(image, cv2.COLOR_HSV2BGR)\n    return image"}
{"nl": "Randomly change the image's saturation", "code": "def saturation(image):\n    saturation_factor = np.random.uniform(low=0.5, high=1.5)\n    image_HLS = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)\n    image_HLS[:, :, 1] = image_HLS[:, :, 1] * saturation_factor\n    image_RGB = cv2.cvtColor(image_HLS, cv2.COLOR_HLS2RGB)\n    return image_RGB"}
{"nl": "Randomly change the image's saturation", "code": "def random_saturation(img, lower=0.5, upper=1.5):\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img = np.array(img, dtype=np.float32)\n    random_scale = np.random.uniform(lower, upper)\n    img[:, :, 1] = img[:, :, 1] * random_scale\n    img[:, :, 1][img[:, :, 1] > 255] = 255\n    img = np.array(img, dtype=np.uint8)\n    img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)\n    return img"}
{"nl": "Randomly change the image's saturation", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomly set the image's saturation", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomly set the image's saturation", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = tf.image.random_saturation(image, lower, upper)\n    return image"}
{"nl": "Randomly set the image's saturation", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    if not _is_numpy_image(image):\n        raise TypeError('Input image should be 3D array.')\n\n    saturation_factor = np.random.uniform(lower, upper)\n\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    hsv[:, :, 1] = hsv[:, :, 1] * saturation_factor\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Randomly set the image's saturation", "code": "def random_saturation(image):\n    image = np.array(image, dtype=np.float64)\n    random_scale = np.random.uniform(low=0.5, high=1.5)\n    image[:, :, 1] *= random_scale\n    image[image[:, :, 1] > 255] = 255\n    image = np.array(image, dtype=np.uint8)\n    return image"}
{"nl": "Randomly set the image's saturation", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    saturation = np.random.uniform(lower, upper)\n    image[:, :, 1] = image[:, :, 1] * saturation\n    image = cv2.cvtColor(image, cv2.COLOR_HSV2BGR)\n    return image"}
{"nl": "Randomly set the image's saturation", "code": "def saturation(image):\n    saturation_factor = np.random.uniform(low=0.5, high=1.5)\n    image_HLS = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)\n    image_HLS[:, :, 1] = image_HLS[:, :, 1] * saturation_factor\n    image_RGB = cv2.cvtColor(image_HLS, cv2.COLOR_HLS2RGB)\n    return image_RGB"}
{"nl": "Randomly set the image's saturation", "code": "def random_saturation(img, lower=0.5, upper=1.5):\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img = np.array(img, dtype=np.float32)\n    random_scale = np.random.uniform(lower, upper)\n    img[:, :, 1] = img[:, :, 1] * random_scale\n    img[:, :, 1][img[:, :, 1] > 255] = 255\n    img = np.array(img, dtype=np.uint8)\n    img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)\n    return img"}
{"nl": "Randomly set the image's saturation", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomly adjust the image's saturation", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomly adjust the image's saturation", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = tf.image.random_saturation(image, lower, upper)\n    return image"}
{"nl": "Randomly adjust the image's saturation", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    if not _is_numpy_image(image):\n        raise TypeError('Input image should be 3D array.')\n\n    saturation_factor = np.random.uniform(lower, upper)\n\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    hsv[:, :, 1] = hsv[:, :, 1] * saturation_factor\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Randomly adjust the image's saturation", "code": "def randomize_saturation(image, lower=0.5, upper=1.5):\n    img = image.astype(np.float32)\n    img = img * np.random.uniform(lower, upper)\n    img = img.clip(0, 255).astype(np.uint8)\n    return img"}
{"nl": "Randomly adjust the image's saturation", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    saturation = np.random.uniform(lower, upper)\n    image[:, :, 1] = image[:, :, 1] * saturation\n    image = cv2.cvtColor(image, cv2.COLOR_HSV2BGR)\n    return image"}
{"nl": "Randomly adjust the image's saturation", "code": "def saturation(image):\n    saturation_factor = np.random.uniform(low=0.5, high=1.5)\n    image_HLS = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)\n    image_HLS[:, :, 1] = image_HLS[:, :, 1] * saturation_factor\n    image_RGB = cv2.cvtColor(image_HLS, cv2.COLOR_HLS2RGB)\n    return image_RGB"}
{"nl": "Randomly adjust the image's saturation", "code": "def random_saturation(img, lower=0.5, upper=1.5):\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img = np.array(img, dtype=np.float32)\n    random_scale = np.random.uniform(lower, upper)\n    img[:, :, 1] = img[:, :, 1] * random_scale\n    img[:, :, 1][img[:, :, 1] > 255] = 255\n    img = np.array(img, dtype=np.uint8)\n    img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)\n    return img"}
{"nl": "Randomly adjust the image's saturation", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Change\u00a0the saturation of an image at random", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Change\u00a0the saturation of an image at random", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = tf.image.random_saturation(image, lower, upper)\n    return image"}
{"nl": "Change\u00a0the saturation of an image at random", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    if not _is_numpy_image(image):\n        raise TypeError('Input image should be 3D array.')\n\n    saturation_factor = np.random.uniform(lower, upper)\n\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    hsv[:, :, 1] = hsv[:, :, 1] * saturation_factor\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Change\u00a0the saturation of an image at random", "code": "def randomize_saturation(image, lower=0.5, upper=1.5):\n    img = image.astype(np.float32)\n    img = img * np.random.uniform(lower, upper)\n    img = img.clip(0, 255).astype(np.uint8)\n    return img"}
{"nl": "Change\u00a0the saturation of an image at random", "code": "def random_saturation(image):\n    image = np.array(image, dtype=np.float64)\n    random_scale = np.random.uniform(low=0.5, high=1.5)\n    image[:, :, 1] *= random_scale\n    image[image[:, :, 1] > 255] = 255\n    image = np.array(image, dtype=np.uint8)\n    return image"}
{"nl": "Change\u00a0the saturation of an image at random", "code": "def saturation(image):\n    saturation_factor = np.random.uniform(low=0.5, high=1.5)\n    image_HLS = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)\n    image_HLS[:, :, 1] = image_HLS[:, :, 1] * saturation_factor\n    image_RGB = cv2.cvtColor(image_HLS, cv2.COLOR_HLS2RGB)\n    return image_RGB"}
{"nl": "Change\u00a0the saturation of an image at random", "code": "def random_saturation(img, lower=0.5, upper=1.5):\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img = np.array(img, dtype=np.float32)\n    random_scale = np.random.uniform(lower, upper)\n    img[:, :, 1] = img[:, :, 1] * random_scale\n    img[:, :, 1][img[:, :, 1] > 255] = 255\n    img = np.array(img, dtype=np.uint8)\n    img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)\n    return img"}
{"nl": "Change\u00a0the saturation of an image at random", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomize image saturation", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Randomize image saturation", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = tf.image.random_saturation(image, lower, upper)\n    return image"}
{"nl": "Randomize image saturation", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    if not _is_numpy_image(image):\n        raise TypeError('Input image should be 3D array.')\n\n    saturation_factor = np.random.uniform(lower, upper)\n\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    hsv[:, :, 1] = hsv[:, :, 1] * saturation_factor\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Randomize image saturation", "code": "def randomize_saturation(image, lower=0.5, upper=1.5):\n    img = image.astype(np.float32)\n    img = img * np.random.uniform(lower, upper)\n    img = img.clip(0, 255).astype(np.uint8)\n    return img"}
{"nl": "Randomize image saturation", "code": "def random_saturation(image):\n    image = np.array(image, dtype=np.float64)\n    random_scale = np.random.uniform(low=0.5, high=1.5)\n    image[:, :, 1] *= random_scale\n    image[image[:, :, 1] > 255] = 255\n    image = np.array(image, dtype=np.uint8)\n    return image"}
{"nl": "Randomize image saturation", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    saturation = np.random.uniform(lower, upper)\n    image[:, :, 1] = image[:, :, 1] * saturation\n    image = cv2.cvtColor(image, cv2.COLOR_HSV2BGR)\n    return image"}
{"nl": "Randomize image saturation", "code": "def random_saturation(img, lower=0.5, upper=1.5):\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img = np.array(img, dtype=np.float32)\n    random_scale = np.random.uniform(lower, upper)\n    img[:, :, 1] = img[:, :, 1] * random_scale\n    img[:, :, 1][img[:, :, 1] > 255] = 255\n    img = np.array(img, dtype=np.uint8)\n    img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)\n    return img"}
{"nl": "Randomize image saturation", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Alter the image saturation randomly", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Alter the image saturation randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = tf.image.random_saturation(image, lower, upper)\n    return image"}
{"nl": "Alter the image saturation randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    if not _is_numpy_image(image):\n        raise TypeError('Input image should be 3D array.')\n\n    saturation_factor = np.random.uniform(lower, upper)\n\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    hsv[:, :, 1] = hsv[:, :, 1] * saturation_factor\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Alter the image saturation randomly", "code": "def randomize_saturation(image, lower=0.5, upper=1.5):\n    img = image.astype(np.float32)\n    img = img * np.random.uniform(lower, upper)\n    img = img.clip(0, 255).astype(np.uint8)\n    return img"}
{"nl": "Alter the image saturation randomly", "code": "def random_saturation(image):\n    image = np.array(image, dtype=np.float64)\n    random_scale = np.random.uniform(low=0.5, high=1.5)\n    image[:, :, 1] *= random_scale\n    image[image[:, :, 1] > 255] = 255\n    image = np.array(image, dtype=np.uint8)\n    return image"}
{"nl": "Alter the image saturation randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    saturation = np.random.uniform(lower, upper)\n    image[:, :, 1] = image[:, :, 1] * saturation\n    image = cv2.cvtColor(image, cv2.COLOR_HSV2BGR)\n    return image"}
{"nl": "Alter the image saturation randomly", "code": "def saturation(image):\n    saturation_factor = np.random.uniform(low=0.5, high=1.5)\n    image_HLS = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)\n    image_HLS[:, :, 1] = image_HLS[:, :, 1] * saturation_factor\n    image_RGB = cv2.cvtColor(image_HLS, cv2.COLOR_HLS2RGB)\n    return image_RGB"}
{"nl": "Alter the image saturation randomly", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Alter the saturation of image randomly", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Alter the saturation of image randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = tf.image.random_saturation(image, lower, upper)\n    return image"}
{"nl": "Alter the saturation of image randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    if not _is_numpy_image(image):\n        raise TypeError('Input image should be 3D array.')\n\n    saturation_factor = np.random.uniform(lower, upper)\n\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    hsv[:, :, 1] = hsv[:, :, 1] * saturation_factor\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Alter the saturation of image randomly", "code": "def randomize_saturation(image, lower=0.5, upper=1.5):\n    img = image.astype(np.float32)\n    img = img * np.random.uniform(lower, upper)\n    img = img.clip(0, 255).astype(np.uint8)\n    return img"}
{"nl": "Alter the saturation of image randomly", "code": "def random_saturation(image):\n    image = np.array(image, dtype=np.float64)\n    random_scale = np.random.uniform(low=0.5, high=1.5)\n    image[:, :, 1] *= random_scale\n    image[image[:, :, 1] > 255] = 255\n    image = np.array(image, dtype=np.uint8)\n    return image"}
{"nl": "Alter the saturation of image randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    saturation = np.random.uniform(lower, upper)\n    image[:, :, 1] = image[:, :, 1] * saturation\n    image = cv2.cvtColor(image, cv2.COLOR_HSV2BGR)\n    return image"}
{"nl": "Alter the saturation of image randomly", "code": "def saturation(image):\n    saturation_factor = np.random.uniform(low=0.5, high=1.5)\n    image_HLS = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)\n    image_HLS[:, :, 1] = image_HLS[:, :, 1] * saturation_factor\n    image_RGB = cv2.cvtColor(image_HLS, cv2.COLOR_HLS2RGB)\n    return image_RGB"}
{"nl": "Alter the saturation of image randomly", "code": "def random_saturation(img, lower=0.5, upper=1.5):\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img = np.array(img, dtype=np.float32)\n    random_scale = np.random.uniform(lower, upper)\n    img[:, :, 1] = img[:, :, 1] * random_scale\n    img[:, :, 1][img[:, :, 1] > 255] = 255\n    img = np.array(img, dtype=np.uint8)\n    img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)\n    return img"}
{"nl": "Set the image saturation randomly", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Set the image saturation randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = tf.image.random_saturation(image, lower, upper)\n    return image"}
{"nl": "Set the image saturation randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    if not _is_numpy_image(image):\n        raise TypeError('Input image should be 3D array.')\n\n    saturation_factor = np.random.uniform(lower, upper)\n\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    hsv[:, :, 1] = hsv[:, :, 1] * saturation_factor\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Set the image saturation randomly", "code": "def randomize_saturation(image, lower=0.5, upper=1.5):\n    img = image.astype(np.float32)\n    img = img * np.random.uniform(lower, upper)\n    img = img.clip(0, 255).astype(np.uint8)\n    return img"}
{"nl": "Set the image saturation randomly", "code": "def random_saturation(image):\n    image = np.array(image, dtype=np.float64)\n    random_scale = np.random.uniform(low=0.5, high=1.5)\n    image[:, :, 1] *= random_scale\n    image[image[:, :, 1] > 255] = 255\n    image = np.array(image, dtype=np.uint8)\n    return image"}
{"nl": "Set the image saturation randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    saturation = np.random.uniform(lower, upper)\n    image[:, :, 1] = image[:, :, 1] * saturation\n    image = cv2.cvtColor(image, cv2.COLOR_HSV2BGR)\n    return image"}
{"nl": "Set the image saturation randomly", "code": "def saturation(image):\n    saturation_factor = np.random.uniform(low=0.5, high=1.5)\n    image_HLS = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)\n    image_HLS[:, :, 1] = image_HLS[:, :, 1] * saturation_factor\n    image_RGB = cv2.cvtColor(image_HLS, cv2.COLOR_HLS2RGB)\n    return image_RGB"}
{"nl": "Set the image saturation randomly", "code": "def random_saturation(img, lower=0.5, upper=1.5):\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img = np.array(img, dtype=np.float32)\n    random_scale = np.random.uniform(lower, upper)\n    img[:, :, 1] = img[:, :, 1] * random_scale\n    img[:, :, 1][img[:, :, 1] > 255] = 255\n    img = np.array(img, dtype=np.uint8)\n    img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)\n    return img"}
{"nl": "Set the saturation of image randomly", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Set the saturation of image randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = tf.image.random_saturation(image, lower, upper)\n    return image"}
{"nl": "Set the saturation of image randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    if not _is_numpy_image(image):\n        raise TypeError('Input image should be 3D array.')\n\n    saturation_factor = np.random.uniform(lower, upper)\n\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    hsv[:, :, 1] = hsv[:, :, 1] * saturation_factor\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Set the saturation of image randomly", "code": "def randomize_saturation(image, lower=0.5, upper=1.5):\n    img = image.astype(np.float32)\n    img = img * np.random.uniform(lower, upper)\n    img = img.clip(0, 255).astype(np.uint8)\n    return img"}
{"nl": "Set the saturation of image randomly", "code": "def random_saturation(image):\n    image = np.array(image, dtype=np.float64)\n    random_scale = np.random.uniform(low=0.5, high=1.5)\n    image[:, :, 1] *= random_scale\n    image[image[:, :, 1] > 255] = 255\n    image = np.array(image, dtype=np.uint8)\n    return image"}
{"nl": "Set the saturation of image randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    saturation = np.random.uniform(lower, upper)\n    image[:, :, 1] = image[:, :, 1] * saturation\n    image = cv2.cvtColor(image, cv2.COLOR_HSV2BGR)\n    return image"}
{"nl": "Set the saturation of image randomly", "code": "def saturation(image):\n    saturation_factor = np.random.uniform(low=0.5, high=1.5)\n    image_HLS = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)\n    image_HLS[:, :, 1] = image_HLS[:, :, 1] * saturation_factor\n    image_RGB = cv2.cvtColor(image_HLS, cv2.COLOR_HLS2RGB)\n    return image_RGB"}
{"nl": "Set the saturation of image randomly", "code": "def random_saturation(img, lower=0.5, upper=1.5):\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img = np.array(img, dtype=np.float32)\n    random_scale = np.random.uniform(lower, upper)\n    img[:, :, 1] = img[:, :, 1] * random_scale\n    img[:, :, 1][img[:, :, 1] > 255] = 255\n    img = np.array(img, dtype=np.uint8)\n    img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)\n    return img"}
{"nl": "Adjust the image saturation randomly", "code": "def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):\n    if np.random.random() < u:\n        x = random_channel_shift(image, np.random.uniform(lower, upper))\n        y = random_channel_shift(mask, np.random.uniform(lower, upper))\n    else:\n        x = image\n        y = mask\n    return x, y"}
{"nl": "Adjust the image saturation randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = tf.image.random_saturation(image, lower, upper)\n    return image"}
{"nl": "Adjust the image saturation randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    if not _is_numpy_image(image):\n        raise TypeError('Input image should be 3D array.')\n\n    saturation_factor = np.random.uniform(lower, upper)\n\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    hsv[:, :, 1] = hsv[:, :, 1] * saturation_factor\n    return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"}
{"nl": "Adjust the image saturation randomly", "code": "def randomize_saturation(image, lower=0.5, upper=1.5):\n    img = image.astype(np.float32)\n    img = img * np.random.uniform(lower, upper)\n    img = img.clip(0, 255).astype(np.uint8)\n    return img"}
{"nl": "Adjust the image saturation randomly", "code": "def random_saturation(image):\n    image = np.array(image, dtype=np.float64)\n    random_scale = np.random.uniform(low=0.5, high=1.5)\n    image[:, :, 1] *= random_scale\n    image[image[:, :, 1] > 255] = 255\n    image = np.array(image, dtype=np.uint8)\n    return image"}
{"nl": "Adjust the image saturation randomly", "code": "def random_saturation(image, lower=0.5, upper=1.5):\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    saturation = np.random.uniform(lower, upper)\n    image[:, :, 1] = image[:, :, 1] * saturation\n    image = cv2.cvtColor(image, cv2.COLOR_HSV2BGR)\n    return image"}
{"nl": "Adjust the image saturation randomly", "code": "def saturation(image):\n    saturation_factor = np.random.uniform(low=0.5, high=1.5)\n    image_HLS = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)\n    image_HLS[:, :, 1] = image_HLS[:, :, 1] * saturation_factor\n    image_RGB = cv2.cvtColor(image_HLS, cv2.COLOR_HLS2RGB)\n    return image_RGB"}
{"nl": "Adjust the image saturation randomly", "code": "def random_saturation(img, lower=0.5, upper=1.5):\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    img = np.array(img, dtype=np.float32)\n    random_scale = np.random.uniform(lower, upper)\n    img[:, :, 1] = img[:, :, 1] * random_scale\n    img[:, :, 1][img[:, :, 1] > 255] = 255\n    img = np.array(img, dtype=np.uint8)\n    img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)\n    return img"}
