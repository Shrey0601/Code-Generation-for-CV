{
    "resize an image": {"nl":"resize an image","code":"def resize(img, scale):   return cv2.resize(img, None, fx=scale, fy=scale, interpolation=cv2.INTER_CUBIC)"},
    "enlarge a picture to twice its size ": {"nl":"enlarge a picture to twice its size ","code":"def resize_image(img):   return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"},
    "enlarge an image to double its size ": {"nl":"enlarge an image to double its size ","code":"def resize_image(img):   return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"},
    "resize an image to double its shape": {"nl":"resize an image to double its shape","code":"def resize_image(img):   return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"},
    "resize a picture to twice its size ": {"nl":"resize a picture to twice its size ","code":"def resize_image(img):       # get the size of the image       (h,w) = img.shape[:2]\n       # define the output image       output = np.zeros((2*h,2*w), dtype = \"uint8\")\n       # for every pixel in the image       for i in range(0,h):               for j in range(0,w):                       # get the pixel value                       pixel = img[i,j]                       # assign the pixel value to 4 pixels in the output image                       output[2*i,2*j] = pixel                       output[2*i+1,2*j] = pixel                       output[2*i,2*j+1] = pixel                       output[2*i+1,2*j+1] = pixel\n       return output"},
    "twice the size of a picture ": {"nl":"twice the size of a picture ","code":"def resize_image(img):       # get the size of the image       (h,w) = img.shape[:2]\n       # define the output image       output = np.zeros((2*h,2*w), dtype = \"uint8\")\n       # for every pixel in the image       for i in range(0,h):               for j in range(0,w):                       # get the pixel value                       pixel = img[i,j]                       # assign the pixel value to 4 pixels in the output image                       output[2*i,2*j] = pixel                       output[2*i+1,2*j] = pixel                       output[2*i,2*j+1] = pixel                       output[2*i+1,2*j+1] = pixel\n       return output"},
    "To double an image's shape, enlarge it. ": {"nl":"To double an image's shape, enlarge it. ","code":"def resize_image(img):   return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"},
    "Double the size of a picture. ": {"nl":"Double the size of a picture. ","code":"def resize_image(img):       # get the size of the image       (h,w) = img.shape[:2]\n       # define the output image       output = np.zeros((2*h,2*w), dtype = \"uint8\")\n       # for every pixel in the image       for i in range(0,h):               for j in range(0,w):                       # get the pixel value                       pixel = img[i,j]                       # assign the pixel value to 4 pixels in the output image                       output[2*i,2*j] = pixel                       output[2*i+1,2*j] = pixel                       output[2*i,2*j+1] = pixel                       output[2*i+1,2*j+1] = pixel\n       return output"},
    "enlarge a photo so that it's twice as big. ": {"nl":"enlarge a photo so that it's twice as big. ","code":"def resize_image(img):       # get the size of the image       (h,w) = img.shape[:2]\n       # define the output image       output = np.zeros((2*h,2*w), dtype = \"uint8\")\n       # for every pixel in the image       for i in range(0,h):               for j in range(0,w):                       # get the pixel value                       pixel = img[i,j]                       # assign the pixel value to 4 pixels in the output image                       output[2*i,2*j] = pixel                       output[2*i+1,2*j] = pixel                       output[2*i,2*j+1] = pixel                       output[2*i+1,2*j+1] = pixel\n       return output"},
    "the photo will need to be resized to be twice as big.": {"nl":"the photo will need to be resized to be twice as big. ","code":"def resize_image(img):   return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"},
    "the photo will need to be resized to be twice as big.": {"nl":"the photo will need to be resized to be twice as big.  ","code":"def resize_image(image):      # enlarge an image to twice its size       return image.resize((image.size[0] * 2, image.size[1] * 2))"},
    "the photo will need to be resized to be twice as big.": {"nl":"the photo will need to be resized to be twice as big.","code":"def resize_image(img):       # get the size of the image       (h,w) = img.shape[:2]\n       # define the output image       output = np.zeros((2*h,2*w), dtype = \"uint8\")\n       # for every pixel in the image       for i in range(0,h):               for j in range(0,w):                       # get the pixel value                       pixel = img[i,j]                       # assign the pixel value to 4 pixels in the output image                       output[2*i,2*j] = pixel                       output[2*i+1,2*j] = pixel                       output[2*i,2*j+1] = pixel                       output[2*i+1,2*j+1] = pixel\n       return output "},
    "2x the initial image shape": {"nl":"2x the initial image shape","code":"def resize_image(img):       # get the size of the image       (h,w) = img.shape[:2]\n       # define the output image       output = np.zeros((2*h,2*w), dtype = \"uint8\")\n       # for every pixel in the image       for i in range(0,h):               for j in range(0,w):                       # get the pixel value                       pixel = img[i,j]                       # assign the pixel value to 4 pixels in the output image                       output[2*i,2*j] = pixel                       output[2*i+1,2*j] = pixel                       output[2*i,2*j+1] = pixel                       output[2*i+1,2*j+1] = pixel\n       return output "},
    "the picture will need to be resized to be twice as large. ": {"nl":"the picture will need to be resized to be twice as large. ","code":"def resize_image(img):       # get the size of the image       (h,w) = img.shape[:2]\n       # define the output image       output = np.zeros((2*h,2*w), dtype = \"uint8\")\n       # for every pixel in the image       for i in range(0,h):               for j in range(0,w):                       # get the pixel value                       pixel = img[i,j]                       # assign the pixel value to 4 pixels in the output image                       output[2*i,2*j] = pixel                       output[2*i+1,2*j] = pixel                       output[2*i,2*j+1] = pixel                       output[2*i+1,2*j+1] = pixel\n       return output "},
    "Double the size of a photograph ": {"nl":"Double the size of a photograph ","code":"def resize_image(img):       # get the size of the image       (h,w) = img.shape[:2]\n       # define the output image       output = np.zeros((2*h,2*w), dtype = \"uint8\")\n       # for every pixel in the image       for i in range(0,h):               for j in range(0,w):                       # get the pixel value                       pixel = img[i,j]                       # assign the pixel value to 4 pixels in the output image                       output[2*i,2*j] = pixel                       output[2*i+1,2*j] = pixel                       output[2*i,2*j+1] = pixel                       output[2*i+1,2*j+1] = pixel\n       return output "},
    "enlarge an image to twice its size ": {"nl":"enlarge an image to twice its size ","code":"def resize_image(img):       # get the size of the image       (h,w) = img.shape[:2]\n       # define the output image       output = np.zeros((2*h,2*w), dtype = \"uint8\")\n       # for every pixel in the image       for i in range(0,h):               for j in range(0,w):                       # get the pixel value                       pixel = img[i,j]                       # assign the pixel value to 4 pixels in the output image                       output[2*i,2*j] = pixel                       output[2*i+1,2*j] = pixel                       output[2*i,2*j+1] = pixel                       output[2*i+1,2*j+1] = pixel\n       return output "},
    "enlarge a photograph to twice its size ": {"nl":"enlarge a photograph to twice its size ","code":"def resize_image(img):       # get the size of the image       (h,w) = img.shape[:2]\n       # define the output image       output = np.zeros((2*h,2*w), dtype = \"uint8\")\n       # for every pixel in the image       for i in range(0,h):               for j in range(0,w):                       # get the pixel value                       pixel = img[i,j]                       # assign the pixel value to 4 pixels in the output image                       output[2*i,2*j] = pixel                       output[2*i+1,2*j] = pixel                       output[2*i,2*j+1] = pixel                       output[2*i+1,2*j+1] = pixel\n       return output "},
    "photo doubled ": {"nl":"photo doubled ","code":"def resize_image(img):       # get the size of the image       (h,w) = img.shape[:2]\n       # define the output image       output = np.zeros((2*h,2*w), dtype = \"uint8\")\n       # for every pixel in the image       for i in range(0,h):               for j in range(0,w):                       # get the pixel value                       pixel = img[i,j]                       # assign the pixel value to 4 pixels in the output image                       output[2*i,2*j] = pixel                       output[2*i+1,2*j] = pixel                       output[2*i,2*j+1] = pixel                       output[2*i+1,2*j+1] = pixel\n       return output "},
    "resize an image to 4 times its shape": {"nl":"resize an image to 4 times its shape","code":"def resize_image(image):   # img = misc.imread(filename)   h = img.shape[0]   w = img.shape[1]   # print(img.shape)   img_new = np.zeros((h*2, w*2, 3))   new_h = img_new.shape[0]   new_w = img_new.shape[1]   # print(img_new.shape)   for i in range(new_h):       for j in range(new_w):           x = int(i / 2)           y = int(j / 2)           if i % 2 == 0 and j % 2 == 0:               img_new[i][j] = img[x][y]           elif i % 2 == 0 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x][y+1]) / 2           elif i % 2 == 1 and j % 2 == 0:               img_new[i][j] = (img[x][y] + img[x+1][y]) / 2           elif i % 2 == 1 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4   # misc.imsave(out_filename, img_new)   return img_new"},
    "Four times the size of a picture ": {"nl":"Four times the size of a picture ","code":"def resize_image(image):   image = cv2.resize(image, (0,0), fx=4, fy=4)   return image"},
    "picture resizing to 4 times its original size ": {"nl":"picture resizing to 4 times its original size ","code":"def resize_image(image):   image = cv2.resize(image, (0,0), fx=4, fy=4)   return image"},
    "4 times the original picture size ": {"nl":"4 times the original picture size ","code":"def resize_image(image):   image = cv2.resize(image, (0,0), fx=4, fy=4)   return image"},
    "enlarge a picture to four times its original size. ": {"nl":"enlarge a picture to four times its original size. ","code":"def resize_image(image):   image = cv2.resize(image, (0,0), fx=4, fy=4)   return image"},
    "enlarge a photograph to four times its original size ": {"nl":"enlarge a photograph to four times its original size ","code":"def resize_image(image):   # img = misc.imread(filename)   h = img.shape[0]   w = img.shape[1]   # print(img.shape)   img_new = np.zeros((h*2, w*2, 3))   new_h = img_new.shape[0]   new_w = img_new.shape[1]   # print(img_new.shape)   for i in range(new_h):       for j in range(new_w):           x = int(i / 2)           y = int(j / 2)           if i % 2 == 0 and j % 2 == 0:               img_new[i][j] = img[x][y]           elif i % 2 == 0 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x][y+1]) / 2           elif i % 2 == 1 and j % 2 == 0:               img_new[i][j] = (img[x][y] + img[x+1][y]) / 2           elif i % 2 == 1 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4   # misc.imsave(out_filename, img_new)   return img_new"},
    "Increase the size of an image to four times its current shape. ": {"nl":"Increase the size of an image to four times its current shape. ","code":"def resize_image(image):   # img = misc.imread(filename)   h = img.shape[0]   w = img.shape[1]   # print(img.shape)   img_new = np.zeros((h*2, w*2, 3))   new_h = img_new.shape[0]   new_w = img_new.shape[1]   # print(img_new.shape)   for i in range(new_h):       for j in range(new_w):           x = int(i / 2)           y = int(j / 2)           if i % 2 == 0 and j % 2 == 0:               img_new[i][j] = img[x][y]           elif i % 2 == 0 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x][y+1]) / 2           elif i % 2 == 1 and j % 2 == 0:               img_new[i][j] = (img[x][y] + img[x+1][y]) / 2           elif i % 2 == 1 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4   # misc.imsave(out_filename, img_new)   return img_new"},
    "resize an image to be four times its original shape. ": {"nl":"resize an image to be four times its original shape. ","code":"def resize_image(image):   # img = misc.imread(filename)   h = img.shape[0]   w = img.shape[1]   # print(img.shape)   img_new = np.zeros((h*2, w*2, 3))   new_h = img_new.shape[0]   new_w = img_new.shape[1]   # print(img_new.shape)   for i in range(new_h):       for j in range(new_w):           x = int(i / 2)           y = int(j / 2)           if i % 2 == 0 and j % 2 == 0:               img_new[i][j] = img[x][y]           elif i % 2 == 0 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x][y+1]) / 2           elif i % 2 == 1 and j % 2 == 0:               img_new[i][j] = (img[x][y] + img[x+1][y]) / 2           elif i % 2 == 1 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4   # misc.imsave(out_filename, img_new)   return img_new"},
    "Adjust the size of an image so that it is four times its original shape. ": {"nl":"Adjust the size of an image so that it is four times its original shape. ","code":"def resize_image(image):   # img = misc.imread(filename)   h = img.shape[0]   w = img.shape[1]   # print(img.shape)   img_new = np.zeros((h*2, w*2, 3))   new_h = img_new.shape[0]   new_w = img_new.shape[1]   # print(img_new.shape)   for i in range(new_h):       for j in range(new_w):           x = int(i / 2)           y = int(j / 2)           if i % 2 == 0 and j % 2 == 0:               img_new[i][j] = img[x][y]           elif i % 2 == 0 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x][y+1]) / 2           elif i % 2 == 1 and j % 2 == 0:               img_new[i][j] = (img[x][y] + img[x+1][y]) / 2           elif i % 2 == 1 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4   # misc.imsave(out_filename, img_new)   return img_new"},
    "image scaled up to four times its original shape ": {"nl":"image scaled up to four times its original shape ","code":"def resize_image(image):   # img = misc.imread(filename)   h = img.shape[0]   w = img.shape[1]   # print(img.shape)   img_new = np.zeros((h*2, w*2, 3))   new_h = img_new.shape[0]   new_w = img_new.shape[1]   # print(img_new.shape)   for i in range(new_h):       for j in range(new_w):           x = int(i / 2)           y = int(j / 2)           if i % 2 == 0 and j % 2 == 0:               img_new[i][j] = img[x][y]           elif i % 2 == 0 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x][y+1]) / 2           elif i % 2 == 1 and j % 2 == 0:               img_new[i][j] = (img[x][y] + img[x+1][y]) / 2           elif i % 2 == 1 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4   # misc.imsave(out_filename, img_new)   return img_new"},
    "fourfold the size of an image's shape ": {"nl":"fourfold the size of an image's shape ","code":"def resize_image(image):   # img = misc.imread(filename)   h = img.shape[0]   w = img.shape[1]   # print(img.shape)   img_new = np.zeros((h*2, w*2, 3))   new_h = img_new.shape[0]   new_w = img_new.shape[1]   # print(img_new.shape)   for i in range(new_h):       for j in range(new_w):           x = int(i / 2)           y = int(j / 2)           if i % 2 == 0 and j % 2 == 0:               img_new[i][j] = img[x][y]           elif i % 2 == 0 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x][y+1]) / 2           elif i % 2 == 1 and j % 2 == 0:               img_new[i][j] = (img[x][y] + img[x+1][y]) / 2           elif i % 2 == 1 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4   # misc.imsave(out_filename, img_new)   return img_new"},
    "enlarge an image fourfold its shape ": {"nl":"enlarge an image fourfold its shape ","code":"def resize_image(image):   # img = misc.imread(filename)   h = img.shape[0]   w = img.shape[1]   # print(img.shape)   img_new = np.zeros((h*2, w*2, 3))   new_h = img_new.shape[0]   new_w = img_new.shape[1]   # print(img_new.shape)   for i in range(new_h):       for j in range(new_w):           x = int(i / 2)           y = int(j / 2)           if i % 2 == 0 and j % 2 == 0:               img_new[i][j] = img[x][y]           elif i % 2 == 0 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x][y+1]) / 2           elif i % 2 == 1 and j % 2 == 0:               img_new[i][j] = (img[x][y] + img[x+1][y]) / 2           elif i % 2 == 1 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4   # misc.imsave(out_filename, img_new)   return img_new"},
    "image resizing to four times the original size ": {"nl":"image resizing to four times the original size ","code":"def resize_image(image):   # img = misc.imread(filename)   h = img.shape[0]   w = img.shape[1]   # print(img.shape)   img_new = np.zeros((h*2, w*2, 3))   new_h = img_new.shape[0]   new_w = img_new.shape[1]   # print(img_new.shape)   for i in range(new_h):       for j in range(new_w):           x = int(i / 2)           y = int(j / 2)           if i % 2 == 0 and j % 2 == 0:               img_new[i][j] = img[x][y]           elif i % 2 == 0 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x][y+1]) / 2           elif i % 2 == 1 and j % 2 == 0:               img_new[i][j] = (img[x][y] + img[x+1][y]) / 2           elif i % 2 == 1 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4   # misc.imsave(out_filename, img_new)   return img_new"},
    "4x image size ": {"nl":"4x image size ","code":"def resize_image(image):   # img = misc.imread(filename)   h = img.shape[0]   w = img.shape[1]   # print(img.shape)   img_new = np.zeros((h*2, w*2, 3))   new_h = img_new.shape[0]   new_w = img_new.shape[1]   # print(img_new.shape)   for i in range(new_h):       for j in range(new_w):           x = int(i / 2)           y = int(j / 2)           if i % 2 == 0 and j % 2 == 0:               img_new[i][j] = img[x][y]           elif i % 2 == 0 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x][y+1]) / 2           elif i % 2 == 1 and j % 2 == 0:               img_new[i][j] = (img[x][y] + img[x+1][y]) / 2           elif i % 2 == 1 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4   # misc.imsave(out_filename, img_new)   return img_new"},
    "enlarge an image by 4 ": {"nl":"enlarge an image by 4 ","code":"def resize_image(image):   # img = misc.imread(filename)   h = img.shape[0]   w = img.shape[1]   # print(img.shape)   img_new = np.zeros((h*2, w*2, 3))   new_h = img_new.shape[0]   new_w = img_new.shape[1]   # print(img_new.shape)   for i in range(new_h):       for j in range(new_w):           x = int(i / 2)           y = int(j / 2)           if i % 2 == 0 and j % 2 == 0:               img_new[i][j] = img[x][y]           elif i % 2 == 0 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x][y+1]) / 2           elif i % 2 == 1 and j % 2 == 0:               img_new[i][j] = (img[x][y] + img[x+1][y]) / 2           elif i % 2 == 1 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4   # misc.imsave(out_filename, img_new)   return img_new"},
    "4x an image's size ": {"nl":"4x an image's size ","code":"def resize_image(image):   # img = misc.imread(filename)   h = img.shape[0]   w = img.shape[1]   # print(img.shape)   img_new = np.zeros((h*2, w*2, 3))   new_h = img_new.shape[0]   new_w = img_new.shape[1]   # print(img_new.shape)   for i in range(new_h):       for j in range(new_w):           x = int(i / 2)           y = int(j / 2)           if i % 2 == 0 and j % 2 == 0:               img_new[i][j] = img[x][y]           elif i % 2 == 0 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x][y+1]) / 2           elif i % 2 == 1 and j % 2 == 0:               img_new[i][j] = (img[x][y] + img[x+1][y]) / 2           elif i % 2 == 1 and j % 2 == 1:               img_new[i][j] = (img[x][y] + img[x+1][y] + img[x][y+1] + img[x+1][y+1]) / 4   # misc.imsave(out_filename, img_new)   return img_new"},
    "combine two images by adding them": {"nl":"combine two images by adding them","code":"def combine_images(img1, img2):   return cv2.add(img1, img2)"},
    "join two photos together by adding them ": {"nl":"join two photos together by adding them ","code":"def combine_images(img1, img2):   return cv2.add(img1, img2)"},
    "simply adding them, merge two photos. ": {"nl":"simply adding them, merge two photos. ","code":"def combine_images(img1, img2):   return cv2.add(img1, img2)"},
    "merge two photos by adding them ": {"nl":"merge two photos by adding them ","code":"def combine_images(img1, img2):   return cv2.add(img1, img2)"},
    "simply combining two photos together ": {"nl":"simply combining two photos together ","code":"def combine_images(img1, img2):   return cv2.add(img1, img2)"},
    "add the two pictures together. ": {"nl":"add the two pictures together. ","code":"def combine_images(img1, img2):   return cv2.add(img1, img2)"},
    "Add the two pictures together to create a new one. ": {"nl":"Add the two pictures together to create a new one. ","code":"def combine_images(img1, img2):   return cv2.add(img1, img2)"},
    "Add the two pictures together to create one composite. ": {"nl":"Add the two pictures together to create one composite. ","code":"def combine_images(img1, img2):   return cv2.add(img1, img2)"},
    "Add two photos. ": {"nl":"Add two photos. ","code":"def combine_images(img1, img2):   return cv2.add(img1, img2)"},
    "add two images ": {"nl":"add two images ","code":"def combine_images(img1, img2):   return cv2.add(img1, img2)"},
    "merge two pictures by combining them. ": {"nl":"merge two pictures by combining them. ","code":"def combine_images(img1, img2):   return cv2.add(img1, img2)"},
    "combine two pictures by adding them. ": {"nl":"combine two pictures by adding them. ","code":"def combine_images(img1, img2):   return cv2.add(img1, img2)"},
    "blur the image ": {"nl":"blur the image ","code":"def blur_img(img, blur_size):   # bluring image   tmp_img = img.astype(np.float32)   tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)   tmp_img = np.clip(tmp_img, 0, 255)   res = tmp_img.astype(np.uint8)\n   return res"},
    "picture blur ": {"nl":"picture blur ","code":"def blur_img(img, blur_size):   # bluring image   tmp_img = img.astype(np.float32)   tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)   tmp_img = np.clip(tmp_img, 0, 255)   res = tmp_img.astype(np.uint8)\n   return res"},
    "image blur ": {"nl":"image blur ","code":"def blur_img(img, blur_size):   # bluring image   tmp_img = img.astype(np.float32)   tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)   tmp_img = np.clip(tmp_img, 0, 255)   res = tmp_img.astype(np.uint8)\n   return res"},
    "muddy up the picture": {"nl":"muddy up the picture","code":"def blur_img(img, blur_size):   # bluring image   tmp_img = img.astype(np.float32)   tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)   tmp_img = np.clip(tmp_img, 0, 255)   res = tmp_img.astype(np.uint8)\n   return res"},
    "distort the picture in some way": {"nl":"distort the picture in some way","code":"def blur_img(img, blur_size):   # bluring image   tmp_img = img.astype(np.float32)   tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)   tmp_img = np.clip(tmp_img, 0, 255)   res = tmp_img.astype(np.uint8)\n   return res"},
    "pixelize ": {"nl":"pixelize ","code":"def blur_img(img, blur_size):   # bluring image   tmp_img = img.astype(np.float32)   tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)   tmp_img = np.clip(tmp_img, 0, 255)   res = tmp_img.astype(np.uint8)\n   return res"},
    "blur picture ": {"nl":"blur picture ","code":"def blur_img(img, blur_size):   # bluring image   tmp_img = img.astype(np.float32)   tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)   tmp_img = np.clip(tmp_img, 0, 255)   res = tmp_img.astype(np.uint8)\n   return res"},
    "Blur the image ": {"nl":"Blur the image ","code":"def blur_img(img, blur_size):   # bluring image   tmp_img = img.astype(np.float32)   tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)   tmp_img = np.clip(tmp_img, 0, 255)   res = tmp_img.astype(np.uint8)\n   return res"},
    "pixelate the picture": {"nl":"pixelate the picture","code":"def blur_img(img, blur_size):   # bluring image   tmp_img = img.astype(np.float32)   tmp_img = cv2.GaussianBlur(tmp_img, (blur_size, blur_size), 0)   tmp_img = np.clip(tmp_img, 0, 255)   res = tmp_img.astype(np.uint8)\n   return res"},
    "increase the brightness and contrast of the image": {"nl":"increase the brightness and contrast of the image","code":"def brightness_contrast(img):   alpha = 2.0 # Simple contrast control [1.0 - 3.0]   beta = 50    # Simple brightness control [0-100]   return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"},
    "increase the image's brightness and contrast ": {"nl":"increase the image's brightness and contrast ","code":"def brightness_contrast(img):   alpha = 2.0 # Simple contrast control [1.0 - 3.0]   beta = 50    # Simple brightness control [0-100]   return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"},
    "enhance the image's brightness and contrast ": {"nl":"enhance the image's brightness and contrast ","code":"def brightness_contrast(img):   alpha = 2.0 # Simple contrast control [1.0 - 3.0]   beta = 50    # Simple brightness control [0-100]   return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"},
    "Boost the image's contrast and brightness ": {"nl":"Boost the image's contrast and brightness ","code":"def brightness_contrast(img):   alpha = 2.0 # Simple contrast control [1.0 - 3.0]   beta = 50    # Simple brightness control [0-100]   return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"},
    "boost the brightness and contrast of the picture ": {"nl":"boost the brightness and contrast of the picture ","code":"def brightness_contrast(img):   alpha = 2.0 # Simple contrast control [1.0 - 3.0]   beta = 50    # Simple brightness control [0-100]   return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"},
    "improve the image's brightness and contrast ": {"nl":"improve the image's brightness and contrast ","code":"def brightness_contrast(img):   alpha = 2.0 # Simple contrast control [1.0 - 3.0]   beta = 50    # Simple brightness control [0-100]   return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"},
    "brighten and contrast up the picture ": {"nl":"brighten and contrast up the picture ","code":"def brightness_contrast(img):   alpha = 2.0 # Simple contrast control [1.0 - 3.0]   beta = 50    # Simple brightness control [0-100]   return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"},
    "Brightness and contrast should be increased in the picture. ": {"nl":"Brightness and contrast should be increased in the picture. ","code":"def brightness_contrast(img):   alpha = 2.0 # Simple contrast control [1.0 - 3.0]   beta = 50    # Simple brightness control [0-100]   return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"},
    "the brightness and contrast of the image need to be increased. ": {"nl":"the brightness and contrast of the image need to be increased. ","code":"def brightness_contrast(img):   alpha = 2.0 # Simple contrast control [1.0 - 3.0]   beta = 50    # Simple brightness control [0-100]   return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"},
    "Boost the intensity of the image's brightness and contrast. ": {"nl":"Boost the intensity of the image's brightness and contrast. ","code":"def brightness_contrast(img):   alpha = 2.0 # Simple contrast control [1.0 - 3.0]   beta = 50    # Simple brightness control [0-100]   return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"},
    "Boost image brightness and contrast ": {"nl":"Boost image brightness and contrast ","code":"def brightness_contrast(img):   alpha = 2.0 # Simple contrast control [1.0 - 3.0]   beta = 50    # Simple brightness control [0-100]   return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"},
    "brighten and contrast the photo ": {"nl":"brighten and contrast the photo ","code":"def brightness_contrast(img):   alpha = 2.0 # Simple contrast control [1.0 - 3.0]   beta = 50    # Simple brightness control [0-100]   return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"},
    "Brighten and contrast the image ": {"nl":"Brighten and contrast the image ","code":"def brightness_contrast(img):   alpha = 2.0 # Simple contrast control [1.0 - 3.0]   beta = 50    # Simple brightness control [0-100]   return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"},
    "boost image brightness and contrast ": {"nl":"boost image brightness and contrast ","code":"def brightness_contrast(img):   alpha = 2.0 # Simple contrast control [1.0 - 3.0]   beta = 50    # Simple brightness control [0-100]   return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"},
    "add contrast and brightness to the image ": {"nl":"add contrast and brightness to the image ","code":"def brightness_contrast(img):   alpha = 2.0 # Simple contrast control [1.0 - 3.0]   beta = 50    # Simple brightness control [0-100]   return cv2.convertScaleAbs(img, alpha=alpha, beta=beta)"},
    "enlarge a picture to double its size ": {"nl":"enlarge a picture to double its size ","code":"def resize_image(img):   return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"},
    "Double the size of an image. ": {"nl":"Double the size of an image. ","code":"def resize_image(img):   return cv2.resize(img, (2*img.shape[1], 2*img.shape[0]), interpolation=cv2.INTER_CUBIC)"},
    "split the channels of a color image": {"nl":"split the channels of a color image","code":"def split_channels(image):      #Helper code to split an image into its colour channels.      return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "separate a colour image's channels ": {"nl":"separate a colour image's channels ","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "the division of a colour image's channels ": {"nl":"the division of a colour image's channels ","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "Dividing a colour image's channels ": {"nl":"Dividing a colour image's channels ","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "divide the channels in a colour picture ": {"nl":"divide the channels in a colour picture ","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "colour picture channel division ": {"nl":"colour picture channel division ","code":"def split_channels(image):      #Helper code to split an image into its colour channels.      return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "colour picture channel separation ": {"nl":"colour picture channel separation ","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "the colour image was separated into its individual channels. ": {"nl":"the colour image was separated into its individual channels. ","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "separation of the colour channels in a picture": {"nl":"separation of the colour channels in a picture","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "the colour image was segmented into its individual channels": {"nl":"the colour image was segmented into its individual channels","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "separating colour channels": {"nl":"separating colour channels","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "Image channels are separated ": {"nl":"Image channels are separated ","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "divide image channels ": {"nl":"divide image channels ","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "Channelize a colour picture ": {"nl":"Channelize a colour picture ","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "Separate the colour channels of a picture ": {"nl":"Separate the colour channels of a picture ","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "separating a colour image's channels ": {"nl":"separating a colour image's channels ","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "Channelize an image's colour channels ": {"nl":"Channelize an image's colour channels ","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "separating the colour channels of an image ": {"nl":"separating the colour channels of an image ","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "split a colour image into its individual colour channels. ": {"nl":"split a colour image into its individual colour channels. ","code":"def split_channels(image):   \"\"\"   Helper code to split an image into its colour channels.   \"\"\"   return image[:, :, 0], image[:, :, 1], image[:, :, 2]"},
    "create a mask for a color range": {"nl":"create a mask for a color range","code":"def mask_color_range(image, lower_color, upper_color):\n   lower = np.array(lower_color, dtype = \"uint8\")   upper = np.array(upper_color, dtype = \"uint8\")   mask = cv2.inRange(image, lower, upper)   output = cv2.bitwise_and(image, image, mask = mask)\n\n"},
    "make a mask for a set of colors": {"nl":"make a mask for a set of colors","code":"def mask_color_range(image, lower_color, upper_color):\n   lower = np.array(lower_color, dtype = \"uint8\")   upper = np.array(upper_color, dtype = \"uint8\")   mask = cv2.inRange(image, lower, upper)   output = cv2.bitwise_and(image, image, mask = mask)\n\n"},
    "make a mask for a certain colour range": {"nl":"make a mask for a certain colour range","code":"def mask_color_range(image, lower_color, upper_color):\n   lower = np.array(lower_color, dtype = \"uint8\")   upper = np.array(upper_color, dtype = \"uint8\")   mask = cv2.inRange(image, lower, upper)   output = cv2.bitwise_and(image, image, mask = mask)\n\n"},
    "construct a mask for a set of colours ": {"nl":"construct a mask for a set of colours ","code":"def mask_color_range(image, lower_color, upper_color):\n   lower = np.array(lower_color, dtype = \"uint8\")   upper = np.array(upper_color, dtype = \"uint8\")   mask = cv2.inRange(image, lower, upper)   output = cv2.bitwise_and(image, image, mask = mask)\n\n"},
    "Make a mask for the colour range you want to work with": {"nl":"Make a mask for the colour range you want to work with","code":"def mask_color_range(image, lower_color, upper_color):\n   lower = np.array(lower_color, dtype = \"uint8\")   upper = np.array(upper_color, dtype = \"uint8\")   mask = cv2.inRange(image, lower, upper)   output = cv2.bitwise_and(image, image, mask = mask)\n\n"},
    "Make a mask for a specific colour range": {"nl":"Make a mask for a specific colour range","code":"def mask_color_range(image, lower_color, upper_color):\n   lower = np.array(lower_color, dtype = \"uint8\")   upper = np.array(upper_color, dtype = \"uint8\")   mask = cv2.inRange(image, lower, upper)   output = cv2.bitwise_and(image, image, mask = mask)\n\n"},
    "Make a mask for a specific colour spectrum": {"nl":"Make a mask for a specific colour spectrum","code":"def mask_color_range(image, lower_color, upper_color):\n   lower = np.array(lower_color, dtype = \"uint8\")   upper = np.array(upper_color, dtype = \"uint8\")   mask = cv2.inRange(image, lower, upper)   output = cv2.bitwise_and(image, image, mask = mask)\n\n"},
    "Color range mask ": {"nl":"Color range mask ","code":"def mask_color_range(image, lower_color, upper_color):\n   lower = np.array(lower_color, dtype = \"uint8\")   upper = np.array(upper_color, dtype = \"uint8\")   mask = cv2.inRange(image, lower, upper)   output = cv2.bitwise_and(image, image, mask = mask)\n\n"},
    "Mask a colour range ": {"nl":"Mask a colour range ","code":"def mask_color_range(image, lower_color, upper_color):\n   lower = np.array(lower_color, dtype = \"uint8\")   upper = np.array(upper_color, dtype = \"uint8\")   mask = cv2.inRange(image, lower, upper)   output = cv2.bitwise_and(image, image, mask = mask)\n\n"},
    "Create a mask for a colour range ": {"nl":"Create a mask for a colour range ","code":"def mask_color_range(image, lower_color, upper_color):\n   lower = np.array(lower_color, dtype = \"uint8\")   upper = np.array(upper_color, dtype = \"uint8\")   mask = cv2.inRange(image, lower, upper)   output = cv2.bitwise_and(image, image, mask = mask)\n\n"},
    "make a mask for a range of colours ": {"nl":"make a mask for a range of colours ","code":"def mask_color_range(image, lower_color, upper_color):\n   lower = np.array(lower_color, dtype = \"uint8\")   upper = np.array(upper_color, dtype = \"uint8\")   mask = cv2.inRange(image, lower, upper)   output = cv2.bitwise_and(image, image, mask = mask)\n\n"},
    "find all contours and the areas of those contours": {"nl":"find all contours and the areas of those contours","code":"def find_contours(img):   imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(imgray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, 1, 2)   areas = [cv2.contourArea(c) for c in contours]   return contours, areas"},
    "Identify all contours and their corresponding areas. ": {"nl":"Identify all contours and their corresponding areas. ","code":"def find_contours(img):   imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(imgray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, 1, 2)   areas = [cv2.contourArea(c) for c in contours]   return contours, areas"},
    "discover all of the contours and their corresponding areas. ": {"nl":"discover all of the contours and their corresponding areas. ","code":"def find_contours(img):   imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(imgray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, 1, 2)   areas = [cv2.contourArea(c) for c in contours]   return contours, areas"},
    "discover every contour and its corresponding areas. ": {"nl":"discover every contour and its corresponding areas. ","code":"def find_contours(img):   imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(imgray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, 1, 2)   areas = [cv2.contourArea(c) for c in contours]   return contours, areas"},
    "discover all curves and the spaces occupied by those contours ": {"nl":"discover all curves and the spaces occupied by those contours ","code":"def find_contours(img):   imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(imgray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, 1, 2)   areas = [cv2.contourArea(c) for c in contours]   return contours, areas"},
    "locate all contours and their areas ": {"nl":"locate all contours and their areas ","code":"def find_contours(img):   imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(imgray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, 1, 2)   areas = [cv2.contourArea(c) for c in contours]   return contours, areas"},
    "locate all curves and their respective areas. ": {"nl":"locate all curves and their respective areas. ","code":"def find_contours(img):   imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(imgray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, 1, 2)   areas = [cv2.contourArea(c) for c in contours]   return contours, areas"},
    "locate all contours and the areas of those contours. ": {"nl":"locate all contours and the areas of those contours. ","code":"def find_contours(img):   imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(imgray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, 1, 2)   areas = [cv2.contourArea(c) for c in contours]   return contours, areas"},
    "locate all contours and their corresponding areas. ": {"nl":"locate all contours and their corresponding areas. ","code":"def find_contours(img):   imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(imgray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, 1, 2)   areas = [cv2.contourArea(c) for c in contours]   return contours, areas"},
    "find all of the contours and their areas. ": {"nl":"find all of the contours and their areas. ","code":"def find_contours(img):   imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(imgray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, 1, 2)   areas = [cv2.contourArea(c) for c in contours]   return contours, areas"},
    "find all contours and the areas of each contour. ": {"nl":"find all contours and the areas of each contour. ","code":"def find_contours(img):   imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(imgray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, 1, 2)   areas = [cv2.contourArea(c) for c in contours]   return contours, areas"},
    "get a list of all curves and their respective areas ": {"nl":"get a list of all curves and their respective areas ","code":"def find_contours(img):   imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(imgray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, 1, 2)   areas = [cv2.contourArea(c) for c in contours]   return contours, areas"},
    "contours and their respective areas must be discovered and recorded": {"nl":"contours and their respective areas must be discovered and recorded","code":"def find_contours(img):   imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(imgray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, 1, 2)   areas = [cv2.contourArea(c) for c in contours]   return contours, areas"},
    "locate all of the contours and the areas corresponding to those contours": {"nl":"locate all of the contours and the areas corresponding to those contours","code":"def find_contours(img):   imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(imgray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, 1, 2)   areas = [cv2.contourArea(c) for c in contours]   return contours, areas"},
    "locate all of the contours as well as the areas corresponding to those contours. ": {"nl":"locate all of the contours as well as the areas corresponding to those contours. ","code":"def find_contours(img):   imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(imgray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, 1, 2)   areas = [cv2.contourArea(c) for c in contours]   return contours, areas"},
    "draw all contours on the original image": {"nl":"draw all contours on the original image","code":"def draw_contours(img, contours):   img = img.copy()   cv2.drawContours(img, contours, -1, (0, 255, 0), 3)   return img"},
    "on the source image, draw every contour ": {"nl":"on the source image, draw every contour ","code":"def draw_contours(img, contours):   img = img.copy()   cv2.drawContours(img, contours, -1, (0, 255, 0), 3)   return img"},
    "tracing every contour on the original image ": {"nl":"tracing every contour on the original image ","code":"def draw_contours(img, contours):   img = img.copy()   cv2.drawContours(img, contours, -1, (0, 255, 0), 3)   return img"},
    "on the original image, draw every contour": {"nl":"on the original image, draw every contour","code":"def draw_contours(img, contours):   img = img.copy()   cv2.drawContours(img, contours, -1, (0, 255, 0), 3)   return img"},
    "draw all contours on the original image, but with a specific color": {"nl":"draw all contours on the original image, but with a specific color","code":"def draw_contours_with_colors(img, contours):   img = img.copy()   for c in contours:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.drawContours(img, [c], -1, color, 2)   return img"},
    "the original image's outlines should all be drawn in a specified hue.": {"nl":"the original image's outlines should all be drawn in a specified hue.","code":"def draw_contours_with_colors(img, contours):   img = img.copy()   for c in contours:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.drawContours(img, [c], -1, color, 2)   return img"},
    "Draw each contour on the original image using a certain colour": {"nl":"Draw each contour on the original image using a certain colour","code":"def draw_contours_with_colors(img, contours):   img = img.copy()   for c in contours:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.drawContours(img, [c], -1, color, 2)   return img"},
    "Using a certain colour, trace every contour on the source image": {"nl":"Using a certain colour, trace every contour on the source image","code":"def draw_contours_with_colors(img, contours):   img = img.copy()   for c in contours:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.drawContours(img, [c], -1, color, 2)   return img"},
    "Draw every contour on the original image, but use a particular colour": {"nl":"Draw every contour on the original image, but use a particular colour","code":"def draw_contours_with_colors(img, contours):   img = img.copy()   for c in contours:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.drawContours(img, [c], -1, color, 2)   return img"},
    "Using a specified colour, draw all outlines on the source image": {"nl":"Using a specified colour, draw all outlines on the source image","code":"def draw_contours_with_colors(img, contours):   img = img.copy()   for c in contours:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.drawContours(img, [c], -1, color, 2)   return img"},
    "All contours on the source image should be drawn in a specified colour": {"nl":"All contours on the source image should be drawn in a specified colour","code":"def draw_contours_with_colors(img, contours):   img = img.copy()   for c in contours:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.drawContours(img, [c], -1, color, 2)   return img"},
    "Draw all outlines on the original image, but with a certain hue": {"nl":"Draw all outlines on the original image, but with a certain hue","code":"def draw_contours_with_colors(img, contours):   img = img.copy()   for c in contours:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.drawContours(img, [c], -1, color, 2)   return img"},
    "draw all contours on the original image, but with a particular hue.": {"nl":"draw all contours on the original image, but with a particular hue.","code":"def draw_contours_with_colors(img, contours):   img = img.copy()   for c in contours:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.drawContours(img, [c], -1, color, 2)   return img"},
    "Create all of the contours on the initial image, but do so using a particular colour. ": {"nl":"Create all of the contours on the initial image, but do so using a particular colour. ","code":"def draw_contours_with_colors(img, contours):   img = img.copy()   for c in contours:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.drawContours(img, [c], -1, color, 2)   return img"},
    "Draw all contours on the source image in a certain hue. ": {"nl":"Draw all contours on the source image in a certain hue. ","code":"def draw_contours_with_colors(img, contours):   img = img.copy()   for c in contours:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.drawContours(img, [c], -1, color, 2)   return img"},
    "Create all of the outlines on the original image, but use a certain shade of colour for them. ": {"nl":"Create all of the outlines on the original image, but use a certain shade of colour for them. ","code":"def draw_contours_with_colors(img, contours):   img = img.copy()   for c in contours:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.drawContours(img, [c], -1, color, 2)   return img"},
    "find the centroid of a contour": {"nl":"find the centroid of a contour","code":"def find_centroid(img, contour):   M = cv2.moments(contour)   cx = int(M['m10']/M['m00'])   cy = int(M['m01']/M['m00'])   return cx, cy"},
    "locate a contour's centroid ": {"nl":"locate a contour's centroid ","code":"def find_centroid(img, contour):   M = cv2.moments(contour)   cx = int(M['m10']/M['m00'])   cy = int(M['m01']/M['m00'])   return cx, cy"},
    "determine a contour's centroid. ": {"nl":"determine a contour's centroid. ","code":"def find_centroid(img, contour):   M = cv2.moments(contour)   cx = int(M['m10']/M['m00'])   cy = int(M['m01']/M['m00'])   return cx, cy"},
    "calculate a contour's centroid. ": {"nl":"calculate a contour's centroid. ","code":"def find_centroid(img, contour):   M = cv2.moments(contour)   cx = int(M['m10']/M['m00'])   cy = int(M['m01']/M['m00'])   return cx, cy"},
    "Locate the centre of a contour using its centroid": {"nl":"Locate the centre of a contour using its centroid","code":"def find_centroid(img, contour):   M = cv2.moments(contour)   cx = int(M['m10']/M['m00'])   cy = int(M['m01']/M['m00'])   return cx, cy"},
    "Locate the centre of a contour ": {"nl":"Locate the centre of a contour ","code":"def find_centroid(img, contour):   M = cv2.moments(contour)   cx = int(M['m10']/M['m00'])   cy = int(M['m01']/M['m00'])   return cx, cy"},
    "Determine the centre of a contour. ": {"nl":"Determine the centre of a contour. ","code":"def find_centroid(img, contour):   M = cv2.moments(contour)   cx = int(M['m10']/M['m00'])   cy = int(M['m01']/M['m00'])   return cx, cy"},
    "How do you find the contour's centroid": {"nl":"How do you find the contour's centroid","code":"def find_centroid(img, contour):   M = cv2.moments(contour)   cx = int(M['m10']/M['m00'])   cy = int(M['m01']/M['m00'])   return cx, cy"},
    "contour centroid ": {"nl":"contour centroid ","code":"def find_centroid(img, contour):   M = cv2.moments(contour)   cx = int(M['m10']/M['m00'])   cy = int(M['m01']/M['m00'])   return cx, cy"},
    "a contour's centroid ": {"nl":"a contour's centroid ","code":"def find_centroid(img, contour):   M = cv2.moments(contour)   cx = int(M['m10']/M['m00'])   cy = int(M['m01']/M['m00'])   return cx, cy"},
    "draw a rectangle around the contours": {"nl":"draw a rectangle around the contours","code":"def draw_rectangles(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "Draw a rectangle around the contours": {"nl":"Draw a rectangle around the contours","code":"def draw_rectangles(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "a rectangle should be drawn around the contours": {"nl":"a rectangle should be drawn around the contours","code":"def draw_rectangles(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "Create a rectangle encompassing the contours": {"nl":"Create a rectangle encompassing the contours","code":"def draw_rectangles(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "enclose the contours in a rectangle": {"nl":"enclose the contours in a rectangle","code":"def draw_rectangles(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "Create a rectangle around the outlines": {"nl":"Create a rectangle around the outlines","code":"def draw_rectangles(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "draw a rectangle around the outlines": {"nl":"draw a rectangle around the outlines","code":"def draw_rectangles(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "draw a rectangle around the outline ": {"nl":"draw a rectangle around the outline ","code":"def draw_rectangles(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "A rectangle should be drawn around the outlines ": {"nl":"A rectangle should be drawn around the outlines ","code":"def draw_rectangles(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "Create a rectangle that surrounds the outlines. ": {"nl":"Create a rectangle that surrounds the outlines. ","code":"def draw_rectangles(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "A rectangle should be drawn around the outside of the outlines. ": {"nl":"A rectangle should be drawn around the outside of the outlines. ","code":"def draw_rectangles(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "Around the contours, draw a rectangle": {"nl":"Around the contours, draw a rectangle","code":"def draw_rectangles(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "Outside of the contours, draw a rectangle": {"nl":"Outside of the contours, draw a rectangle","code":"def draw_rectangles(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "surrounding the contours, draw a rectangle": {"nl":"surrounding the contours, draw a rectangle","code":"def draw_rectangles(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "a rectangle enclosing the outline ": {"nl":"a rectangle enclosing the outline ","code":"def draw_rectangles(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "draw a rectangle around the contours with a specific color": {"nl":"draw a rectangle around the contours with a specific color","code":"def draw_rectangles_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)   return img"},
    "In a given colour, draw a rectangle around the contours": {"nl":"In a given colour, draw a rectangle around the contours","code":"def draw_rectangles_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)   return img"},
    "Create a rectangle with a given colour around the contours": {"nl":"Create a rectangle with a given colour around the contours","code":"def draw_rectangles_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)   return img"},
    "With a particular hue, create a rectangle around the contours": {"nl":"With a particular hue, create a rectangle around the contours","code":"def draw_rectangles_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)   return img"},
    "With a certain hue, draw a rectangle around the contours": {"nl":"With a certain hue, draw a rectangle around the contours","code":"def draw_rectangles_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)   return img"},
    "Draw a rectangle with a certain colour around the contours": {"nl":"Draw a rectangle with a certain colour around the contours","code":"def draw_rectangles_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)   return img"},
    "Using a specified colour, draw a rectangle around the contours": {"nl":"Using a specified colour, draw a rectangle around the contours","code":"def draw_rectangles_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)   return img"},
    "With a given colour, create a rectangle around the contours": {"nl":"With a given colour, create a rectangle around the contours","code":"def draw_rectangles_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)   return img"},
    "encircle the contours with a rectangle of a given colour ": {"nl":"encircle the contours with a rectangle of a given colour ","code":"def draw_rectangles_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)   return img"},
    "Use a specific colour to outline the contours with a rectangle ": {"nl":"Use a specific colour to outline the contours with a rectangle ","code":"def draw_rectangles_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)   return img"},
    "Create a rectangle using a particular colour and wrap it around the contours": {"nl":"Create a rectangle using a particular colour and wrap it around the contours","code":"def draw_rectangles_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)   return img"},
    "get the center of the contours": {"nl":"get the center of the contours","code":"def get_contours_center(img, contours):   centers = []   for c in contours:       cx, cy = find_centroid(img, c)       centers.append((cx, cy))   return centers"},
    "Identify the contours' centre": {"nl":"Identify the contours' centre","code":"def get_contours_center(img, contours):   centers = []   for c in contours:       cx, cy = find_centroid(img, c)       centers.append((cx, cy))   return centers"},
    "the contours' centre, please": {"nl":"the contours' centre, please","code":"def get_contours_center(img, contours):   centers = []   for c in contours:       cx, cy = find_centroid(img, c)       centers.append((cx, cy))   return centers"},
    "obtain the contours' centre ": {"nl":"obtain the contours' centre ","code":"def get_contours_center(img, contours):   centers = []   for c in contours:       cx, cy = find_centroid(img, c)       centers.append((cx, cy))   return centers"},
    "find the centre of the contours ": {"nl":"find the centre of the contours ","code":"def get_contours_center(img, contours):   centers = []   for c in contours:       cx, cy = find_centroid(img, c)       centers.append((cx, cy))   return centers"},
    "contour centre ": {"nl":"contour centre ","code":"def get_contours_center(img, contours):   centers = []   for c in contours:       cx, cy = find_centroid(img, c)       centers.append((cx, cy))   return centers"},
    "get contours' centres": {"nl":"get contours' centres","code":"def get_contours_center(img, contours):   centers = []   for c in contours:       cx, cy = find_centroid(img, c)       centers.append((cx, cy))   return centers"},
    "draw a circle at the center of the contours": {"nl":"draw a circle at the center of the contours","code":"def draw_circles(img, centers):   img = img.copy()   for c in centers:       cv2.circle(img, c, 2, (255, 0, 0), 2)   return img"},
    "At the centre of the contours, draw a circle": {"nl":"At the centre of the contours, draw a circle","code":"def draw_circles(img, centers):   img = img.copy()   for c in centers:       cv2.circle(img, c, 2, (255, 0, 0), 2)   return img"},
    "The centre of the contours should be marked with a circle": {"nl":"The centre of the contours should be marked with a circle","code":"def draw_circles(img, centers):   img = img.copy()   for c in centers:       cv2.circle(img, c, 2, (255, 0, 0), 2)   return img"},
    "At the centre of the contours, trace a circle": {"nl":"At the centre of the contours, trace a circle","code":"def draw_circles(img, centers):   img = img.copy()   for c in centers:       cv2.circle(img, c, 2, (255, 0, 0), 2)   return img"},
    "In the centre of the contours, draw a circle": {"nl":"In the centre of the contours, draw a circle","code":"def draw_circles(img, centers):   img = img.copy()   for c in centers:       cv2.circle(img, c, 2, (255, 0, 0), 2)   return img"},
    "Make a circle in the centre of the contours": {"nl":"Make a circle in the centre of the contours","code":"def draw_circles(img, centers):   img = img.copy()   for c in centers:       cv2.circle(img, c, 2, (255, 0, 0), 2)   return img"},
    "Create a circle in the centre of the outlines": {"nl":"Create a circle in the centre of the outlines","code":"def draw_circles(img, centers):   img = img.copy()   for c in centers:       cv2.circle(img, c, 2, (255, 0, 0), 2)   return img"},
    "draw a circle in the centre of the contours ": {"nl":"draw a circle in the centre of the contours ","code":"def draw_circles(img, centers):   img = img.copy()   for c in centers:       cv2.circle(img, c, 2, (255, 0, 0), 2)   return img"},
    "draw a circle at the center of the contours with a specific color": {"nl":"draw a circle at the center of the contours with a specific color","code":"def draw_circles_with_colors(img, centers):   img = img.copy()   for c in centers:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.circle(img, c, 2, color, 2)   return img"},
    "With a specified hue, draw a circle in the centre of the contours": {"nl":"With a specified hue, draw a circle in the centre of the contours","code":"def draw_circles_with_colors(img, centers):   img = img.copy()   for c in centers:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.circle(img, c, 2, color, 2)   return img"},
    "Draw a circle with a certain colour in the centre of the contours": {"nl":"Draw a circle with a certain colour in the centre of the contours","code":"def draw_circles_with_colors(img, centers):   img = img.copy()   for c in centers:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.circle(img, c, 2, color, 2)   return img"},
    "Using a specified hue, create a circle with the contours in its centre": {"nl":"Using a specified hue, create a circle with the contours in its centre","code":"def draw_circles_with_colors(img, centers):   img = img.copy()   for c in centers:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.circle(img, c, 2, color, 2)   return img"},
    "Using a specified colour, create a circle in the centre of the contours": {"nl":"Using a specified colour, create a circle in the centre of the contours","code":"def draw_circles_with_colors(img, centers):   img = img.copy()   for c in centers:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.circle(img, c, 2, color, 2)   return img"},
    "Create a circle in the middle of the contours and fill it with a particular colour": {"nl":"Create a circle in the middle of the contours and fill it with a particular colour","code":"def draw_circles_with_colors(img, centers):   img = img.copy()   for c in centers:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.circle(img, c, 2, color, 2)   return img"},
    "Draw a colour circle in the contours' centre": {"nl":"Draw a colour circle in the contours' centre","code":"def draw_circles_with_colors(img, centers):   img = img.copy()   for c in centers:       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.circle(img, c, 2, color, 2)   return img"},
    "calculate the center of mass": {"nl":"calculate the center of mass","code":"def get_center_of_mass(img, contours):   M = cv2.moments(img)   return (int(M['m10']/M['m00']), int(M['m01']/M['m00']))"},
    "to determine the centre of mass ": {"nl":"to determine the centre of mass ","code":"def get_center_of_mass(img, contours):   M = cv2.moments(img)   return (int(M['m10']/M['m00']), int(M['m01']/M['m00']))"},
    "find the centre of mass ": {"nl":"find the centre of mass ","code":"def get_center_of_mass(img, contours):   M = cv2.moments(img)   return (int(M['m10']/M['m00']), int(M['m01']/M['m00']))"},
    "determine the centre of mass ": {"nl":"determine the centre of mass ","code":"def get_center_of_mass(img, contours):   M = cv2.moments(img)   return (int(M['m10']/M['m00']), int(M['m01']/M['m00']))"},
    "centre of mass calculation ": {"nl":"centre of mass calculation ","code":"def get_center_of_mass(img, contours):   M = cv2.moments(img)   return (int(M['m10']/M['m00']), int(M['m01']/M['m00']))"},
    "draw the center of mass": {"nl":"draw the center of mass","code":"def draw_center_of_mass(img, center_of_mass):   img = img.copy()   cv2.circle(img, center_of_mass, 2, (255, 0, 0), 2)   return img"},
    "make a diagram showing the centre of mass ": {"nl":"make a diagram showing the centre of mass ","code":"def draw_center_of_mass(img, center_of_mass):   img = img.copy()   cv2.circle(img, center_of_mass, 2, (255, 0, 0), 2)   return img"},
    "create the centre of mass ": {"nl":"create the centre of mass ","code":"def draw_center_of_mass(img, center_of_mass):   img = img.copy()   cv2.circle(img, center_of_mass, 2, (255, 0, 0), 2)   return img"},
    "Draw the mass's centroid. ": {"nl":"Draw the mass's centroid. ","code":"def draw_center_of_mass(img, center_of_mass):   img = img.copy()   cv2.circle(img, center_of_mass, 2, (255, 0, 0), 2)   return img"},
    "Make a mass centre diagram. ": {"nl":"Make a mass centre diagram. ","code":"def draw_center_of_mass(img, center_of_mass):   img = img.copy()   cv2.circle(img, center_of_mass, 2, (255, 0, 0), 2)   return img"},
    "Figure out the mass's centre. ": {"nl":"Figure out the mass's centre. ","code":"def draw_center_of_mass(img, center_of_mass):   img = img.copy()   cv2.circle(img, center_of_mass, 2, (255, 0, 0), 2)   return img"},
    "get the area of each contour": {"nl":"get the area of each contour","code":"def get_areas(img, contours):   areas = [cv2.contourArea(c) for c in contours]   return areas"},
    "acquire each contour's area ": {"nl":"acquire each contour's area ","code":"def get_areas(img, contours):   areas = [cv2.contourArea(c) for c in contours]   return areas"},
    "determine each contour's area": {"nl":"determine each contour's area","code":"def get_areas(img, contours):   areas = [cv2.contourArea(c) for c in contours]   return areas"},
    "determining the area of each contour ": {"nl":"determining the area of each contour ","code":"def get_areas(img, contours):   areas = [cv2.contourArea(c) for c in contours]   return areas"},
    "calculating the area of each contour": {"nl":"calculating the area of each contour","code":"def get_areas(img, contours):   areas = [cv2.contourArea(c) for c in contours]   return areas"},
    "obtain the area of every contour": {"nl":"obtain the area of every contour","code":"def get_areas(img, contours):   areas = [cv2.contourArea(c) for c in contours]   return areas"},
    "find the area of each contour ": {"nl":"find the area of each contour ","code":"def get_areas(img, contours):   areas = [cv2.contourArea(c) for c in contours]   return areas"},
    "determine the area occupied by each contour": {"nl":"determine the area occupied by each contour","code":"def get_areas(img, contours):   areas = [cv2.contourArea(c) for c in contours]   return areas"},
    "contour area ": {"nl":"contour area ","code":"def get_areas(img, contours):   areas = [cv2.contourArea(c) for c in contours]   return areas"},
    "area of each contour ": {"nl":"area of each contour ","code":"def get_areas(img, contours):   areas = [cv2.contourArea(c) for c in contours]   return areas"},
    "get every contour area ": {"nl":"get every contour area ","code":"def get_areas(img, contours):   areas = [cv2.contourArea(c) for c in contours]   return areas"},
    "calculate the aspect ratio of each contour": {"nl":"calculate the aspect ratio of each contour","code":"def aspect_ratio(contour):   x, y, w, h = cv2.boundingRect(contour)   aspect_ratio = float(w)/h   return aspect_ratio"},
    "draw a bounding box around the contours": {"nl":"draw a bounding box around the contours","code":"def draw_bounding_boxes(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "The contours should be surrounded by a bounding box": {"nl":"The contours should be surrounded by a bounding box","code":"def draw_bounding_boxes(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "around the contours, draw a bounding box": {"nl":"around the contours, draw a bounding box","code":"def draw_bounding_boxes(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "A bounding box should be drawn around the contours": {"nl":"A bounding box should be drawn around the contours","code":"def draw_bounding_boxes(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "Draw a bounding box around the contours": {"nl":"Draw a bounding box around the contours","code":"def draw_bounding_boxes(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "Create a box around the contours": {"nl":"Create a box around the contours","code":"def draw_bounding_boxes(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "Make a box around the contours": {"nl":"Make a box around the contours","code":"def draw_bounding_boxes(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)   return img"},
    "draw a bounding box around the contours with a specific color": {"nl":"draw a bounding box around the contours with a specific color","code":"def draw_bounding_boxes_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.rectangle(img, (x, y), (x+w, y+h), color, 2)   return img"},
    "draw the bounding box around the contours with a specific color": {"nl":"draw the bounding box around the contours with a specific color","code":"def draw_bounding_ellipses_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.ellipse(img, (x + int(w/2), y + int(h/2)), (int(w/2), int(h/2)), 0, 0, 360, color, 2)   return img"},
    "With a specified hue, create a bounding box around the contours. ": {"nl":"With a specified hue, create a bounding box around the contours. ","code":"def draw_bounding_ellipses_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.ellipse(img, (x + int(w/2), y + int(h/2)), (int(w/2), int(h/2)), 0, 0, 360, color, 2)   return img"},
    "Using a specified hue, create a bounding box around the contours. ": {"nl":"Using a specified hue, create a bounding box around the contours. ","code":"def draw_bounding_ellipses_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.ellipse(img, (x + int(w/2), y + int(h/2)), (int(w/2), int(h/2)), 0, 0, 360, color, 2)   return img"},
    "The bounding box around the contours should be drawn using a certain colour. ": {"nl":"The bounding box around the contours should be drawn using a certain colour. ","code":"def draw_bounding_ellipses_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.ellipse(img, (x + int(w/2), y + int(h/2)), (int(w/2), int(h/2)), 0, 0, 360, color, 2)   return img"},
    "A certain colour should be used to outline the bounding box. ": {"nl":"A certain colour should be used to outline the bounding box. ","code":"def draw_bounding_ellipses_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.ellipse(img, (x + int(w/2), y + int(h/2)), (int(w/2), int(h/2)), 0, 0, 360, color, 2)   return img"},
    "Draw a specified colour for the bounding box around the contours. ": {"nl":"Draw a specified colour for the bounding box around the contours. ","code":"def draw_bounding_ellipses_with_colors(img, contours):   img = img.copy()   for c in contours:       x, y, w, h = cv2.boundingRect(c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.ellipse(img, (x + int(w/2), y + int(h/2)), (int(w/2), int(h/2)), 0, 0, 360, color, 2)   return img"},
    "calculate the extreme points of the contours": {"nl":"calculate the extreme points of the contours","code":"def get_extreme_points(contours):   extreme_left = tuple(contours[contours[:, :, 0].argmin()][0])   extreme_right = tuple(contours[contours[:, :, 0].argmax()][0])   extreme_top = tuple(contours[contours[:, :, 1].argmin()][0])   extreme_bottom = tuple(contours[contours[:, :, 1].argmax()][0])   return extreme_left, extreme_right, extreme_top, extreme_bottom"},
    "compute the outlines extreme points ": {"nl":"compute the outlines extreme points ","code":"def get_extreme_points(contours):   extreme_left = tuple(contours[contours[:, :, 0].argmin()][0])   extreme_right = tuple(contours[contours[:, :, 0].argmax()][0])   extreme_top = tuple(contours[contours[:, :, 1].argmin()][0])   extreme_bottom = tuple(contours[contours[:, :, 1].argmax()][0])   return extreme_left, extreme_right, extreme_top, extreme_bottom"},
    "determine the outlines extreme points ": {"nl":"determine the outlines extreme points ","code":"def get_extreme_points(contours):   extreme_left = tuple(contours[contours[:, :, 0].argmin()][0])   extreme_right = tuple(contours[contours[:, :, 0].argmax()][0])   extreme_top = tuple(contours[contours[:, :, 1].argmin()][0])   extreme_bottom = tuple(contours[contours[:, :, 1].argmax()][0])   return extreme_left, extreme_right, extreme_top, extreme_bottom"},
    "Calculate the contours extreme points": {"nl":"Calculate the contours extreme points","code":"def get_extreme_points(contours):   extreme_left = tuple(contours[contours[:, :, 0].argmin()][0])   extreme_right = tuple(contours[contours[:, :, 0].argmax()][0])   extreme_top = tuple(contours[contours[:, :, 1].argmin()][0])   extreme_bottom = tuple(contours[contours[:, :, 1].argmax()][0])   return extreme_left, extreme_right, extreme_top, extreme_bottom"},
    "draw the extreme points of the contours": {"nl":"draw the extreme points of the contours","code":"def draw_extreme_points(img, contours):   img = img.copy()   left, right, top, bottom = get_extreme_points(contours)   cv2.circle(img, left, 5, (0, 0, 255), -1)   cv2.circle(img, right, 5, (0, 255, 255), -1)   cv2.circle(img, top, 5, (255, 0, 0), -1)   cv2.circle(img, bottom, 5, (255, 255, 0), -1)   return img"},
    "calculate the bounding rectangle area": {"nl":"calculate the bounding rectangle area","code":"def get_bounding_rectangle_area(img, contours):   _, _, width, height = cv2.boundingRect(contours[0])   return width * height"},
    "calculate the bounding rotated rectangle area": {"nl":"calculate the bounding rotated rectangle area","code":"def get_bounding_rotated_rectangle_area(img, contours):   return cv2.minAreaRect(contours[0])[1][0] * cv2.minAreaRect(contours[0])[1][1]"},
    "draw a line through the center of the contours": {"nl":"draw a line through the center of the contours","code":"def draw_lines_through_center(img, contours):   img = img.copy()   for c in contours:       cx, cy = find_centroid(img, c)       cv2.line(img, (cx, 0), (cx, img.shape[0]), (255, 0, 0), 1)       cv2.line(img, (0, cy), (img.shape[1], cy), (255, 0, 0), 1)   return img"},
    "draw a line through the center of the contours with a specific color": {"nl":"draw a line through the center of the contours with a specific color","code":"def draw_lines_through_center_with_colors(img, contours):   img = img.copy()   for c in contours:       cx, cy = find_centroid(img, c)       color = (np.random.randint(256), np.random.randint(256), np.random.randint(256))       cv2.line(img, (cx, 0), (cx, img.shape[0]), color, 2)       cv2.line(img, (0, cy), (img.shape[1], cy), color, 2)   return img"},
    "return the length of the contours": {"nl":"return the length of the contours","code":"def get_contour_lengths(img, contours):   lengths = [cv2.arcLength(c, True) for c in contours]   return lengths"},
    "return the contours' length ": {"nl":"return the contours' length ","code":"def get_contour_lengths(img, contours):   lengths = [cv2.arcLength(c, True) for c in contours]   return lengths"},
    "give the contours length ": {"nl":"give the contours length ","code":"def get_contour_lengths(img, contours):   lengths = [cv2.arcLength(c, True) for c in contours]   return lengths"},
    "provide the contours length ": {"nl":"provide the contours length ","code":"def get_contour_lengths(img, contours):   lengths = [cv2.arcLength(c, True) for c in contours]   return lengths"},
    "get the center of the bounding rectangle": {"nl":"get the center of the bounding rectangle","code":"\"def get_center(cnt):   x, y, w, h = cv2.boundingRect(cnt)   center = (x + w / 2, y + h / 2)\""},
    "get the center of the minimum enclosing circle": {"nl":"get the center of the minimum enclosing circle","code":"def get_minimum_enclosing_circle_centers(img, contours):   centers = []   for c in contours:       (x, y), radius = cv2.minEnclosingCircle(c)       centers.append((int(x), int(y)))   return centers"},
    "give the contours' length ": {"nl":"give the contours' length ","code":"def get_contour_lengths(img, contours):   lengths = [cv2.arcLength(c, True) for c in contours]   return lengths"},
    "provide the contours' length": {"nl":"provide the contours' length","code":"def get_contour_lengths(img, contours):   lengths = [cv2.arcLength(c, True) for c in contours]   return lengths"},
    "randomly rotates an image with an angle from -180 to 180": {"nl":"randomly rotates an image with an angle from -180 to 180","code":"def random_rotation(image):   angle = np.random.uniform(-180, 180)   return rotate(image, angle)\n"},
    "Randomly spins an image from -180 to 180 degrees": {"nl":"Randomly spins an image from -180 to 180 degrees","code":"def random_rotation(image):   angle = np.random.uniform(-180, 180)   return rotate(image, angle)\n"},
    "Randomly rotates an image's angle between -180 and 180 degrees": {"nl":"Randomly rotates an image's angle between -180 and 180 degrees","code":"def random_rotation(image):   angle = np.random.uniform(-180, 180)   return rotate(image, angle)\n"},
    "A random rotation of 180 degrees is applied to an image": {"nl":"A random rotation of 180 degrees is applied to an image","code":"def random_rotation(image):   angle = np.random.uniform(-180, 180)   return rotate(image, angle)\n"},
    "performs a random rotation on a picture using an angle ranging from -180 to 180": {"nl":"performs a random rotation on a picture using an angle ranging from -180 to 180","code":"def random_rotation(image):   angle = np.random.uniform(-180, 180)   return rotate(image, angle)\n"},
    "transforms an image by a random amount using an angle ranging from -180 to 180": {"nl":"transforms an image by a random amount using an angle ranging from -180 to 180","code":"def random_rotation(image):   angle = np.random.uniform(-180, 180)   return rotate(image, angle)\n"},
    "a random rotation with an angle ranging from -180 to 180 degrees is applied to an image": {"nl":"a random rotation with an angle ranging from -180 to 180 degrees is applied to an image","code":"def random_rotation(image):   angle = np.random.uniform(-180, 180)   return rotate(image, angle)\n"},
    "generates a random angle between -180 and 180 degrees for rotating an image": {"nl":"generates a random angle between -180 and 180 degrees for rotating an image","code":"def random_rotation(image):   angle = np.random.uniform(-180, 180)   return rotate(image, angle)\n"},
    "random rotation from -180 to 180 ": {"nl":"random rotation from -180 to 180 ","code":"def random_rotation(image):   angle = np.random.uniform(-180, 180)   return rotate(image, angle)\n"},
    "randomly translates the image both horizontally and vertically": {"nl":"randomly translates the image both horizontally and vertically","code":"def Translation(image):   transy=np.random.uniform(-0.2,0.2)   transx=np.random.uniform(-0.2,0.2)   height, width = image.shape[:2]   tx, ty = width * transx, height*transy   translation_matrix = np.array([[1, 0, tx],[0, 1, ty]], dtype=np.float32)   translated_image = cv2.warpAffine(src=image, M=translation_matrix, dsize=(width, height))   return translated_image"},
    "scales the image with a random factor value": {"nl":"scales the image with a random factor value","code":"def Scale(image):   factor=np.random.uniform(0.8,1.2)   scaled_image = cv2.resize(image, (0, 0), fx=factor, fy=factor)   return scaled_image"},
    "scales the picture using a random value": {"nl":"scales the picture using a random value","code":"def Scale(image):   factor=np.random.uniform(0.8,1.2)   scaled_image = cv2.resize(image, (0, 0), fx=factor, fy=factor)   return scaled_image"},
    "enlarges the picture by a random factor": {"nl":"enlarges the picture by a random factor","code":"def Scale(image):   factor=np.random.uniform(0.8,1.2)   scaled_image = cv2.resize(image, (0, 0), fx=factor, fy=factor)   return scaled_image"},
    "adjusts the picture shape using a random value ": {"nl":"adjusts the picture shape using a random value ","code":"def Scale(image):   factor=np.random.uniform(0.8,1.2)   scaled_image = cv2.resize(image, (0, 0), fx=factor, fy=factor)   return scaled_image"},
    "uses a random factor value to scale the picture": {"nl":"uses a random factor value to scale the picture","code":"def Scale(image):   factor=np.random.uniform(0.8,1.2)   scaled_image = cv2.resize(image, (0, 0), fx=factor, fy=factor)   return scaled_image"},
    "shears the image": {"nl":"shears the image","code":"def Shear(image):   height, width = image.shape[:2]   theta=np.random.uniform(-30,30)   M = np.float32([[1, np.tan(theta), 0],[np.tan(theta), 1  , 0],[0, 0  , 1]])     M[0,2] = -M[0,1] * width/2   M[1,2] = -M[1,0] * height/2   sheared_img = cv2.warpPerspective(image,M,(width,height))   return sheared_img"},
    "shears the picture ": {"nl":"shears the picture ","code":"def Shear(image):   height, width = image.shape[:2]   theta=np.random.uniform(-30,30)   M = np.float32([[1, np.tan(theta), 0],[np.tan(theta), 1  , 0],[0, 0  , 1]])     M[0,2] = -M[0,1] * width/2   M[1,2] = -M[1,0] * height/2   sheared_img = cv2.warpPerspective(image,M,(width,height))   return sheared_img"},
    "image shears ": {"nl":"image shears ","code":"def Shear(image):   height, width = image.shape[:2]   theta=np.random.uniform(-30,30)   M = np.float32([[1, np.tan(theta), 0],[np.tan(theta), 1  , 0],[0, 0  , 1]])     M[0,2] = -M[0,1] * width/2   M[1,2] = -M[1,0] * height/2   sheared_img = cv2.warpPerspective(image,M,(width,height))   return sheared_img"},
    "cuts the picture. ": {"nl":"cuts the picture. ","code":"def Shear(image):   height, width = image.shape[:2]   theta=np.random.uniform(-30,30)   M = np.float32([[1, np.tan(theta), 0],[np.tan(theta), 1  , 0],[0, 0  , 1]])     M[0,2] = -M[0,1] * width/2   M[1,2] = -M[1,0] * height/2   sheared_img = cv2.warpPerspective(image,M,(width,height))   return sheared_img"},
    "shreds the picture ": {"nl":"shreds the picture ","code":"def Shear(image):   height, width = image.shape[:2]   theta=np.random.uniform(-30,30)   M = np.float32([[1, np.tan(theta), 0],[np.tan(theta), 1  , 0],[0, 0  , 1]])     M[0,2] = -M[0,1] * width/2   M[1,2] = -M[1,0] * height/2   sheared_img = cv2.warpPerspective(image,M,(width,height))   return sheared_img"},
    "adds contrast to image": {"nl":"adds contrast to image","code":"def Contrast(image):   alpha=np.random.uniform(0.2, 1.8)   new_image = np.zeros(image.shape, image.dtype)   new_image = cv2.convertScaleAbs(image, alpha=alpha, beta=0)   return new_image"},
    "enhances image contrast ": {"nl":"enhances image contrast ","code":"def Contrast(image):   alpha=np.random.uniform(0.2, 1.8)   new_image = np.zeros(image.shape, image.dtype)   new_image = cv2.convertScaleAbs(image, alpha=alpha, beta=0)   return new_image"},
    "increases image contrast ": {"nl":"increases image contrast ","code":"def Contrast(image):   alpha=np.random.uniform(0.2, 1.8)   new_image = np.zeros(image.shape, image.dtype)   new_image = cv2.convertScaleAbs(image, alpha=alpha, beta=0)   return new_image"},
    "improves image contrast ": {"nl":"improves image contrast ","code":"def Contrast(image):   alpha=np.random.uniform(0.2, 1.8)   new_image = np.zeros(image.shape, image.dtype)   new_image = cv2.convertScaleAbs(image, alpha=alpha, beta=0)   return new_image"},
    "contrasts the image ": {"nl":"contrasts the image ","code":"def Contrast(image):   alpha=np.random.uniform(0.2, 1.8)   new_image = np.zeros(image.shape, image.dtype)   new_image = cv2.convertScaleAbs(image, alpha=alpha, beta=0)   return new_image"},
    "boosts the image's contrast ": {"nl":"boosts the image's contrast ","code":"def Contrast(image):   alpha=np.random.uniform(0.2, 1.8)   new_image = np.zeros(image.shape, image.dtype)   new_image = cv2.convertScaleAbs(image, alpha=alpha, beta=0)   return new_image"},
    "changes brightness of image": {"nl":"changes brightness of image","code":"def Brightness(image):   beta=np.random.uniform(0.2, 1.8)   new_image = np.zeros(image.shape, image.dtype)   new_image = cv2.convertScaleAbs(image, alpha=1, beta=beta)   return new_image"},
    "alters the image's brightness ": {"nl":"alters the image's brightness ","code":"def Brightness(image):   beta=np.random.uniform(0.2, 1.8)   new_image = np.zeros(image.shape, image.dtype)   new_image = cv2.convertScaleAbs(image, alpha=1, beta=beta)   return new_image"},
    "alterations in picture brightness ": {"nl":"alterations in picture brightness ","code":"def Brightness(image):   beta=np.random.uniform(0.2, 1.8)   new_image = np.zeros(image.shape, image.dtype)   new_image = cv2.convertScaleAbs(image, alpha=1, beta=beta)   return new_image"},
    "adjusts the image's brightness ": {"nl":"adjusts the image's brightness ","code":"def Brightness(image):   beta=np.random.uniform(0.2, 1.8)   new_image = np.zeros(image.shape, image.dtype)   new_image = cv2.convertScaleAbs(image, alpha=1, beta=beta)   return new_image"},
    "Return a sharpened version of the image, using an unsharp mask.": {"nl":"Return a sharpened version of the image, using an unsharp mask.","code":"def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n   blurred = cv2.GaussianBlur(image, kernel_size, sigma)   sharpened = float(amount + 1) * image - float(amount) * blurred   sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))   sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))   sharpened = sharpened.round().astype(np.uint8)   if threshold > 0:       low_contrast_mask = np.absolute(image - blurred) < threshold       np.copyto(sharpened, image, where=low_contrast_mask)   return sharpened"},
    "Use an unsharp mask to return a sharpened version of the image. ": {"nl":"Use an unsharp mask to return a sharpened version of the image. ","code":"def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n   blurred = cv2.GaussianBlur(image, kernel_size, sigma)   sharpened = float(amount + 1) * image - float(amount) * blurred   sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))   sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))   sharpened = sharpened.round().astype(np.uint8)   if threshold > 0:       low_contrast_mask = np.absolute(image - blurred) < threshold       np.copyto(sharpened, image, where=low_contrast_mask)   return sharpened"},
    "Return the picture with the image sharpened using an unsharp mask. ": {"nl":"Return the picture with the image sharpened using an unsharp mask. ","code":"def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n   blurred = cv2.GaussianBlur(image, kernel_size, sigma)   sharpened = float(amount + 1) * image - float(amount) * blurred   sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))   sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))   sharpened = sharpened.round().astype(np.uint8)   if threshold > 0:       low_contrast_mask = np.absolute(image - blurred) < threshold       np.copyto(sharpened, image, where=low_contrast_mask)   return sharpened"},
    "With the help of an unsharp mask, return a sharpened version of the image. ": {"nl":"With the help of an unsharp mask, return a sharpened version of the image. ","code":"def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n   blurred = cv2.GaussianBlur(image, kernel_size, sigma)   sharpened = float(amount + 1) * image - float(amount) * blurred   sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))   sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))   sharpened = sharpened.round().astype(np.uint8)   if threshold > 0:       low_contrast_mask = np.absolute(image - blurred) < threshold       np.copyto(sharpened, image, where=low_contrast_mask)   return sharpened"},
    "Return a picture that has been sharpened using an unsharp mask. ": {"nl":"Return a picture that has been sharpened using an unsharp mask. ","code":"def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n   blurred = cv2.GaussianBlur(image, kernel_size, sigma)   sharpened = float(amount + 1) * image - float(amount) * blurred   sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))   sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))   sharpened = sharpened.round().astype(np.uint8)   if threshold > 0:       low_contrast_mask = np.absolute(image - blurred) < threshold       np.copyto(sharpened, image, where=low_contrast_mask)   return sharpened"},
    "Using an unsharp mask, return a sharpened version of the image. ": {"nl":"Using an unsharp mask, return a sharpened version of the image. ","code":"def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n   blurred = cv2.GaussianBlur(image, kernel_size, sigma)   sharpened = float(amount + 1) * image - float(amount) * blurred   sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))   sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))   sharpened = sharpened.round().astype(np.uint8)   if threshold > 0:       low_contrast_mask = np.absolute(image - blurred) < threshold       np.copyto(sharpened, image, where=low_contrast_mask)   return sharpened"},
    "Return an image that has been sharpened by applying an unsharp mask to it": {"nl":"Return an image that has been sharpened by applying an unsharp mask to it","code":"def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n   blurred = cv2.GaussianBlur(image, kernel_size, sigma)   sharpened = float(amount + 1) * image - float(amount) * blurred   sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))   sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))   sharpened = sharpened.round().astype(np.uint8)   if threshold > 0:       low_contrast_mask = np.absolute(image - blurred) < threshold       np.copyto(sharpened, image, where=low_contrast_mask)   return sharpened"},
    "Return a version of the image that has been sharpened by employing an unsharp mask": {"nl":"Return a version of the image that has been sharpened by employing an unsharp mask","code":"def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n   blurred = cv2.GaussianBlur(image, kernel_size, sigma)   sharpened = float(amount + 1) * image - float(amount) * blurred   sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))   sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))   sharpened = sharpened.round().astype(np.uint8)   if threshold > 0:       low_contrast_mask = np.absolute(image - blurred) < threshold       np.copyto(sharpened, image, where=low_contrast_mask)   return sharpened"},
    "Return an unsharp mask-sharpened image": {"nl":"Return an unsharp mask-sharpened image","code":"def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n   blurred = cv2.GaussianBlur(image, kernel_size, sigma)   sharpened = float(amount + 1) * image - float(amount) * blurred   sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))   sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))   sharpened = sharpened.round().astype(np.uint8)   if threshold > 0:       low_contrast_mask = np.absolute(image - blurred) < threshold       np.copyto(sharpened, image, where=low_contrast_mask)   return sharpened"},
    "Sharpen image using unsharp mask": {"nl":"Sharpen image using unsharp mask","code":"def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n   blurred = cv2.GaussianBlur(image, kernel_size, sigma)   sharpened = float(amount + 1) * image - float(amount) * blurred   sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))   sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))   sharpened = sharpened.round().astype(np.uint8)   if threshold > 0:       low_contrast_mask = np.absolute(image - blurred) < threshold       np.copyto(sharpened, image, where=low_contrast_mask)   return sharpened"},
    "displays an image": {"nl":"displays an image","code":"def show_image(img, title='image'):   plt.imshow(img)   plt.title(title)   plt.show()"},
    "Shows an image": {"nl":"Shows an image","code":"def show_image(img, title='image'):   plt.imshow(img)   plt.title(title)   plt.show()"},
    "shows a picture ": {"nl":"shows a picture ","code":"def show_image(img, title='image'):   plt.imshow(img)   plt.title(title)   plt.show()"},
    "displays a picture ": {"nl":"displays a picture ","code":"def show_image(img, title='image'):   plt.imshow(img)   plt.title(title)   plt.show()"},
    "a picture is shown ": {"nl":"a picture is shown ","code":"def show_image(img, title='image'):   plt.imshow(img)   plt.title(title)   plt.show()"},
    "show image and mask in one figure with transparent background": {"nl":"show image and mask in one figure with transparent background","code":"def show_image_and_mask_transparent(img, mask):   plt.figure(figsize=(15, 15))   plt.subplot(121)   plt.imshow(img)   plt.imshow(mask, alpha=0.7)   plt.show()"},
    "display picture and mask together in a single figure on a transparent backdrop": {"nl":"display picture and mask together in a single figure on a transparent backdrop","code":"def show_image_and_mask_transparent(img, mask):   plt.figure(figsize=(15, 15))   plt.subplot(121)   plt.imshow(img)   plt.imshow(mask, alpha=0.7)   plt.show()"},
    "translucent backdrop with picture and mask combined into one figure ": {"nl":"translucent backdrop with picture and mask combined into one figure ","code":"def show_image_and_mask_transparent(img, mask):   plt.figure(figsize=(15, 15))   plt.subplot(121)   plt.imshow(img)   plt.imshow(mask, alpha=0.7)   plt.show()"},
    "one figure with a transparent backdrop that combines the picture with the mask. ": {"nl":"one figure with a transparent backdrop that combines the picture with the mask. ","code":"def show_image_and_mask_transparent(img, mask):   plt.figure(figsize=(15, 15))   plt.subplot(121)   plt.imshow(img)   plt.imshow(mask, alpha=0.7)   plt.show()"},
    "present picture and mask in a single figure with a translucent backdrop. ": {"nl":"present picture and mask in a single figure with a translucent backdrop. ","code":"def show_image_and_mask_transparent(img, mask):   plt.figure(figsize=(15, 15))   plt.subplot(121)   plt.imshow(img)   plt.imshow(mask, alpha=0.7)   plt.show()"},
    "show image and prediction and label in one figure": {"nl":"show image and prediction and label in one figure","code":"def show_image_and_pred_and_label(img, pred, label):   plt.figure(figsize=(15, 15))   plt.subplot(131)   plt.imshow(img)   plt.subplot(132)   plt.imshow(pred)   plt.subplot(133)   plt.imshow(label)   plt.show()\n"},
    "display image, prediction, and label in a single figure": {"nl":"display image, prediction, and label in a single figure","code":"def show_image_and_pred_and_label(img, pred, label):   plt.figure(figsize=(15, 15))   plt.subplot(131)   plt.imshow(img)   plt.subplot(132)   plt.imshow(pred)   plt.subplot(133)   plt.imshow(label)   plt.show()\n"},
    "display the image, prediction, and caption in a single figure ": {"nl":"display the image, prediction, and caption in a single figure ","code":"def show_image_and_pred_and_label(img, pred, label):   plt.figure(figsize=(15, 15))   plt.subplot(131)   plt.imshow(img)   plt.subplot(132)   plt.imshow(pred)   plt.subplot(133)   plt.imshow(label)   plt.show()\n"},
    "show image, prediction, and label in one picture ": {"nl":"show image, prediction, and label in one picture ","code":"def show_image_and_pred_and_label(img, pred, label):   plt.figure(figsize=(15, 15))   plt.subplot(131)   plt.imshow(img)   plt.subplot(132)   plt.imshow(pred)   plt.subplot(133)   plt.imshow(label)   plt.show()\n"},
    "show the picture, the prediction, and the label all in one picture": {"nl":"show the picture, the prediction, and the label all in one picture","code":"def show_image_and_pred_and_label(img, pred, label):   plt.figure(figsize=(15, 15))   plt.subplot(131)   plt.imshow(img)   plt.subplot(132)   plt.imshow(pred)   plt.subplot(133)   plt.imshow(label)   plt.show()\n"},
    "use just one figure to illustrate both image and prediction and label ": {"nl":"use just one figure to illustrate both image and prediction and label ","code":"def show_image_and_pred_and_label(img, pred, label):   plt.figure(figsize=(15, 15))   plt.subplot(131)   plt.imshow(img)   plt.subplot(132)   plt.imshow(pred)   plt.subplot(133)   plt.imshow(label)   plt.show()\n"},
    "image and prediction labelled in a single diagram ": {"nl":"image and prediction labelled in a single diagram ","code":"def show_image_and_pred_and_label(img, pred, label):   plt.figure(figsize=(15, 15))   plt.subplot(131)   plt.imshow(img)   plt.subplot(132)   plt.imshow(pred)   plt.subplot(133)   plt.imshow(label)   plt.show()\n"},
    "save an image": {"nl":"save an image","code":"def save_image(path, image):   cv2.imwrite(path, image)"},
    "save a picture ": {"nl":"save a picture ","code":"def save_image(path, image):   cv2.imwrite(path, image)"},
    "save a photo ": {"nl":"save a photo ","code":"def save_image(path, image):   cv2.imwrite(path, image)"},
    "convert an image to gray scale": {"nl":"convert an image to gray scale","code":"def convert_to_gray(image):   return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)"},
    "a grayscale conversion of a picture ": {"nl":"a grayscale conversion of a picture ","code":"def convert_to_gray(image):   return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)"},
    "a grayscale picture conversion ": {"nl":"a grayscale picture conversion ","code":"def convert_to_gray(image):   return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)"},
    "picture grayscale conversion ": {"nl":"picture grayscale conversion ","code":"def convert_to_gray(image):   return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)"},
    "grayscale an image ": {"nl":"grayscale an image ","code":"def convert_to_gray(image):   return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)"},
    "grayscale picture conversion ": {"nl":"grayscale picture conversion ","code":"def convert_to_gray(image):   return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)"},
    "Grayscale a picture ": {"nl":"Grayscale a picture ","code":"def convert_to_gray(image):   return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)"},
    "convert an image to hsv": {"nl":"convert an image to hsv","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "hsv conversion of a picture": {"nl":"hsv conversion of a picture","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "picture to hsv conversion ": {"nl":"picture to hsv conversion ","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "a picture to hsv conversion ": {"nl":"a picture to hsv conversion ","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "convert a picture to hsv ": {"nl":"convert a picture to hsv ","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "hsv image conversion ": {"nl":"hsv image conversion ","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "Convert a picture to hsv format": {"nl":"Convert a picture to hsv format","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "Image to hsv conversion ": {"nl":"Image to hsv conversion ","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "Image conversion to hsv ": {"nl":"Image conversion to hsv ","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "change a picture to hsv format ": {"nl":"change a picture to hsv format ","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "change an image to hsv ": {"nl":"change an image to hsv ","code":"def convert_to_hsv(image):   return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "image-to-hsv ": {"nl":"image-to-hsv ","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "picture-to-hsv converter ": {"nl":"picture-to-hsv converter ","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "You may convert a picture to hsv format": {"nl":"You may convert a picture to hsv format","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "converting a picture to hsv format": {"nl":"converting a picture to hsv format","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "Perform the conversion of a picture to hsv format": {"nl":"Perform the conversion of a picture to hsv format","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "hsv image converter ": {"nl":"hsv image converter ","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "Image to HSV ": {"nl":"Image to HSV ","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "image to hsv ": {"nl":"image to hsv ","code":"def convert_to_hsv(image):      # convert an image to hsv   # :param image: the image to convert   # :return: the hsv image      return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)"},
    "Convert image to lab": {"nl":"Convert image to lab","code":"def to_lab(image):   lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)   return lab_image"},
    "lab conversion of a picture ": {"nl":"lab conversion of a picture ","code":"def to_lab(image): #Conversion b/w rgb and lab using skimage return color.rgb2lab(image)"},
    "a lab conversion of a picture ": {"nl":"a lab conversion of a picture ","code":"def to_lab(image): #Conversion b/w rgb and lab using skimage return color.rgb2lab(image)"},
    "picture to lab conversion ": {"nl":"picture to lab conversion ","code":"def to_lab(image): #Conversion b/w rgb and lab using skimage return color.rgb2lab(image)"},
    "lab picture conversion ": {"nl":"lab picture conversion ","code":"def to_lab(image): #Conversion b/w rgb and lab using skimage return color.rgb2lab(image)"},
    "convert a picture to lab ": {"nl":"convert a picture to lab ","code":"def to_lab(image): #Conversion b/w rgb and lab using skimage return color.rgb2lab(image)"},
    "lab format picture conversion ": {"nl":"lab format picture conversion ","code":"def to_lab(image): #Conversion b/w rgb and lab using skimage return color.rgb2lab(image)"},
    "convert a picture to lab format ": {"nl":"convert a picture to lab format ","code":"def to_lab(image): #Conversion b/w rgb and lab using skimage return color.rgb2lab(image)"},
    "convert an image to a lab ": {"nl":"convert an image to a lab ","code":"def to_lab(image): #Conversion b/w rgb and lab using skimage return color.rgb2lab(image)"},
    "convert an image to lab format ": {"nl":"convert an image to lab format ","code":"def to_lab(image): #Conversion b/w rgb and lab using skimage return color.rgb2lab(image)"},
    "transform a picture into a lab ": {"nl":"transform a picture into a lab ","code":"def to_lab(image): #Conversion b/w rgb and lab using skimage return color.rgb2lab(image)"},
    "picture to lab format conversion ": {"nl":"picture to lab format conversion ","code":"def to_lab(image): #Conversion b/w rgb and lab using skimage return color.rgb2lab(image)"},
    "converting a picture to lab format ": {"nl":"converting a picture to lab format ","code":"def to_lab(image): #Conversion b/w rgb and lab using skimage return color.rgb2lab(image)"},
    "the process of converting a picture to lab format": {"nl":"the process of converting a picture to lab format","code":"def to_lab(image): #Conversion b/w rgb and lab using skimage return color.rgb2lab(image)"},
    "image-to-lab ": {"nl":"image-to-lab ","code":"def to_lab(image): #Conversion b/w rgb and lab using skimage return color.rgb2lab(image)"},
    "image2lab ": {"nl":"image2lab ","code":"def to_lab(image): #Conversion b/w rgb and lab using skimage return color.rgb2lab(image)"},
    "merge channels into an image": {"nl":"merge channels into an image","code":"def merge_image(channels):   return cv2.merge(channels)"},
    "combine channels into a single image ": {"nl":"combine channels into a single image ","code":"def merge_image(channels):   return cv2.merge(channels)"},
    "get a specific channel from an image": {"nl":"get a specific channel from an image","code":"def get_channel(image, channel):   return image[:, :, channel]"},
    "obtain a specific image channel ": {"nl":"obtain a specific image channel ","code":"def get_channel(image, channel):   return image[:, :, channel]"},
    "get the histogram of a specific channel": {"nl":"get the histogram of a specific channel","code":"def get_channel_histogram(image, channel, mask=None):   return cv2.calcHist([image], [channel], mask, [256], [0, 256])"},
    "obtain a specific channel's histogram ": {"nl":"obtain a specific channel's histogram ","code":"def get_channel_histogram(image, channel, mask=None):   return cv2.calcHist([image], [channel], mask, [256], [0, 256])"},
    "get the histogram of all channels": {"nl":"get the histogram of all channels","code":"def get_channels_histogram(image, channels, mask=None):   histograms = []   for channel in channels:       histograms.append(get_channel_histogram(image, channel, mask))   return histograms"},
    "obtain a histogram of all channels ": {"nl":"obtain a histogram of all channels ","code":"def get_channels_histogram(image, channels, mask=None):   histograms = []   for channel in channels:       histograms.append(get_channel_histogram(image, channel, mask))   return histograms"},
    "obtain a channel-by-channel histogram ": {"nl":"obtain a channel-by-channel histogram ","code":"def get_channels_histogram(image, channels, mask=None):   histograms = []   for channel in channels:       histograms.append(get_channel_histogram(image, channel, mask))   return histograms"},
    "assemble a histogram for each channel. ": {"nl":"assemble a histogram for each channel. ","code":"def get_channels_histogram(image, channels, mask=None):   histograms = []   for channel in channels:       histograms.append(get_channel_histogram(image, channel, mask))   return histograms"},
    "get a channel-by-channel histogram ": {"nl":"get a channel-by-channel histogram ","code":"def get_channels_histogram(image, channels, mask=None):   histograms = []   for channel in channels:       histograms.append(get_channel_histogram(image, channel, mask))   return histograms"},
    "make a histogram of all the channels ": {"nl":"make a histogram of all the channels ","code":"def get_channels_histogram(image, channels, mask=None):   histograms = []   for channel in channels:       histograms.append(get_channel_histogram(image, channel, mask))   return histograms"},
    "get a histogram of all the channels ": {"nl":"get a histogram of all the channels ","code":"def get_channels_histogram(image, channels, mask=None):   histograms = []   for channel in channels:       histograms.append(get_channel_histogram(image, channel, mask))   return histograms"},
    "get the histogram of an image": {"nl":"get the histogram of an image","code":"def get_image_histogram(image, mask=None):   return cv2.calcHist([image], [0], mask, [256], [0, 256])"},
    "obtain an image's histogram ": {"nl":"obtain an image's histogram ","code":"def get_image_histogram(image, mask=None):   return cv2.calcHist([image], [0], mask, [256], [0, 256])"},
    "retrieve an image's histogram ": {"nl":"retrieve an image's histogram ","code":"def get_image_histogram(image, mask=None):   return cv2.calcHist([image], [0], mask, [256], [0, 256])"},
    "to obtain an image's histogram ": {"nl":"to obtain an image's histogram ","code":"def get_image_histogram(image, mask=None):   return cv2.calcHist([image], [0], mask, [256], [0, 256])"},
    "discover an image's histogram ": {"nl":"discover an image's histogram ","code":"def get_image_histogram(image, mask=None):   return cv2.calcHist([image], [0], mask, [256], [0, 256])"},
    "find an image's histogram ": {"nl":"find an image's histogram ","code":"def get_image_histogram(image, mask=None):   return cv2.calcHist([image], [0], mask, [256], [0, 256])"},
    "get the cdf of all channels": {"nl":"get the cdf of all channels","code":"def get_channels_cdf(image, channels):   cdfs = []   for channel in channels:       histogram = get_channel_histogram(image, channel)       cdf = histogram.cumsum()       cdfs.append(cdf)   return cdfs"},
    "obtain the cdf for all channels ": {"nl":"obtain the cdf for all channels ","code":"def get_channels_cdf(image, channels):   cdfs = []   for channel in channels:       histogram = get_channel_histogram(image, channel)       cdf = histogram.cumsum()       cdfs.append(cdf)   return cdfs"},
    "get the cdf of an image": {"nl":"get the cdf of an image","code":"def get_image_cdf(image):   histogram = get_image_histogram(image)   cdf = histogram.cumsum()   return cdf"},
    "obtain an image's cdf ": {"nl":"obtain an image's cdf ","code":"def get_image_cdf(image):   histogram = get_image_histogram(image)   cdf = histogram.cumsum()   return cdf"},
    "equalize an image": {"nl":"equalize an image","code":"def equalize_image(image, channels):   cdfs = get_channels_cdf(image, channels)   equalized_image = np.copy(image)   for channel, cdf in zip(channels, cdfs):       equalized_image[:, :, channel] = cdf[image[:, :, channel]]   return equalized_image"},
    "picture equalisation ": {"nl":"picture equalisation ","code":"def equalize_image(image, channels):   cdfs = get_channels_cdf(image, channels)   equalized_image = np.copy(image)   for channel, cdf in zip(channels, cdfs):       equalized_image[:, :, channel] = cdf[image[:, :, channel]]   return equalized_image"},
    "image equivalence ": {"nl":"image equivalence ","code":"def equalize_image(image, channels):   cdfs = get_channels_cdf(image, channels)   equalized_image = np.copy(image)   for channel, cdf in zip(channels, cdfs):       equalized_image[:, :, channel] = cdf[image[:, :, channel]]   return equalized_image"},
    "Image equalisation ": {"nl":"Image equalisation ","code":"def equalize_image(image, channels):   cdfs = get_channels_cdf(image, channels)   equalized_image = np.copy(image)   for channel, cdf in zip(channels, cdfs):       equalized_image[:, :, channel] = cdf[image[:, :, channel]]   return equalized_image"},
    "threshold an image": {"nl":"threshold an image","code":"def threshold_image(image, threshold):   _, thresholded_image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)   return thresholded_image"},
    "thresholding a picture ": {"nl":"thresholding a picture ","code":"def threshold_image(image, threshold):   _, thresholded_image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)   return thresholded_image"},
    "image threshold ": {"nl":"image threshold ","code":"def threshold_image(image, threshold):   _, thresholded_image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)   return thresholded_image"},
    "a picture threshold ": {"nl":"a picture threshold ","code":"def threshold_image(image, threshold):   _, thresholded_image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)   return thresholded_image"},
    "thresholding an image ": {"nl":"thresholding an image ","code":"def threshold_image(image, threshold):   _, thresholded_image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)   return thresholded_image"},
    "threshold a photograph ": {"nl":"threshold a photograph ","code":"def threshold_image(image, threshold):   _, thresholded_image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)   return thresholded_image"},
    "threshold a picture ": {"nl":"threshold a picture ","code":"def threshold_image(image, threshold):   _, thresholded_image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)   return thresholded_image"},
    "threshold an image adaptive": {"nl":"threshold an image adaptive","code":"def threshold_image_adaptive(image, block_size, c):   return cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, block_size, c)"},
    "threshold an image OTSU": {"nl":"threshold an image OTSU","code":"def threshold_image_otsu(image):   return cv2.threshold(image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]"},
    "apply morphological transform to an image": {"nl":"apply morphological transform to an image","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "apply morphological transform on an image ": {"nl":"apply morphological transform on an image ","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "image morphological transformation ": {"nl":"image morphological transformation ","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "apply morphological transformation to a picture ": {"nl":"apply morphological transformation to a picture ","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "the transformation of a picture using morphology ": {"nl":"the transformation of a picture using morphology ","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "perform morphological transformation on an image": {"nl":"perform morphological transformation on an image","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "alter an image using morphological operations ": {"nl":"alter an image using morphological operations ","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "morphologically change an image ": {"nl":"morphologically change an image ","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "perform morphological transformation on a picture ": {"nl":"perform morphological transformation on a picture ","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "morphological transformation is used on an image": {"nl":"morphological transformation is used on an image","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "transform an image using morphology ": {"nl":"transform an image using morphology ","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "Put an image through a morphological transformation": {"nl":"Put an image through a morphological transformation","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "morphologically modify an image before using it": {"nl":"morphologically modify an image before using it","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "A morphological transformation should be applied to an image": {"nl":"A morphological transformation should be applied to an image","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "change an image using morphological methods": {"nl":"change an image using morphological methods","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "morph image ": {"nl":"morph image ","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "an image can be transformed using morphological methods ": {"nl":"an image can be transformed using morphological methods ","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "an image can be transformed using morphological techniques ": {"nl":"an image can be transformed using morphological techniques ","code":"def morphological_transform(image, kernel, morph_op):   return cv2.morphologyEx(image, morph_op, kernel)"},
    "erode the image": {"nl":"erode the image","code":"def img_erode(img, kernel, iterations):   return cv2.erode(img, kernel, iterations = iterations)"},
    "deteriorate the image ": {"nl":"deteriorate the image ","code":"def img_erode(img, kernel, iterations):   return cv2.erode(img, kernel, iterations = iterations)"},
    "degrade the image ": {"nl":"degrade the image ","code":"def img_erode(img, kernel, iterations):   return cv2.erode(img, kernel, iterations = iterations)"},
    "destroy the image ": {"nl":"destroy the image ","code":"def img_erode(img, kernel, iterations):   return cv2.erode(img, kernel, iterations = iterations)"},
    "dilate the image": {"nl":"dilate the image","code":"def img_dilate(img, kernel, iterations):   return cv2.dilate(img, kernel, iterations = iterations)"},
    "canny edge detection": {"nl":"canny edge detection","code":"def img_canny(img, low_threshold, high_threshold):   return cv2.Canny(img, low_threshold, high_threshold)"},
    "sobel edge detection": {"nl":"sobel edge detection","code":"def img_sobel(img, x, y, kernel_size):   return cv2.Sobel(img, cv2.CV_64F, x, y, ksize = kernel_size)"},
    "laplacian edge detection": {"nl":"laplacian edge detection","code":"def img_laplacian(img):   return cv2.Laplacian(img, cv2.CV_64F)"},
    "edge detection using laplacian ": {"nl":"edge detection using laplacian ","code":"def img_laplacian(img):   return cv2.Laplacian(img, cv2.CV_64F)"},
    "Laplacian edge recognition ": {"nl":"Laplacian edge recognition ","code":"def img_laplacian(img):   return cv2.Laplacian(img, cv2.CV_64F)"},
    "Laplacian edge detection ": {"nl":"Laplacian edge detection ","code":"def img_laplacian(img):   return cv2.Laplacian(img, cv2.CV_64F)"},
    "median blur filter": {"nl":"median blur filter","code":"def img_medianBlur(img, kernel_size):   return cv2.medianBlur(img, kernel_size)"},
    "filter for a median blur ": {"nl":"filter for a median blur ","code":"def img_medianBlur(img, kernel_size):   return cv2.medianBlur(img, kernel_size)"},
    "Use a median blur filter": {"nl":"Use a median blur filter","code":"def img_medianBlur(img, kernel_size):   return cv2.medianBlur(img, kernel_size)"},
    "Create a median blur filter": {"nl":"Create a median blur filter","code":"def img_medianBlur(img, kernel_size):   return cv2.medianBlur(img, kernel_size)"},
    "bilateral filter": {"nl":"bilateral filter","code":"def img_bilateralFilter(img, d, sigmaColor, sigmaSpace):   return cv2.bilateralFilter(img, d, sigmaColor, sigmaSpace)"},
    "weighted sum of two images": {"nl":"weighted sum of two images","code":"def img_addWeighted(img1, w1, img2, w2, gama):   return cv2.addWeighted(img1, w1, img2, w2, gama)"},
    "weighted sum of two photos ": {"nl":"weighted sum of two photos ","code":"def img_addWeighted(img1, w1, img2, w2, gama):   return cv2.addWeighted(img1, w1, img2, w2, gama)"},
    "two photos combined, weighted ": {"nl":"two photos combined, weighted ","code":"def img_addWeighted(img1, w1, img2, w2, gama):   return cv2.addWeighted(img1, w1, img2, w2, gama)"},
    "find contours": {"nl":"find contours","code":"def img_findContours(img, mode, method):   return cv2.findContours(img, mode, method)"},
    "locate contours ": {"nl":"locate contours ","code":"def img_findContours(img, mode, method):   return cv2.findContours(img, mode, method)"},
    "look for contours ": {"nl":"look for contours ","code":"def img_findContours(img, mode, method):   return cv2.findContours(img, mode, method)"},
    "Identify contours ": {"nl":"Identify contours ","code":"def img_findContours(img, mode, method):   return cv2.findContours(img, mode, method)"},
    "discover contours ": {"nl":"discover contours ","code":"def img_findContours(img, mode, method):   return cv2.findContours(img, mode, method)"},
    "draw contours": {"nl":"draw contours","code":"def img_drawContours(img, contours, contourIdx, color, thickness):   return cv2.drawContours(img, contours, contourIdx, color, thickness)"},
    "make contours ": {"nl":"make contours ","code":"def img_drawContours(img, contours, contourIdx, color, thickness):   return cv2.drawContours(img, contours, contourIdx, color, thickness)"},
    "create contours ": {"nl":"create contours ","code":"def img_drawContours(img, contours, contourIdx, color, thickness):   return cv2.drawContours(img, contours, contourIdx, color, thickness)"},
    "contours should be drawn ": {"nl":"contours should be drawn ","code":"def img_drawContours(img, contours, contourIdx, color, thickness):   return cv2.drawContours(img, contours, contourIdx, color, thickness)"},
    "sketch contours ": {"nl":"sketch contours ","code":"def img_drawContours(img, contours, contourIdx, color, thickness):   return cv2.drawContours(img, contours, contourIdx, color, thickness)"},
    "produce contours ": {"nl":"produce contours ","code":"def img_drawContours(img, contours, contourIdx, color, thickness):   return cv2.drawContours(img, contours, contourIdx, color, thickness)"},
    "calculate the contour area": {"nl":"calculate the contour area","code":"def img_contourArea(contours):   return cv2.contourArea(contours)\n"},
    "determine the contour area. ": {"nl":"determine the contour area. ","code":"def img_contourArea(contours):   return cv2.contourArea(contours)\n"},
    "figure out the contour area. ": {"nl":"figure out the contour area. ","code":"def img_contourArea(contours):   return cv2.contourArea(contours)\n"},
    "compute the contour area ": {"nl":"compute the contour area ","code":"def img_contourArea(contours):   return cv2.contourArea(contours)\n"},
    "calculate the bounding rectangle": {"nl":"calculate the bounding rectangle","code":"def img_boundingRect(contours):   return cv2.boundingRect(contours)"},
    "determine the boundary rectangle ": {"nl":"determine the boundary rectangle ","code":"def img_boundingRect(contours):   return cv2.boundingRect(contours)"},
    "compute the bounding rectangle ": {"nl":"compute the bounding rectangle ","code":"def img_boundingRect(contours):   return cv2.boundingRect(contours)"},
    "find the enclosing rectangle ": {"nl":"find the enclosing rectangle ","code":"def img_boundingRect(contours):   return cv2.boundingRect(contours)"},
    "Identify the boundary rectangle": {"nl":"Identify the boundary rectangle","code":"def img_boundingRect(contours):   return cv2.boundingRect(contours)"},
    "determine the bounded rectangle": {"nl":"determine the bounded rectangle","code":"def img_boundingRect(contours):   return cv2.boundingRect(contours)"},
    "calculate the min area rectangle": {"nl":"calculate the min area rectangle","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "determine the minimum area rectangle": {"nl":"determine the minimum area rectangle","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "the minimum area rectangle, please ": {"nl":"the minimum area rectangle, please ","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "the minimum-area rectangle calculation ": {"nl":"the minimum-area rectangle calculation ","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "Determine the minimum area rectangle": {"nl":"Determine the minimum area rectangle","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "compute the minimum area rectangle ": {"nl":"compute the minimum area rectangle ","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "determine the minimum area rectangle ": {"nl":"determine the minimum area rectangle ","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "determine the minimum rectangle area": {"nl":"determine the minimum rectangle area","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "compute the smallest rectangle's area": {"nl":"compute the smallest rectangle's area","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "determine the smallest possible rectangle's surface area ": {"nl":"determine the smallest possible rectangle's surface area ","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "Calculate the smallest possible rectangular area ": {"nl":"Calculate the smallest possible rectangular area ","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "Find the rectangle with the smallest possible area": {"nl":"Find the rectangle with the smallest possible area","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "Determine the minimum rectangle's area": {"nl":"Determine the minimum rectangle's area","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "Find the rectangle with the smallest possible area and calculate it": {"nl":"Find the rectangle with the smallest possible area and calculate it","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "find the rectangle with the smallest possible area": {"nl":"find the rectangle with the smallest possible area","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "minimum rectangular area ": {"nl":"minimum rectangular area ","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "rectangle min area ": {"nl":"rectangle min area ","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "min rectangular area ": {"nl":"min rectangular area ","code":"def img_minAreaRect(contours):   return cv2.minAreaRect(contours)"},
    "calculate the moments": {"nl":"calculate the moments","code":"def img_moments(contours):   return cv2.moments(contours)"},
    "compute the moments ": {"nl":"compute the moments ","code":"def img_moments(contours):   return cv2.moments(contours)"},
    "determine the moments ": {"nl":"determine the moments ","code":"def img_moments(contours):   return cv2.moments(contours)"},
    "Determine the moments ": {"nl":"Determine the moments ","code":"def img_moments(contours):   return cv2.moments(contours)"},
    "the moments; compute": {"nl":"the moments; compute","code":"def img_moments(contours):   return cv2.moments(contours)"},
    "calculate the contour perimeter": {"nl":"calculate the contour perimeter","code":"def img_contourPerimeter(contours):   return cv2.arcLength(contours, True)"},
    "the contour perimeter to be calculated ": {"nl":"the contour perimeter to be calculated ","code":"def img_contourPerimeter(contours):   return cv2.arcLength(contours, True)"},
    "find the contour perimeter": {"nl":"find the contour perimeter","code":"def img_contourPerimeter(contours):   return cv2.arcLength(contours, True)"},
    "Do the contour perimeter calculation": {"nl":"Do the contour perimeter calculation","code":"def img_contourPerimeter(contours):   return cv2.arcLength(contours, True)"},
    "determine the contour perimeter": {"nl":"determine the contour perimeter","code":"def img_contourPerimeter(contours):   return cv2.arcLength(contours, True)"},
    "compute the contour perimeter ": {"nl":"compute the contour perimeter ","code":"def img_contourPerimeter(contours):   return cv2.arcLength(contours, True)"},
    "compute the perimeter of the contour ": {"nl":"compute the perimeter of the contour ","code":"def img_contourPerimeter(contours):   return cv2.arcLength(contours, True)"},
    "the perimeter of the contour ": {"nl":"the perimeter of the contour ","code":"def img_contourPerimeter(contours):   return cv2.arcLength(contours, True)"},
    "calculate the perimeter of the contour": {"nl":"calculate the perimeter of the contour","code":"def img_contourPerimeter(contours):   return cv2.arcLength(contours, True)"},
    "Determine the perimeter of the contour": {"nl":"Determine the perimeter of the contour","code":"def img_contourPerimeter(contours):   return cv2.arcLength(contours, True)"},
    "approximate the contour": {"nl":"approximate the contour","code":"def img_approxPolyDP(contours, epsilon, closed):   return cv2.approxPolyDP(contours, epsilon, closed)\n"},
    "a close approximation of the contour ": {"nl":"a close approximation of the contour ","code":"def img_approxPolyDP(contours, epsilon, closed):   return cv2.approxPolyDP(contours, epsilon, closed)\n"},
    "approximating the shape of the contour ": {"nl":"approximating the shape of the contour ","code":"def img_approxPolyDP(contours, epsilon, closed):   return cv2.approxPolyDP(contours, epsilon, closed)\n"},
    "roughly estimate the contour ": {"nl":"roughly estimate the contour ","code":"def img_approxPolyDP(contours, epsilon, closed):   return cv2.approxPolyDP(contours, epsilon, closed)\n"},
    "Estimate the contour": {"nl":"Estimate the contour","code":"def img_approxPolyDP(contours, epsilon, closed):   return cv2.approxPolyDP(contours, epsilon, closed)\n"},
    "a rough idea of the curve ": {"nl":"a rough idea of the curve ","code":"def img_approxPolyDP(contours, epsilon, closed):   return cv2.approxPolyDP(contours, epsilon, closed)\n"},
    "the contour's approximation ": {"nl":"the contour's approximation ","code":"def img_approxPolyDP(contours, epsilon, closed):   return cv2.approxPolyDP(contours, epsilon, closed)\n"},
    "contour approximation ": {"nl":"contour approximation ","code":"def img_approxPolyDP(contours, epsilon, closed):   return cv2.approxPolyDP(contours, epsilon, closed)\n"},
    "convex hull on contours": {"nl":"convex hull on contours","code":"def img_convexHull(contours):   return cv2.convexHull(contours)"},
    "Convex hull on contours ": {"nl":"Convex hull on contours ","code":"def img_convexHull(contours):   return cv2.convexHull(contours)"},
    "contour convex hull ": {"nl":"contour convex hull ","code":"def img_convexHull(contours):   return cv2.convexHull(contours)"},
    "Convex Hull": {"nl":"Convex Hull","code":"def img_convexHull(contours):   return cv2.convexHull(contours)"},
    "convexity defects": {"nl":"convexity defects","code":"def img_convexityDefects(contours):   return cv2.convexityDefects(contours)"},
    "point polygon test": {"nl":"point polygon test","code":"def img_pointPolygonTest(contours):   return cv2.pointPolygonTest(contours)"},
    "polygon point test ": {"nl":"polygon point test ","code":"def img_pointPolygonTest(contours):   return cv2.pointPolygonTest(contours)"},
    "Test of point polygons ": {"nl":"Test of point polygons ","code":"def img_pointPolygonTest(contours):   return cv2.pointPolygonTest(contours)"},
    "the point polygon test ": {"nl":"the point polygon test ","code":"def img_pointPolygonTest(contours):   return cv2.pointPolygonTest(contours)"},
    "match shapes": {"nl":"match shapes","code":"def img_matchShapes(contours):   return cv2.matchShapes(contours)"},
    "Hough lines detection": {"nl":"Hough lines detection","code":"def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):   return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"},
    "The detection of Hough lines ": {"nl":"The detection of Hough lines ","code":"def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):   return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"},
    "The search for Hough lines ": {"nl":"The search for Hough lines ","code":"def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):   return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"},
    "The discovery of the Hough lines ": {"nl":"The discovery of the Hough lines ","code":"def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):   return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"},
    "detection of Hough lines ": {"nl":"detection of Hough lines ","code":"def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):   return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"},
    "Finding Hough lines ": {"nl":"Finding Hough lines ","code":"def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):   return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"},
    "Recognition of Hough lines ": {"nl":"Recognition of Hough lines ","code":"def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):   return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"},
    "Detection of Hough lines ": {"nl":"Detection of Hough lines ","code":"def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):   return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"},
    "Detecting Hough lines ": {"nl":"Detecting Hough lines ","code":"def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):   return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"},
    "Hough lines finder ": {"nl":"Hough lines finder ","code":"def img_HoughLines(img, rho, theta, threshold, min_line_length, max_line_gap):   return cv2.HoughLines(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"},
    "Hough lines P detection": {"nl":"Hough lines P detection","code":"def img_HoughLinesP(img, rho, theta, threshold, min_line_length, max_line_gap):   return cv2.HoughLinesP(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"},
    "P detection with Hough lines ": {"nl":"P detection with Hough lines ","code":"def img_HoughLinesP(img, rho, theta, threshold, min_line_length, max_line_gap):   return cv2.HoughLinesP(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"},
    "Finding Hough lines P ": {"nl":"Finding Hough lines P ","code":"def img_HoughLinesP(img, rho, theta, threshold, min_line_length, max_line_gap):   return cv2.HoughLinesP(img, rho, theta, threshold, np.array([]), min_line_length, max_line_gap)"},
    "Hough circles detection": {"nl":"Hough circles detection","code":"def img_HoughCircles(img, method, dp, minDist, param1, param2, minRadius, max_radius):   return cv2.HoughCircles(img, method, dp, minDist, param1, param2, minRadius, max_radius)\n"},
    "blob detection": {"nl":"blob detection","code":"def img_blobDetection(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio):   return cv2.SimpleBlobDetector(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio)"},
    "detection of blobs ": {"nl":"detection of blobs ","code":"def img_blobDetection(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio):   return cv2.SimpleBlobDetector(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio)"},
    "Detection of blobs ": {"nl":"Detection of blobs ","code":"def img_blobDetection(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio):   return cv2.SimpleBlobDetector(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio)"},
    "A blob detection ": {"nl":"A blob detection ","code":"def img_blobDetection(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio):   return cv2.SimpleBlobDetector(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio)"},
    "Finding blobs ": {"nl":"Finding blobs ","code":"def img_blobDetection(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio):   return cv2.SimpleBlobDetector(img, minThreshold, maxThreshold, filterByArea, minArea, maxArea, filterByCircularity, minCircularity, maxCircularity, filterByConvexity, minConvexity, maxConvexity, filterByInertia, minInertiaRatio, maxInertiaRatio)"},
    "fast feature detection": {"nl":"fast feature detection","code":"def img_fastFeatureDetector(img):   return cv2.FastFeatureDetector(img)"},
    "quickly detecting features ": {"nl":"quickly detecting features ","code":"def img_fastFeatureDetector(img):   return cv2.FastFeatureDetector(img)"},
    "rapid feature detection ": {"nl":"rapid feature detection ","code":"def img_fastFeatureDetector(img):   return cv2.FastFeatureDetector(img)"},
    "rapid recognition of features ": {"nl":"rapid recognition of features ","code":"def img_fastFeatureDetector(img):   return cv2.FastFeatureDetector(img)"},
    "rapid feature identification ": {"nl":"rapid feature identification ","code":"def img_fastFeatureDetector(img):   return cv2.FastFeatureDetector(img)"},
    "rapid identification of features ": {"nl":"rapid identification of features ","code":"def img_fastFeatureDetector(img):   return cv2.FastFeatureDetector(img)"},
    "quickly identifying features ": {"nl":"quickly identifying features ","code":"def img_fastFeatureDetector(img):   return cv2.FastFeatureDetector(img)"},
    "SIFT feature detection": {"nl":"SIFT feature detection","code":"def img_SIFT(img):   return cv2.SIFT(img)"},
    "detection of SIFT features ": {"nl":"detection of SIFT features ","code":"def img_SIFT(img):   return cv2.SIFT(img)"},
    "Finding SIFT features ": {"nl":"Finding SIFT features ","code":"def img_SIFT(img):   return cv2.SIFT(img)"},
    "Recognition of SIFT features ": {"nl":"Recognition of SIFT features ","code":"def img_SIFT(img):   return cv2.SIFT(img)"},
    "SIFT feature recognition ": {"nl":"SIFT feature recognition ","code":"def img_SIFT(img):   return cv2.SIFT(img)"},
    "SURF feature detection": {"nl":"SURF feature detection","code":"def img_SURF(img):   return cv2.SURF(img)"},
    "identification of SURF features ": {"nl":"identification of SURF features ","code":"def img_SURF(img):   return cv2.SURF(img)"},
    "Finding SURF features ": {"nl":"Finding SURF features ","code":"def img_SURF(img):   return cv2.SURF(img)"},
    "Recognizing SURF features ": {"nl":"Recognizing SURF features ","code":"def img_SURF(img):   return cv2.SURF(img)"},
    "SURF feature identification ": {"nl":"SURF feature identification ","code":"def img_SURF(img):   return cv2.SURF(img)"},
    "Detection of SURF features ": {"nl":"Detection of SURF features ","code":"def img_SURF(img):   return cv2.SURF(img)"},
    "ORB feature detection": {"nl":"ORB feature detection","code":"def img_ORB(img):   return cv2.ORB(img)"},
    "identification of ORB features ": {"nl":"identification of ORB features ","code":"def img_ORB(img):   return cv2.ORB(img)"},
    "Finding ORB features ": {"nl":"Finding ORB features ","code":"def img_ORB(img):   return cv2.ORB(img)"},
    "Discovering ORB features ": {"nl":"Discovering ORB features ","code":"def img_ORB(img):   return cv2.ORB(img)"},
    "ORB feature recognition ": {"nl":"ORB feature recognition ","code":"def img_ORB(img):   return cv2.ORB(img)"},
    "BRIEF feature descriptor": {"nl":"BRIEF feature descriptor","code":"def img_brief(img):   return cv2.BRIEF(img)"},
    "Use BRIEF feature descriptor": {"nl":"Use BRIEF feature descriptor","code":"def img_brief(img):   return cv2.BRIEF(img)"},
    "Create BRIEF feature descriptor": {"nl":"Create BRIEF feature descriptor","code":"def img_brief(img):   return cv2.BRIEF(img)"},
    "BRISK feature descriptor": {"nl":"BRISK feature descriptor","code":"def img_brisk(img):   return cv2.BRISK(img)"},
    "Use BRISK feature descriptor": {"nl":"Use BRISK feature descriptor","code":"def img_brisk(img):   return cv2.BRISK(img)"},
    "Create BRISK feature descriptor": {"nl":"Create BRISK feature descriptor","code":"def img_brisk(img):   return cv2.BRISK(img)"},
    "FREAK feature descriptor": {"nl":"FREAK feature descriptor","code":"def img_freak(img):   return cv2.FREAK(img)"},
    "Use FREAK feature descriptor": {"nl":"Use FREAK feature descriptor","code":"def img_freak(img):   return cv2.FREAK(img)"},
    "Create FREAK feature descriptor": {"nl":"Create FREAK feature descriptor","code":"def img_freak(img):   return cv2.FREAK(img)"},
    "DAISY feature descriptor": {"nl":"DAISY feature descriptor","code":"def img_daisy(img):   return cv2.DAISY(img)"},
    "Use DAISY feature descriptor": {"nl":"Use DAISY feature descriptor","code":"def img_daisy(img):   return cv2.DAISY(img)"},
    "Create DAISY feature descriptor": {"nl":"Create DAISY feature descriptor","code":"def img_daisy(img):   return cv2.DAISY(img)"},
    "fHOG feature descriptor": {"nl":"fHOG feature descriptor","code":"def img_fhog(img):   return cv2.fHOG(img)"},
    "Use fHOG feature descriptor": {"nl":"Use fHOG feature descriptor","code":"def img_fhog(img):   return cv2.fHOG(img)"},
    "Create fHOG feature descriptor": {"nl":"Create fHOG feature descriptor","code":"def img_fhog(img):   return cv2.fHOG(img)"},
    "HOG feature descriptor": {"nl":"HOG feature descriptor","code":"def img_hog(img):   return cv2.HOGDescriptor(img)"},
    "Use HOG feature descriptor": {"nl":"Use HOG feature descriptor","code":"def img_hog(img):   return cv2.HOGDescriptor(img)"},
    "Create HOG feature descriptor": {"nl":"Create HOG feature descriptor","code":"def img_hog(img):   return cv2.HOGDescriptor(img)"},
    "resize an image to triple its shape": {"nl":"resize an image to triple its shape","code":"def resize_image(image):   return cv2.resize(image, (image.shape[1]*3, image.shape[0]*3))"},
    "enlarge a picture to thrice its size ": {"nl":"enlarge a picture to thrice its size ","code":"def resize_image(image):   return cv2.resize(image, (image.shape[1]*3, image.shape[0]*3))"},
    "triple the size of a picture ": {"nl":"triple the size of a picture ","code":"def resize_image(image):   return cv2.resize(image, (image.shape[1]*3, image.shape[0]*3))"},
    "Triple the size of an image ": {"nl":"Triple the size of an image ","code":"def resize_image(image):   return cv2.resize(image, (image.shape[1]*3, image.shape[0]*3))"},
    "picture three times its original size ": {"nl":"picture three times its original size ","code":"def resize_image(image):   return cv2.resize(image, (image.shape[1]*3, image.shape[0]*3))"},
    "three times as large as a picture ": {"nl":"three times as large as a picture ","code":"def resize_image(image):   return cv2.resize(image, (image.shape[1]*3, image.shape[0]*3))"},
    "picture size increased by three times ": {"nl":"picture size increased by three times ","code":"def resize_image(image):   return cv2.resize(image, (image.shape[1]*3, image.shape[0]*3))"},
    "resize an image to 4 times its shape\n": {"nl":"resize an image to 4 times its shape\n","code":"def resize_image(image):   image = cv2.resize(image, (0,0), fx=4, fy=4)   return image"},
    " Rotate image at an angle": {"nl":" Rotate image at an angle","code":"def rotate_image(img, angle):   rows, cols = img.shape[:2]   M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)   return cv2.warpAffine(img, M, (cols, rows))\n"},
    "picture rotation at an angle ": {"nl":"picture rotation at an angle ","code":"def rotate_image(img, angle):   rows, cols = img.shape[:2]   M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)   return cv2.warpAffine(img, M, (cols, rows))\n"},
    "Picture rotated at an angle": {"nl":"Picture rotated at an angle","code":"def rotate_image(img, angle):   rows, cols = img.shape[:2]   M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)   return cv2.warpAffine(img, M, (cols, rows))\n"},
    "Image should be rotated at an angle": {"nl":"Image should be rotated at an angle","code":"def rotate_image(img, angle):   rows, cols = img.shape[:2]   M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)   return cv2.warpAffine(img, M, (cols, rows))\n"},
    "Rotate picture at an angle": {"nl":"Rotate picture at an angle","code":"def rotate_image(img, angle):   rows, cols = img.shape[:2]   M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)   return cv2.warpAffine(img, M, (cols, rows))\n"},
    "The picture may be rotated at an angle": {"nl":"The picture may be rotated at an angle","code":"def rotate_image(img, angle):   rows, cols = img.shape[:2]   M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)   return cv2.warpAffine(img, M, (cols, rows))\n"},
    "Image rotation ": {"nl":"Image rotation ","code":"def rotate_image(img, angle):   rows, cols = img.shape[:2]   M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1)   return cv2.warpAffine(img, M, (cols, rows))\n"},
    " Flip an image horizontally": {"nl":" Flip an image horizontally","code":"def flip_image_horizontally(img, axis=1):   if axis == 0:       img = img[:,:,::-1]       return img   else:       img = img[:,::-1,:]       return img"},
    "Flip a picture horizontally": {"nl":"Flip a picture horizontally","code":"def flip_image_horizontally(img, axis=1):   if axis == 0:       img = img[:,:,::-1]       return img   else:       img = img[:,::-1,:]       return img"},
    "Image flipping horizontally": {"nl":"Image flipping horizontally","code":"def flip_image_horizontally(img, axis=1):   if axis == 0:       img = img[:,:,::-1]       return img   else:       img = img[:,::-1,:]       return img"},
    "Flip a picture over horizontally": {"nl":"Flip a picture over horizontally","code":"def flip_image_horizontally(img, axis=1):   if axis == 0:       img = img[:,:,::-1]       return img   else:       img = img[:,::-1,:]       return img"},
    "Image reversal ": {"nl":"Image reversal ","code":"def flip_image_horizontally(img, axis=1):   if axis == 0:       img = img[:,:,::-1]       return img   else:       img = img[:,::-1,:]       return img"},
    "Add noise to the image": {"nl":"Add noise to the image","code":"def add_noise(image,probability):   output = np.zeros(image.shape,np.uint8)   thres = 1 - probability   for i in range(image.shape[0]):       for j in range(image.shape[1]):           rdn = random.random()           if rdn < probability:               output[i][j] = 0           elif rdn > thres:               output[i][j] = 255           else:               output[i][j] = image[i][j]   return output"},
    "Make the image noisier": {"nl":"Make the image noisier","code":"def add_noise(image,probability):   output = np.zeros(image.shape,np.uint8)   thres = 1 - probability   for i in range(image.shape[0]):       for j in range(image.shape[1]):           rdn = random.random()           if rdn < probability:               output[i][j] = 0           elif rdn > thres:               output[i][j] = 255           else:               output[i][j] = image[i][j]   return output"},
    "Make the image more noisy": {"nl":"Make the image more noisy","code":"def add_noise(image,probability):   output = np.zeros(image.shape,np.uint8)   thres = 1 - probability   for i in range(image.shape[0]):       for j in range(image.shape[1]):           rdn = random.random()           if rdn < probability:               output[i][j] = 0           elif rdn > thres:               output[i][j] = 255           else:               output[i][j] = image[i][j]   return output"},
    "Boost the image's noise level": {"nl":"Boost the image's noise level","code":"def add_noise(image,probability):   output = np.zeros(image.shape,np.uint8)   thres = 1 - probability   for i in range(image.shape[0]):       for j in range(image.shape[1]):           rdn = random.random()           if rdn < probability:               output[i][j] = 0           elif rdn > thres:               output[i][j] = 255           else:               output[i][j] = image[i][j]   return output"},
    "Remove noise from an image": {"nl":"Remove noise from an image","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "Remove noise from a photograph ": {"nl":"Remove noise from a photograph ","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "Remove noise from a picture ": {"nl":"Remove noise from a picture ","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "Remove image noise ": {"nl":"Remove image noise ","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "picture noise removal": {"nl":"picture noise removal","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "Delete the noise from a picture ": {"nl":"Delete the noise from a picture ","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "Eliminating picture noise": {"nl":"Eliminating picture noise","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "Get rid of noise in a picture ": {"nl":"Get rid of noise in a picture ","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "Take out noise from an image ": {"nl":"Take out noise from an image ","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "Eliminate noise from an image ": {"nl":"Eliminate noise from an image ","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "Eliminate unwanted noise from an image": {"nl":"Eliminate unwanted noise from an image","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "Clean up the image by removing the noise": {"nl":"Clean up the image by removing the noise","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "Noise removal ": {"nl":"Noise removal ","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "Delete image noise ": {"nl":"Delete image noise ","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "Noise-free image ": {"nl":"Noise-free image ","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "a picture's noise can be reduced or eliminated ": {"nl":"a picture's noise can be reduced or eliminated ","code":"def remove_noise(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.medianBlur(img, 5)   img = cv2.GaussianBlur(img, (5, 5), 0)   return img"},
    "Remove horizontal lines from an image": {"nl":"Remove horizontal lines from an image","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Remove vertical lines from an image": {"nl":"Remove vertical lines from an image","code":"def remove_vertical_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   vertical_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 25))   remove_vertical = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, vertical_kernel, iterations=2)   cnts = cv2.findContours(remove_vertical, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img"},
    "Remove horizontal lines from a photograph ": {"nl":"Remove horizontal lines from a photograph ","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Remove horizontal lines from a picture ": {"nl":"Remove horizontal lines from a picture ","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Remove horizontal lines from an image ": {"nl":"Remove horizontal lines from an image ","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "How to Remove Horizontal Lines from a Photo ": {"nl":"How to Remove Horizontal Lines from a Photo ","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Eliminate horizontal lines from a picture": {"nl":"Eliminate horizontal lines from a picture","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Delete horizontal lines from a photograph": {"nl":"Delete horizontal lines from a photograph","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Eliminate horizontal lines in a photograph": {"nl":"Eliminate horizontal lines in a photograph","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Get rid of horizontal lines in a picture ": {"nl":"Get rid of horizontal lines in a picture ","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Getting rid of horizontal lines in a picture": {"nl":"Getting rid of horizontal lines in a picture","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Take out horizontal lines from an image ": {"nl":"Take out horizontal lines from an image ","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Take away horizontal lines from an image ": {"nl":"Take away horizontal lines from an image ","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Take away any lines that are horizontal in an image": {"nl":"Take away any lines that are horizontal in an image","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Getting rid of horizontal lines in an image ": {"nl":"Getting rid of horizontal lines in an image ","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Take away any lines that are horizontal in a picture": {"nl":"Take away any lines that are horizontal in a picture","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Remove any lines that are horizontal from an image. ": {"nl":"Remove any lines that are horizontal from an image. ","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Picture horizontal lines removed ": {"nl":"Picture horizontal lines removed ","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Remove image horizontal lines ": {"nl":"Remove image horizontal lines ","code":"def remove_horizontal_lines(image):   img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)   img = cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Show a list of images using matplotlib in a grid with their histograms": {"nl":"Show a list of images using matplotlib in a grid with their histograms","code":"def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):   plt.figure()   for i, img in enumerate(imgs):       plt.subplot(1, len(imgs), i+1)       plt.imshow(img, cmap=cmap)       if titles is not None:           plt.title(titles[i])   plt.show()= cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Using Matplotlib, display a grid of photos with associated histograms.": {"nl":"Using Matplotlib, display a grid of photos with associated histograms.","code":"def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):   plt.figure()   for i, img in enumerate(imgs):       plt.subplot(1, len(imgs), i+1)       plt.imshow(img, cmap=cmap)       if titles is not None:           plt.title(titles[i])   plt.show()= cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Using Matplotlib, display a grid of photos along with the histograms for each one.": {"nl":"Using Matplotlib, display a grid of photos along with the histograms for each one.","code":"def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):   plt.figure()   for i, img in enumerate(imgs):       plt.subplot(1, len(imgs), i+1)       plt.imshow(img, cmap=cmap)       if titles is not None:           plt.title(titles[i])   plt.show()= cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Display the histograms of a grid of photos in a list using the Matplotlib library.": {"nl":"Display the histograms of a grid of photos in a list using the Matplotlib library.","code":"def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):   plt.figure()   for i, img in enumerate(imgs):       plt.subplot(1, len(imgs), i+1)       plt.imshow(img, cmap=cmap)       if titles is not None:           plt.title(titles[i])   plt.show()= cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Using Matplotlib, display a grid of photos together with their histograms.": {"nl":"Using Matplotlib, display a grid of photos together with their histograms.","code":"def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):   plt.figure()   for i, img in enumerate(imgs):       plt.subplot(1, len(imgs), i+1)       plt.imshow(img, cmap=cmap)       if titles is not None:           plt.title(titles[i])   plt.show()= cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Show an image using matplotlib with its histogram and cdf": {"nl":"Show an image using matplotlib with its histogram and cdf","code":"def show_image_with_histogram_and_cdf(img, title=None, cmap=None):   plt.figure()   plt.subplot(131)   plt.imshow(img, cmap=cmap)   plt.title(title)   plt.subplot(132)   plt.hist(img.ravel(), 256)   plt.subplot(133)   plt.hist(img.ravel(), 256, cumulative=True)   plt.show()    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Display a picture using the Cdfs and histogram from Matplotlib.": {"nl":"Display a picture using the Cdfs and histogram from Matplotlib.","code":"def show_image_with_histogram_and_cdf(img, title=None, cmap=None):   plt.figure()   plt.subplot(131)   plt.imshow(img, cmap=cmap)   plt.title(title)   plt.subplot(132)   plt.hist(img.ravel(), 256)   plt.subplot(133)   plt.hist(img.ravel(), 256, cumulative=True)   plt.show()    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Display an image using Matplotlib, its histogram, and CDFS": {"nl":"Display an image using Matplotlib, its histogram, and CDFS","code":"def show_image_with_histogram_and_cdf(img, title=None, cmap=None):   plt.figure()   plt.subplot(131)   plt.imshow(img, cmap=cmap)   plt.title(title)   plt.subplot(132)   plt.hist(img.ravel(), 256)   plt.subplot(133)   plt.hist(img.ravel(), 256, cumulative=True)   plt.show()    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Show an image using matplotlib with its histogram and cdf and equalized histogram": {"nl":"Show an image using matplotlib with its histogram and cdf and equalized histogram","code":"def show_image_with_histogram_and_cdf_and_equalized_histogram(img, title=None, cmap=None):   plt.figure()   plt.subplot(141)   plt.imshow(img, cmap=cmap)   plt.title(title)   plt.subplot(142)   plt.hist(img.ravel(), 256)   plt.subplot(143)   plt.hist(img.ravel(), 256, cumulative=True)   plt.subplot(144)   plt.hist(cv2.equalizeHist(img).ravel(), 256)   plt.show()"},
    "Display an image with the histogram, cdf, and equalised histogram from matplotlib.": {"nl":"Display an image with the histogram, cdf, and equalised histogram from matplotlib.","code":"def show_image_with_histogram_and_cdf_and_equalized_histogram(img, title=None, cmap=None):   plt.figure()   plt.subplot(141)   plt.imshow(img, cmap=cmap)   plt.title(title)   plt.subplot(142)   plt.hist(img.ravel(), 256)   plt.subplot(143)   plt.hist(img.ravel(), 256, cumulative=True)   plt.subplot(144)   plt.hist(cv2.equalizeHist(img).ravel(), 256)   plt.show()"},
    "Using Matplotlib, display an image with its histogram, cdf, and equalised histogram.": {"nl":"Using Matplotlib, display an image with its histogram, cdf, and equalised histogram.","code":"def show_image_with_histogram_and_cdf_and_equalized_histogram(img, title=None, cmap=None):   plt.figure()   plt.subplot(141)   plt.imshow(img, cmap=cmap)   plt.title(title)   plt.subplot(142)   plt.hist(img.ravel(), 256)   plt.subplot(143)   plt.hist(img.ravel(), 256, cumulative=True)   plt.subplot(144)   plt.hist(cv2.equalizeHist(img).ravel(), 256)   plt.show()"},
    "Define a code that takes an image, gradient orientation, and threshold min / max values.": {"nl":"Define a code that takes an image, gradient orientation, and threshold min / max values.","code":"def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   if orient == 'x':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))   if orient == 'y':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))   scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))   binary_output = np.zeros_like(scaled_sobel)   binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1   return binary_output"},
    "Create a code that accepts an image, the gradient's direction, and the threshold's minimum and maximum values.": {"nl":"Create a code that accepts an image, the gradient's direction, and the threshold's minimum and maximum values.","code":"def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   if orient == 'x':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))   if orient == 'y':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))   scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))   binary_output = np.zeros_like(scaled_sobel)   binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1   return binary_output"},
    "Create a code that accepts an image, the gradient's orientation, and the minimum and maximum values for the threshold.": {"nl":"Create a code that accepts an image, the gradient's orientation, and the minimum and maximum values for the threshold.","code":"def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   if orient == 'x':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))   if orient == 'y':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))   scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))   binary_output = np.zeros_like(scaled_sobel)   binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1   return binary_output"},
    "Create a code that accepts an image, the gradient's orientation, and the threshold's minimum and maximum values.": {"nl":"Create a code that accepts an image, the gradient's orientation, and the threshold's minimum and maximum values.","code":"def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   if orient == 'x':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))   if orient == 'y':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))   scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))   binary_output = np.zeros_like(scaled_sobel)   binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1   return binary_output"},
    "Define a code to return the magnitude of the gradient for a given sobel kernel size and threshold values": {"nl":"Define a code to return the magnitude of the gradient for a given sobel kernel size and threshold values","code":"def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   gradmag = np.sqrt(sobelx**2 + sobely**2)   scale_factor = np.max(gradmag)/255    gradmag = (gradmag/scale_factor).astype(np.uint8)    binary_output = np.zeros_like(gradmag)   binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1   return binary_output"},
    "Create a code that, given a sobel kernel size and threshold value, returns the gradient's magnitude.": {"nl":"Create a code that, given a sobel kernel size and threshold value, returns the gradient's magnitude.","code":"def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   gradmag = np.sqrt(sobelx**2 + sobely**2)   scale_factor = np.max(gradmag)/255    gradmag = (gradmag/scale_factor).astype(np.uint8)    binary_output = np.zeros_like(gradmag)   binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1   return binary_output"},
    "Create a code that returns the gradient's magnitude for a specified sobel kernel size and threshold value.": {"nl":"Create a code that returns the gradient's magnitude for a specified sobel kernel size and threshold value.","code":"def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   gradmag = np.sqrt(sobelx**2 + sobely**2)   scale_factor = np.max(gradmag)/255    gradmag = (gradmag/scale_factor).astype(np.uint8)    binary_output = np.zeros_like(gradmag)   binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1   return binary_output"},
    "Create a code that returns the gradient's magnitude given the threshold and sobel kernel sizes.": {"nl":"Create a code that returns the gradient's magnitude given the threshold and sobel kernel sizes.","code":"def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   gradmag = np.sqrt(sobelx**2 + sobely**2)   scale_factor = np.max(gradmag)/255    gradmag = (gradmag/scale_factor).astype(np.uint8)    binary_output = np.zeros_like(gradmag)   binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1   return binary_output"},
    "Define a code to threshold an image for a given range and Sobel kernel": {"nl":"Define a code to threshold an image for a given range and Sobel kernel","code":"def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))   binary_output =  np.zeros_like(absgraddir)   binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1   return binary_output"},
    "Create a code to threshold an image using a Sobel kernel and a defined range.": {"nl":"Create a code to threshold an image using a Sobel kernel and a defined range.","code":"def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))   binary_output =  np.zeros_like(absgraddir)   binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1   return binary_output"},
    "Create a thresholding code for an image using the Sobel kernel and the specified range.": {"nl":"Create a thresholding code for an image using the Sobel kernel and the specified range.","code":"def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))   binary_output =  np.zeros_like(absgraddir)   binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1   return binary_output"},
    "Create a code that thresholds a picture based on a given range and Sobel kernel.": {"nl":"Create a code that thresholds a picture based on a given range and Sobel kernel.","code":"def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))   binary_output =  np.zeros_like(absgraddir)   binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1   return binary_output"},
    "Define a code that thresholds the S-channel of HLS": {"nl":"Define a code that thresholds the S-channel of HLS","code":"def hls_select(img, thresh=(0, 255)):   s_channel = hls[:,:,2]   binary_output = np.zeros_like(s_channel)   binary_output[(s_channel > thresh[0]) & (s_channel <= thresh[1])] = 1   return binary_output"},
    "Create a code to threshold the HLS S-channel.": {"nl":"Create a code to threshold the HLS S-channel.","code":"def hls_select(img, thresh=(0, 255)):   s_channel = hls[:,:,2]   binary_output = np.zeros_like(s_channel)   binary_output[(s_channel > thresh[0]) & (s_channel <= thresh[1])] = 1   return binary_output"},
    "Establish a code that thresholds the HLS S-channel.": {"nl":"Establish a code that thresholds the HLS S-channel.","code":"def hls_select(img, thresh=(0, 255)):   s_channel = hls[:,:,2]   binary_output = np.zeros_like(s_channel)   binary_output[(s_channel > thresh[0]) & (s_channel <= thresh[1])] = 1   return binary_output"},
    "Display a grid of photos with histograms using matplotlib.": {"nl":"Display a grid of photos with histograms using matplotlib.","code":"def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):   plt.figure()   for i, img in enumerate(imgs):       plt.subplot(1, len(imgs), i+1)       plt.imshow(img, cmap=cmap)       if titles is not None:           plt.title(titles[i])   plt.show()= cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Use matplotlib to show a list of images in a grid with their histograms.": {"nl":"Use matplotlib to show a list of images in a grid with their histograms.","code":"def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):   plt.figure()   for i, img in enumerate(imgs):       plt.subplot(1, len(imgs), i+1)       plt.imshow(img, cmap=cmap)       if titles is not None:           plt.title(titles[i])   plt.show()= cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Using matplotlib, display a grid of photos with associated histograms.": {"nl":"Using matplotlib, display a grid of photos with associated histograms.","code":"def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):   plt.figure()   for i, img in enumerate(imgs):       plt.subplot(1, len(imgs), i+1)       plt.imshow(img, cmap=cmap)       if titles is not None:           plt.title(titles[i])   plt.show()= cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Display, in a grid format using matplotlib, a list of images\u00a0along with their respective histograms": {"nl":"Display, in a grid format using matplotlib, a list of images\u00a0along with their respective histograms","code":"def show_images_in_grid_with_histogram(imgs, titles=None, cmap=None):   plt.figure()   for i, img in enumerate(imgs):       plt.subplot(1, len(imgs), i+1)       plt.imshow(img, cmap=cmap)       if titles is not None:           plt.title(titles[i])   plt.show()= cv2.bitwise_not(img)   thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]   horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Display an image with its histogram and CDF using matplotlib.": {"nl":"Display an image with its histogram and CDF using matplotlib.","code":"def show_image_with_histogram_and_cdf(img, title=None, cmap=None):   plt.figure()   plt.subplot(131)   plt.imshow(img, cmap=cmap)   plt.title(title)   plt.subplot(132)   plt.hist(img.ravel(), 256)   plt.subplot(133)   plt.hist(img.ravel(), 256, cumulative=True)   plt.show()    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))   remove_horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)   cnts = cv2.findContours(remove_horizontal, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)   cnts = cnts[0] if len(cnts) == 2 else cnts[1]   for c in cnts:       cv2.drawContours(img, [c], -1, (255, 255, 255), 5)   return img\n\n\n\n"},
    "Display an image with its histogram, CDF, and equalised histogram using matplotlib.": {"nl":"Display an image with its histogram, CDF, and equalised histogram using matplotlib.","code":"def show_image_with_histogram_and_cdf_and_equalized_histogram(img, title=None, cmap=None):   plt.figure()   plt.subplot(141)   plt.imshow(img, cmap=cmap)   plt.title(title)   plt.subplot(142)   plt.hist(img.ravel(), 256)   plt.subplot(143)   plt.hist(img.ravel(), 256, cumulative=True)   plt.subplot(144)   plt.hist(cv2.equalizeHist(img).ravel(), 256)   plt.show()"},
    "Using matplotlib, display an image with its histogram, cdf, and equalised histogram.": {"nl":"Using matplotlib, display an image with its histogram, cdf, and equalised histogram.","code":"def show_image_with_histogram_and_cdf_and_equalized_histogram(img, title=None, cmap=None):   plt.figure()   plt.subplot(141)   plt.imshow(img, cmap=cmap)   plt.title(title)   plt.subplot(142)   plt.hist(img.ravel(), 256)   plt.subplot(143)   plt.hist(img.ravel(), 256, cumulative=True)   plt.subplot(144)   plt.hist(cv2.equalizeHist(img).ravel(), 256)   plt.show()"},
    "Use matplotlib to display an image with its cdf and equalised cdf.": {"nl":"Use matplotlib to display an image with its cdf and equalised cdf.","code":"def show_image_with_histogram_and_cdf_and_equalized_histogram(img, title=None, cmap=None):   plt.figure()   plt.subplot(141)   plt.imshow(img, cmap=cmap)   plt.title(title)   plt.subplot(142)   plt.hist(img.ravel(), 256)   plt.subplot(143)   plt.hist(img.ravel(), 256, cumulative=True)   plt.subplot(144)   plt.hist(cv2.equalizeHist(img).ravel(), 256)   plt.show()"},
    "Using matplotlib, display an image together with its histogram, CDF, and equalised histogram": {"nl":"Using matplotlib, display an image together with its histogram, CDF, and equalised histogram","code":"def show_image_with_histogram_and_cdf_and_equalized_histogram(img, title=None, cmap=None):   plt.figure()   plt.subplot(141)   plt.imshow(img, cmap=cmap)   plt.title(title)   plt.subplot(142)   plt.hist(img.ravel(), 256)   plt.subplot(143)   plt.hist(img.ravel(), 256, cumulative=True)   plt.subplot(144)   plt.hist(cv2.equalizeHist(img).ravel(), 256)   plt.show()"},
    "Create a code that accepts an image, gradient orientation, and min/max threshold values.": {"nl":"Create a code that accepts an image, gradient orientation, and min/max threshold values.","code":"def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   if orient == 'x':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))   if orient == 'y':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))   scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))   binary_output = np.zeros_like(scaled_sobel)   binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1   return binary_output"},
    "Define a code which accepts an image, gradient orientation, and minimum and maximum threshold values.": {"nl":"Define a code which accepts an image, gradient orientation, and minimum and maximum threshold values.","code":"def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   if orient == 'x':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))   if orient == 'y':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))   scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))   binary_output = np.zeros_like(scaled_sobel)   binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1   return binary_output"},
    "Set up a code that takes an image, the direction of the gradient, and the minimum and maximum threshold values.": {"nl":"Set up a code that takes an image, the direction of the gradient, and the minimum and maximum threshold values.","code":"def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   if orient == 'x':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))   if orient == 'y':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))   scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))   binary_output = np.zeros_like(scaled_sobel)   binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1   return binary_output"},
    "Create a code that accepts a picture, the gradient orientation, and the threshold min/max value ranges as arguments.": {"nl":"Create a code that accepts a picture, the gradient orientation, and the threshold min/max value ranges as arguments.","code":"def abs_sobel_thresh(img, orient='x', sobel_kernel=3, thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   if orient == 'x':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel))   if orient == 'y':       abs_sobel = np.absolute(cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel))   scaled_sobel = np.uint8(255*abs_sobel/np.max(abs_sobel))   binary_output = np.zeros_like(scaled_sobel)   binary_output[(scaled_sobel >= thresh[0]) & (scaled_sobel <= thresh[1])] = 1   return binary_output"},
    "Create a code that returns the gradient magnitude for a specified sobel kernel size and threshold settings.": {"nl":"Create a code that returns the gradient magnitude for a specified sobel kernel size and threshold settings.","code":"def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   gradmag = np.sqrt(sobelx**2 + sobely**2)   scale_factor = np.max(gradmag)/255    gradmag = (gradmag/scale_factor).astype(np.uint8)    binary_output = np.zeros_like(gradmag)   binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1   return binary_output"},
    "Define a code that returns the gradient's magnitude for a given sobel kernel size and threshold settings.": {"nl":"Define a code that returns the gradient's magnitude for a given sobel kernel size and threshold settings.","code":"def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   gradmag = np.sqrt(sobelx**2 + sobely**2)   scale_factor = np.max(gradmag)/255    gradmag = (gradmag/scale_factor).astype(np.uint8)    binary_output = np.zeros_like(gradmag)   binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1   return binary_output"},
    "The gradient magnitude for a particular sobel kernel size and threshold value should be defined as a code.": {"nl":"The gradient magnitude for a particular sobel kernel size and threshold value should be defined as a code.","code":"def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   gradmag = np.sqrt(sobelx**2 + sobely**2)   scale_factor = np.max(gradmag)/255    gradmag = (gradmag/scale_factor).astype(np.uint8)    binary_output = np.zeros_like(gradmag)   binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1   return binary_output"},
    "Define a code that, given the sobel kernel size and threshold values, will return the magnitude of the gradient.": {"nl":"Define a code that, given the sobel kernel size and threshold values, will return the magnitude of the gradient.","code":"def mag_thresh(img, sobel_kernel=3, mag_thresh=(0, 255)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   gradmag = np.sqrt(sobelx**2 + sobely**2)   scale_factor = np.max(gradmag)/255    gradmag = (gradmag/scale_factor).astype(np.uint8)    binary_output = np.zeros_like(gradmag)   binary_output[(gradmag >= mag_thresh[0]) & (gradmag <= mag_thresh[1])] = 1   return binary_output"},
    "Define a code and Sobel kernel to threshold a picture for a particular range.": {"nl":"Define a code and Sobel kernel to threshold a picture for a particular range.","code":"def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))   binary_output =  np.zeros_like(absgraddir)   binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1   return binary_output"},
    "Define a code to threshold an image according to a specified range and Sobel kernel.": {"nl":"Define a code to threshold an image according to a specified range and Sobel kernel.","code":"def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))   binary_output =  np.zeros_like(absgraddir)   binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1   return binary_output"},
    "Set up a code to threshold an image for a given range and Sobel kernel.": {"nl":"Set up a code to threshold an image for a given range and Sobel kernel.","code":"def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))   binary_output =  np.zeros_like(absgraddir)   binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1   return binary_output"},
    "Define a code to threshold a picture using the Sobel kernel for a certain range.": {"nl":"Define a code to threshold a picture using the Sobel kernel for a certain range.","code":"def dir_threshold(img, sobel_kernel=3, thresh=(0, np.pi/2)):   gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)   sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=sobel_kernel)   sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=sobel_kernel)   absgraddir = np.arctan2(np.absolute(sobely), np.absolute(sobelx))   binary_output =  np.zeros_like(absgraddir)   binary_output[(absgraddir >= thresh[0]) & (absgraddir <= thresh[1])] = 1   return binary_output"},
    "Create a code that defines the HLS S-channel threshold.": {"nl":"Create a code that defines the HLS S-channel threshold.","code":"def hls_select(img, thresh=(0, 255)):   s_channel = hls[:,:,2]   binary_output = np.zeros_like(s_channel)   binary_output[(s_channel > thresh[0]) & (s_channel <= thresh[1])] = 1   return binary_output"},
    "Define a thresholding code for the S-channel of HLS": {"nl":"Define a thresholding code for the S-channel of HLS","code":"def hls_select(img, thresh=(0, 255)):   s_channel = hls[:,:,2]   binary_output = np.zeros_like(s_channel)   binary_output[(s_channel > thresh[0]) & (s_channel <= thresh[1])] = 1   return binary_output"},
    "Set up a code that thresholds the S-channel of HLS.": {"nl":"Set up a code that thresholds the S-channel of HLS.","code":"def hls_select(img, thresh=(0, 255)):   s_channel = hls[:,:,2]   binary_output = np.zeros_like(s_channel)   binary_output[(s_channel > thresh[0]) & (s_channel <= thresh[1])] = 1   return binary_output"},
    "Set the threshold for the S-channel of HLS using a code.": {"nl":"Set the threshold for the S-channel of HLS using a code.","code":"def hls_select(img, thresh=(0, 255)):   s_channel = hls[:,:,2]   binary_output = np.zeros_like(s_channel)   binary_output[(s_channel > thresh[0]) & (s_channel <= thresh[1])] = 1   return binary_output"},
    "Crop the image": {"nl":"Crop the image","code":"def crop_image(image, start_row, start_col, end_row, end_col):      # Args:   #     image: image to crop   #     start_row: start row   #     start_col: start col   #     end_row: end row   #     end_col: end col   # Returns:   #     cropped image      return image[start_row:end_row, start_col:end_col]"},
    "code to crop the image": {"nl":"code to crop the image","code":"def crop_image(image, start_row, start_col, end_row, end_col):      # Args:   #     image: image to crop   #     start_row: start row   #     start_col: start col   #     end_row: end row   #     end_col: end col   # Returns:   #     cropped image      return image[start_row:end_row, start_col:end_col]"},
    "crop the photo ": {"nl":"crop the photo ","code":"def crop_image(image, start_row, start_col, end_row, end_col):      # Args:   #     image: image to crop   #     start_row: start row   #     start_col: start col   #     end_row: end row   #     end_col: end col   # Returns:   #     cropped image      return image[start_row:end_row, start_col:end_col]"},
    "crop the picture ": {"nl":"crop the picture ","code":"def crop_image(image, start_row, start_col, end_row, end_col):      # Args:   #     image: image to crop   #     start_row: start row   #     start_col: start col   #     end_row: end row   #     end_col: end col   # Returns:   #     cropped image      return image[start_row:end_row, start_col:end_col]"},
    "Image cropping": {"nl":"Image cropping","code":"def crop_image(image, start_row, start_col, end_row, end_col):      # Args:   #     image: image to crop   #     start_row: start row   #     start_col: start col   #     end_row: end row   #     end_col: end col   # Returns:   #     cropped image      return image[start_row:end_row, start_col:end_col]"},
    "The image may be resized by cropping it": {"nl":"The image may be resized by cropping it","code":"def crop_image(image, start_row, start_col, end_row, end_col):      # Args:   #     image: image to crop   #     start_row: start row   #     start_col: start col   #     end_row: end row   #     end_col: end col   # Returns:   #     cropped image      return image[start_row:end_row, start_col:end_col]"},
    "The image should be cropped": {"nl":"The image should be cropped","code":"def crop_image(image, start_row, start_col, end_row, end_col):      # Args:   #     image: image to crop   #     start_row: start row   #     start_col: start col   #     end_row: end row   #     end_col: end col   # Returns:   #     cropped image      return image[start_row:end_row, start_col:end_col]"},
    "Modify the image by cropping it": {"nl":"Modify the image by cropping it","code":"def crop_image(image, start_row, start_col, end_row, end_col):      # Args:   #     image: image to crop   #     start_row: start row   #     start_col: start col   #     end_row: end row   #     end_col: end col   # Returns:   #     cropped image      return image[start_row:end_row, start_col:end_col]"},
    "Remove unwanted parts of the picture by cropping it": {"nl":"Remove unwanted parts of the picture by cropping it","code":"def crop_image(image, start_row, start_col, end_row, end_col):      # Args:   #     image: image to crop   #     start_row: start row   #     start_col: start col   #     end_row: end row   #     end_col: end col   # Returns:   #     cropped image      return image[start_row:end_row, start_col:end_col]"},
    "Image-crop ": {"nl":"Image-crop ","code":"def crop_image(image, start_row, start_col, end_row, end_col):      # Args:   #     image: image to crop   #     start_row: start row   #     start_col: start col   #     end_row: end row   #     end_col: end col   # Returns:   #     cropped image      return image[start_row:end_row, start_col:end_col]"},
    "Image crop ": {"nl":"Image crop ","code":"def crop_image(image, start_row, start_col, end_row, end_col):      # Args:   #     image: image to crop   #     start_row: start row   #     start_col: start col   #     end_row: end row   #     end_col: end col   # Returns:   #     cropped image      return image[start_row:end_row, start_col:end_col]"},
    "Crop the picture ": {"nl":"Crop the picture ","code":"def crop_image(image, start_row, start_col, end_row, end_col):      # Args:   #     image: image to crop   #     start_row: start row   #     start_col: start col   #     end_row: end row   #     end_col: end col   # Returns:   #     cropped image      return image[start_row:end_row, start_col:end_col]"},
    "Calculate each contour's aspect ratio.": {"nl":"Calculate each contour's aspect ratio.","code":"def aspect_ratio(img):   img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(img_gray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n   for cnt in contours:       x, y, w, h = cv2.boundingRect(cnt)       aspect_ratio = float(w)/h       print(aspect_ratio)       if aspect_ratio >= 0.95 and aspect_ratio <= 1.05:           cv2.drawContours(img, [cnt], 0, (0, 255, 0), 2)       else:           cv2.drawContours(img, [cnt], 0, (0, 0, 255), 2)       return aspect_ratio"},
    "Each contour's aspect ratio should be calculated.": {"nl":"Each contour's aspect ratio should be calculated.","code":"def aspect_ratio(img):   img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(img_gray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n   for cnt in contours:       x, y, w, h = cv2.boundingRect(cnt)       aspect_ratio = float(w)/h       print(aspect_ratio)       if aspect_ratio >= 0.95 and aspect_ratio <= 1.05:           cv2.drawContours(img, [cnt], 0, (0, 255, 0), 2)       else:           cv2.drawContours(img, [cnt], 0, (0, 0, 255), 2)       return aspect_ratio"},
    "Determine each contour's aspect ratio using the formula.": {"nl":"Determine each contour's aspect ratio using the formula.","code":"def aspect_ratio(img):   img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(img_gray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n   for cnt in contours:       x, y, w, h = cv2.boundingRect(cnt)       aspect_ratio = float(w)/h       print(aspect_ratio)       if aspect_ratio >= 0.95 and aspect_ratio <= 1.05:           cv2.drawContours(img, [cnt], 0, (0, 255, 0), 2)       else:           cv2.drawContours(img, [cnt], 0, (0, 0, 255), 2)       return aspect_ratio"},
    "contour aspect ratios": {"nl":"contour aspect ratios","code":"def aspect_ratio(img):   img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)   ret, thresh = cv2.threshold(img_gray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n   for cnt in contours:       x, y, w, h = cv2.boundingRect(cnt)       aspect_ratio = float(w)/h       print(aspect_ratio)       if aspect_ratio >= 0.95 and aspect_ratio <= 1.05:           cv2.drawContours(img, [cnt], 0, (0, 255, 0), 2)       else:           cv2.drawContours(img, [cnt], 0, (0, 0, 255), 2)       return aspect_ratio"},
    "find the bounding rectangle's centre.": {"nl":"find the bounding rectangle's centre.","code":"\"def find_centre(rect):   \"\"\"\"\"\"   Find the centre of a rectangle.\n   Parameters   ----------   rect : list       A list of 4 values (x1, y1, x2, y2) defining the bounding       rectangle.\n   Returns   -------   centre : tuple       A tuple of 2 values (x, y) defining the centre of the rectangle.   \"\"\"\"\"\"   x1, y1, x2, y2 = rect   x = (x1 + x2) / 2   y = (y1 + y2) / 2   return (x, y)\""},
    "obtain the bounding rectangle's centre": {"nl":"obtain the bounding rectangle's centre","code":"\"def get_center(cnt):   x, y, w, h = cv2.boundingRect(cnt)   center = (x + w / 2, y + h / 2)\""},
    "find the centre of the rectangle that bounds": {"nl":"find the centre of the rectangle that bounds","code":"\"def get_center(cnt):   x, y, w, h = cv2.boundingRect(cnt)   center = (x + w / 2, y + h / 2)\""},
    "determine the location of the centre of the bounding rectangle.": {"nl":"determine the location of the centre of the bounding rectangle.","code":"\"def get_center(cnt):   x, y, w, h = cv2.boundingRect(cnt)   center = (x + w / 2, y + h / 2)\""},
    "Get minimum enclosing circle of a contour": {"nl":"Get minimum enclosing circle of a contour","code":"def get_min_enclosing_circle(img):   img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n   ret, thresh = cv2.threshold(img_gray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n   cnt = contours[0]\n   (x, y), radius = cv2.minEnclosingCircle(cnt)   center = (int(x), int(y))   radius = int(radius)   return center, radius"},
    "Get a contour's smallest possible enclosing circle": {"nl":"Get a contour's smallest possible enclosing circle","code":"def get_min_enclosing_circle(img):   img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n   ret, thresh = cv2.threshold(img_gray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n   cnt = contours[0]\n   (x, y), radius = cv2.minEnclosingCircle(cnt)   center = (int(x), int(y))   radius = int(radius)   return center, radius"},
    "Get the contour's smallest enclosing circle.": {"nl":"Get the contour's smallest enclosing circle.","code":"def get_min_enclosing_circle(img):   img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n   ret, thresh = cv2.threshold(img_gray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n   cnt = contours[0]\n   (x, y), radius = cv2.minEnclosingCircle(cnt)   center = (int(x), int(y))   radius = int(radius)   return center, radius"},
    "Get the smallest circumscribing circle of a contour": {"nl":"Get the smallest circumscribing circle of a contour","code":"def get_min_enclosing_circle(img):   img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n   ret, thresh = cv2.threshold(img_gray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n   cnt = contours[0]\n   (x, y), radius = cv2.minEnclosingCircle(cnt)   center = (int(x), int(y))   radius = int(radius)   return center, radius"},
    "Get the smallest possible enclosing circle for a contour.": {"nl":"Get the smallest possible enclosing circle for a contour.","code":"def get_min_enclosing_circle(img):   img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n   ret, thresh = cv2.threshold(img_gray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n   cnt = contours[0]\n   (x, y), radius = cv2.minEnclosingCircle(cnt)   center = (int(x), int(y))   radius = int(radius)   return center, radius"},
    "Minimum contour enclosing circle": {"nl":"Minimum contour enclosing circle","code":"def get_min_enclosing_circle(img):   img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n   ret, thresh = cv2.threshold(img_gray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n   cnt = contours[0]\n   (x, y), radius = cv2.minEnclosingCircle(cnt)   center = (int(x), int(y))   radius = int(radius)   return center, radius"},
    "Find the smallest circle that fits the\u00a0contour": {"nl":"Find the smallest circle that fits the\u00a0contour","code":"def get_min_enclosing_circle(img):   img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n   ret, thresh = cv2.threshold(img_gray, 127, 255, 0)   contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n   cnt = contours[0]\n   (x, y), radius = cv2.minEnclosingCircle(cnt)   center = (int(x), int(y))   radius = int(radius)   return center, radius"},
    "Get convex defects of a contour": {"nl":"Get convex defects of a contour","code":"\"def show_defects(contours):   cnt = contours[0]   hull = cv2.convexHull(cnt, returnPoints=False)   defects = cv2.convexityDefects(cnt, hull)   return defects\""},
    "Get orientation of a contour": {"nl":"Get orientation of a contour","code":""},
    "Get hull mask of a contour": {"nl":"Get hull mask of a contour","code":"def get_contour_hull_mask(img, contour):   \"\"\"   Get hull mask of a contour   \"\"\"   hull = cv2.convexHull(contour)   mask = np.zeros(img.shape, np.uint8)   cv2.drawContours(mask, [hull], 0, 255, -1)   return mask"},
    " Get hull defects of a contour": {"nl":" Get hull defects of a contour","code":"def get_contour_hull_defects(contour):   \"\"\"   Get hull defects of a contour   \"\"\"   hull = cv2.convexHull(contour, returnPoints=False)   defects = cv2.convexityDefects(contour, hull)   return defects"},
    "Obtain a contour's convex defects.": {"nl":"Obtain a contour's convex defects.","code":""},
    "Obtain the convex defects of a contour.": {"nl":"Obtain the convex defects of a contour.","code":"\"def get_contour_defects(img):   gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n   # Threshold the image   ret, thresh = cv2.threshold(gray, 127, 255, 0)\n   # Find contours   contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n   # Draw contours   img = cv2.drawContours(img, contours, -1, (0, 255, 0), 3)\n   # Find convex hull   hull = [cv2.convexHull(c) for c in contours]\n   # Draw contours + hull results   img = cv2.drawContours(img, hull, -1, (0, 0, 255), 3)\n   # Find convexity defects   defects = [cv2.convexityDefects(c, h) for c, h in zip(contours, hull)]   return defects\""},
    "Determine the convex defects in a contour.": {"nl":"Determine the convex defects in a contour.","code":""},
    "get contour defects": {"nl":"get contour defects","code":"\"def show_defects(contours):   cnt = contours[0]   hull = cv2.convexHull(cnt, returnPoints=False)   defects = cv2.convexityDefects(cnt, hull)   return defects\""},
    "Get convex defects in a contour.": {"nl":"Get convex defects in a contour.","code":"\"def get_contour_defects(img):   gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n   # Threshold the image   ret, thresh = cv2.threshold(gray, 127, 255, 0)\n   # Find contours   contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n   # Draw contours   img = cv2.drawContours(img, contours, -1, (0, 255, 0), 3)\n   # Find convex hull   hull = [cv2.convexHull(c) for c in contours]\n   # Draw contours + hull results   img = cv2.drawContours(img, hull, -1, (0, 0, 255), 3)\n   # Find convexity defects   defects = [cv2.convexityDefects(c, h) for c, h in zip(contours, hull)]   return defects\""},
    "": {"nl":"","code":""},
    "Get hull defects depth of a contour": {"nl":"Get hull defects depth of a contour","code":"def get_contour_hull_defects_depth(contour):   \"\"\"   Get hull defects depth of a contour   \"\"\"   hull = cv2.convexHull(contour, returnPoints=False)   defects = cv2.convexityDefects(contour, hull)   for i in range(defects.shape[0]):       s, e, f, d = defects[i, 0]       return d"},
    "Get hull defects angle of a contour": {"nl":"Get hull defects angle of a contour","code":"def get_contour_hull_defects_angle(contour):   \"\"\"   Get hull defects angle of a contour   \"\"\"   hull = cv2.convexHull(contour, returnPoints=False)   defects = cv2.convexityDefects(contour, hull)   for i in range(defects.shape[0]):       s, e, f, d = defects[i, 0]       start = tuple(contour[s][0])       end = tuple(contour[e][0])       far = tuple(contour[f][0])       a = math.sqrt((end[0] - start[0]) ** 2 + (end[1] - start[1]) ** 2)       b = math.sqrt((far[0] - start[0]) ** 2 + (far[1] - start[1]) ** 2)       c = math.sqrt((end[0] - far[0]) ** 2 + (end[1] - far[1]) ** 2)       angle = math.acos((b ** 2 + c ** 2 - a ** 2) / (2 * b * c)) * 57       return angle"},
    "Get hull defects count of a contour": {"nl":"Get hull defects count of a contour","code":"def get_contour_hull_defects_count(contour):   \"\"\"   Get hull defects count of a contour   \"\"\"   hull = cv2.convexHull(contour, returnPoints=False)   defects = cv2.convexityDefects(contour, hull)   return defects.shape[0]"},
    "Get hull defects points of a contour": {"nl":"Get hull defects points of a contour","code":"\"def get_hull_defects(contours):   cnt = contours[0]\n   hull = cv2.convexHull(cnt, returnPoints=False)   defects = cv2.convexityDefects(cnt, hull)\n   for i in range(defects.shape[0]):       s, e, f, d = defects[i, 0]       start = tuple(cnt[s][0])       end = tuple(cnt[e][0])       far = tuple(cnt[f][0])       cv2.line(img, start, end, [0, 255, 0], 2)       cv2.circle(img, far, 5, [0, 0, 255], -1)\n   cv2.imshow('img', img)   cv2.waitKey(0)   cv2.destroyAllWindows()\""},
    "Identify hull defects in a contour.": {"nl":"Identify hull defects in a contour.","code":"\"def get_hull_defects(contours):   cnt = contours[0]\n   hull = cv2.convexHull(cnt, returnPoints=False)   defects = cv2.convexityDefects(cnt, hull)\n   for i in range(defects.shape[0]):       s, e, f, d = defects[i, 0]       start = tuple(cnt[s][0])       end = tuple(cnt[e][0])       far = tuple(cnt[f][0])       cv2.line(img, start, end, [0, 255, 0], 2)       cv2.circle(img, far, 5, [0, 0, 255], -1)\n   cv2.imshow('img', img)   cv2.waitKey(0)   cv2.destroyAllWindows()\""},
    "Obtain the hull defects points of a contour": {"nl":"Obtain the hull defects points of a contour","code":"\"def get_hull_defects(contours):   cnt = contours[0]\n   hull = cv2.convexHull(cnt, returnPoints=False)   defects = cv2.convexityDefects(cnt, hull)\n   for i in range(defects.shape[0]):       s, e, f, d = defects[i, 0]       start = tuple(cnt[s][0])       end = tuple(cnt[e][0])       far = tuple(cnt[f][0])       cv2.line(img, start, end, [0, 255, 0], 2)       cv2.circle(img, far, 5, [0, 0, 255], -1)\n   cv2.imshow('img', img)   cv2.waitKey(0)   cv2.destroyAllWindows()\""},
    "Obtain hull defect locations along a contour.": {"nl":"Obtain hull defect locations along a contour.","code":"\"def get_hull_defects(contours):   cnt = contours[0]\n   hull = cv2.convexHull(cnt, returnPoints=False)   defects = cv2.convexityDefects(cnt, hull)\n   for i in range(defects.shape[0]):       s, e, f, d = defects[i, 0]       start = tuple(cnt[s][0])       end = tuple(cnt[e][0])       far = tuple(cnt[f][0])       cv2.line(img, start, end, [0, 255, 0], 2)       cv2.circle(img, far, 5, [0, 0, 255], -1)\n   cv2.imshow('img', img)   cv2.waitKey(0)   cv2.destroyAllWindows()\""},
    "Find out the\u00a0hull defects on a contour": {"nl":"Find out the\u00a0hull defects on a contour","code":"def get_hull_defects(contours):      # Find the convex hull object for each contour   hull = [cv2.convexHull(c) for c in contours]\n   # Draw contours + hull results   drawing = np.zeros((thresh.shape[0], thresh.shape[1], 3), dtype=np.uint8)\n   for i in range(len(contours)):       color_contours = (0, 255, 0) # green - color for contours       color = (255, 0, 0) # blue - color for convex hull       # draw ith contour       cv2.drawContours(drawing, contours, i, color_contours, 1, 8, hierarchy)       # draw ith convex hull object       cv2.drawContours(drawing, hull, i, color, 1, 8)\n   cv2.imshow('Output', drawing)   cv2.waitKey(0)   cv2.destroyAllWindows()"},
    "Find contour hull defects": {"nl":"Find contour hull defects","code":"\"\"\"def get_hull_defects(contour, hull):   hull_defects = cv2.convexityDefects(contour, hull)   hull_defects_points = []   for i in range(hull_defects.shape[0]):       s, e, f, d = hull_defects[i, 0]       start = tuple(contour[s][0])       end = tuple(contour[e][0])       far = tuple(contour[f][0])       hull_defects_points.append([start, end, far])   return hull_defects_points\"\"\""},
    "Shift the channels randomly": {"nl":"Shift the channels randomly","code":"def random_shift_channels(img):   img_copy = img.copy()   channels = cv2.split(img_copy)   random.shuffle(channels)   return cv2.merge(channels)"},
    "Change the saturation of image randomly": {"nl":"Change the saturation of image randomly","code":"def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):   if np.random.random() < u:       x = random_channel_shift(image, np.random.uniform(lower, upper))       y = random_channel_shift(mask, np.random.uniform(lower, upper))   else:       x = image       y = mask   return x, y"},
    "Add random noise to an image": {"nl":"Add random noise to an image","code":"def add_noise(img, noise_type, sigma):   if noise_type == \"gauss\":       row, col, ch = img.shape       mean = 0       gauss = np.random.normal(mean, sigma, (row, col, ch))       gauss = gauss.reshape(row, col, ch)       noisy = img + gauss       return noisy   elif noise_type == \"s&p\":       row, col, ch = img.shape       s_vs_p = 0.5       amount = 0.004       out = np.copy(img)       # Salt mode       num_salt = np.ceil(amount * img.size * s_vs_p)       coords = [np.random.randint(0, i - 1, int(num_salt))                 for i in img.shape]       out[coords] = 1\n       # Pepper mode       num_pepper = np.ceil(amount * img.size * (1. - s_vs_p))       coords = [np.random.randint(0, i - 1, int(num_pepper))                 for i in img.shape]       out[coords] = 0       return out   elif noise_type == \"poisson\":       vals = len(np.unique(img))       vals = 2 ** np.ceil(np.log2(vals))       noisy = np.random.poisson(img * vals) / float(vals)       return noisy   elif noise_type == \"speckle\":       row, col, ch = img.shape       gauss = np.random.randn(row, col, ch)       gauss = gauss.reshape(row, col, ch)       noisy = img + img * gauss       return noisy"},
    "Randomly flip an image horizontally": {"nl":"Randomly flip an image horizontally","code":"def random_flip_horizontal(image):   if np.random.rand() < 0.5:       image = cv2.flip(image, 1)   return image"},
    "Image horizontal flipping at random": {"nl":"Image horizontal flipping at random","code":"def random_flip_horizontal(image):   if np.random.rand() < 0.5:       image = cv2.flip(image, 1)   return image"},
    "Randomly flip an image in the horizontal direction.": {"nl":"Randomly flip an image in the horizontal direction.","code":"def flip_image(image, label):   if random.random() < 0.5:       image = cv2.flip(image, 1)       label = cv2.flip(label, 1)   return image, label\n"},
    "Horizontally flip an image randomly": {"nl":"Horizontally flip an image randomly","code":"def random_flip_horizontal(image):   if np.random.rand() < 0.5:       image = cv2.flip(image, 1)   return image"},
    "Flip an image horizontally at random": {"nl":"Flip an image horizontally at random","code":"def random_flip_horizontal(image):   if np.random.rand() < 0.5:       image = cv2.flip(image, 1)   return image"},
    "Randomly flip an image vertically": {"nl":"Randomly flip an image vertically","code":"def random_flip_vertical(image, mask):   if np.random.rand() < 0.5:       image = cv2.flip(image, 0)       mask = cv2.flip(mask, 0)   return image, mask"},
    "Vertically flip an image at random": {"nl":"Vertically flip an image at random","code":"def vertical_flip(image, mask):   if np.random.random() < 0.5:       image = image[::-1, :]       mask = mask[::-1, :]   return image, mask"},
    "Flip an image vertically at random.": {"nl":"Flip an image vertically at random.","code":"def vertical_flip(image, mask):   if np.random.random() < 0.5:       image = image[::-1, :]       mask = mask[::-1, :]   return image, mask"},
    "Vertically flip an image randomly": {"nl":"Vertically flip an image randomly","code":"def random_flip_vertical(image, mask):   if np.random.rand() < 0.5:       image = cv2.flip(image, 0)       mask = cv2.flip(mask, 0)   return image, mask"},
    "Randomly flip an image in the vertical direction": {"nl":"Randomly flip an image in the vertical direction","code":"def random_flip_vertical(image, mask):   if np.random.rand() < 0.5:       image = cv2.flip(image, 0)       mask = cv2.flip(mask, 0)   return image, mask"},
    "Image vertial flipping at random": {"nl":"Image vertial flipping at random","code":""},
    "Randomly crop image": {"nl":"Randomly crop image","code":"def crop_image(img, crop_size):   h, w, _ = img.shape   x = random.randint(0, w - crop_size)   y = random.randint(0, h - crop_size)   return img[y:y+crop_size, x:x+crop_size, :]"},
    "random image crop": {"nl":"random image crop","code":"def crop_image(img, crop_size):   h, w, _ = img.shape   x = random.randint(0, w - crop_size)   y = random.randint(0, h - crop_size)   return img[y:y+crop_size, x:x+crop_size, :]"},
    "Crop an image at random": {"nl":"Crop an image at random","code":"def crop_image(img, crop_size):   h, w, _ = img.shape   top = np.random.randint(0, h - crop_size[0])   left = np.random.randint(0, w - crop_size[1])   bottom = top + crop_size[0]   right = left + crop_size[1]   return img[top:bottom, left:right, :]"},
    "Image cropped at random": {"nl":"Image cropped at random","code":"def crop_image(img, crop_size):   h, w, _ = img.shape   top = np.random.randint(0, h - crop_size[0])   left = np.random.randint(0, w - crop_size[1])   bottom = top + crop_size[0]   right = left + crop_size[1]   return img[top:bottom, left:right, :]"},
    "Crop the image randomly with given crop size": {"nl":"Crop the image randomly with given crop size","code":"def crop_image(img, crop_size):   h, w, _ = img.shape   top = np.random.randint(0, h - crop_size[0])   left = np.random.randint(0, w - crop_size[1])   bottom = top + crop_size[0]   right = left + crop_size[1]   return img[top:bottom, left:right, :]"},
    "Image cropped in a random way": {"nl":"Image cropped in a random way","code":"def crop_image(img, crop_size):   h, w, _ = img.shape   top = np.random.randint(0, h - crop_size[0])   left = np.random.randint(0, w - crop_size[1])   bottom = top + crop_size[0]   right = left + crop_size[1]   return img[top:bottom, left:right, :]"},
    "Crop image randomly": {"nl":"Crop image randomly","code":"def random_crop(img, random_crop_size):   assert img.shape[2] == 3   height, width = img.shape[0], img.shape[1]   dy, dx = random_crop_size   x = np.random.randint(0, width - dx + 1)   y = np.random.randint(0, height - dy + 1)   return img[y:(y+dy), x:(x+dx), :]\n"},
    "Randomly shear an image": {"nl":"Randomly shear an image","code":"def random_shear(img, shear_range):   rows, cols, ch = img.shape   dx = np.random.randint(-shear_range, shear_range + 1)   random_point = [cols / 2 + dx, rows / 2]   pts1 = np.float32([[0, rows], [cols, rows], [cols / 2, rows / 2]])   pts2 = np.float32([[0, rows], [cols, rows], random_point])   dsteering = dx / (rows / 2) * 360 / (2 * np.pi * 25.0) / 6.0   M = cv2.getAffineTransform(pts1, pts2)   img = cv2.warpAffine(img, M, (cols, rows), borderMode=1)   return img, dsteering"},
    "random image shearing": {"nl":"random image shearing","code":"def random_shear(img, shear_range):   rows, cols, ch = img.shape   dx = np.random.randint(-shear_range, shear_range + 1)   random_point = [cols / 2 + dx, rows / 2]   pts1 = np.float32([[0, rows], [cols, rows], [cols / 2, rows / 2]])   pts2 = np.float32([[0, rows], [cols, rows], random_point])   dsteering = dx / (rows / 2) * 360 / (2 * np.pi * 25.0) / 6.0   M = cv2.getAffineTransform(pts1, pts2)   img = cv2.warpAffine(img, M, (cols, rows), borderMode=1)   return img, dsteering"},
    "Shear an image randomly": {"nl":"Shear an image randomly","code":"def random_shear(image, mask, intensity):   shear = np.random.uniform(-intensity, intensity)   shear_matrix = np.array([[1, -np.sin(shear), 0], [0, np.cos(shear), 0], [0, 0, 1]])   h, w = image.shape[0], image.shape[1]   transform_matrix = transform.AffineTransform(shear_matrix)   image = transform.warp(image, transform_matrix, mode='edge')   mask = transform.warp(mask, transform_matrix, mode='edge')   return image, mask"},
    "Image shear randomly": {"nl":"Image shear randomly","code":"def random_shear(image, mask, intensity):   shear = np.random.uniform(-intensity, intensity)   shear_matrix = np.array([[1, -np.sin(shear), 0], [0, np.cos(shear), 0], [0, 0, 1]])   h, w = image.shape[0], image.shape[1]   transform_matrix = transform.AffineTransform(shear_matrix)   image = transform.warp(image, transform_matrix, mode='edge')   mask = transform.warp(mask, transform_matrix, mode='edge')   return image, mask"},
    "Randomly zoom an image": {"nl":"Randomly zoom an image","code":"def zoom(img, zoom_factor):   height, width = img.shape[:2]   new_height, new_width = int(height * zoom_factor), int(width * zoom_factor)   y1, x1 = random.randint(0, height - new_height), random.randint(0, width - new_width)   y2, x2 = y1 + new_height, x1 + new_width   bbox = np.array([y1, x1, y2, x2])   bbox = bbox.astype(np.float32)   return img[y1:y2, x1:x2], bbox"},
    "Zoom an image randomly": {"nl":"Zoom an image randomly","code":"def zoom(img, zoom_factor):   height, width = img.shape[:2]   new_height, new_width = int(height * zoom_factor), int(width * zoom_factor)   y1, x1 = random.randint(0, height - new_height), random.randint(0, width - new_width)   y2, x2 = y1 + new_height, x1 + new_width   bbox = np.array([y1, x1, y2, x2])   bbox = bbox.astype(np.float32)   return img[y1:y2, x1:x2], bbox"},
    "Zoom in on an image at random": {"nl":"Zoom in on an image at random","code":"def zoom(img, zoom_factor):   height, width = img.shape[:2]   new_height, new_width = int(height * zoom_factor), int(width * zoom_factor)   y1, x1 = random.randint(0, height - new_height), random.randint(0, width - new_width)   y2, x2 = y1 + new_height, x1 + new_width   bbox = np.array([y1, x1, y2, x2])   bbox = bbox.astype(np.float32)   return img[y1:y2, x1:x2], bbox"},
    "Create a random zoom effect on an image": {"nl":"Create a random zoom effect on an image","code":"def zoom(img, zoom_factor):   height, width = img.shape[:2]   new_height, new_width = int(height * zoom_factor), int(width * zoom_factor)   y1, x1 = random.randint(0, height - new_height), random.randint(0, width - new_width)   y2, x2 = y1 + new_height, x1 + new_width   bbox = np.array([y1, x1, y2, x2])   bbox = bbox.astype(np.float32)   return img[y1:y2, x1:x2], bbox"},
    "Zoom randomly": {"nl":"Zoom randomly","code":"def zoom(img, zoom_factor):   height, width = img.shape[:2]   new_height, new_width = int(height * zoom_factor), int(width * zoom_factor)   y1, x1 = random.randint(0, height - new_height), random.randint(0, width - new_width)   y2, x2 = y1 + new_height, x1 + new_width   bbox = np.array([y1, x1, y2, x2])   bbox = bbox.astype(np.float32)   return img[y1:y2, x1:x2], bbox"},
    "Change the brighntess of image randomly": {"nl":"Change the brighntess of image randomly","code":"def decrease_brightness(img):   M = np.ones(img.shape, dtype=\"\"uint8\"\") * 100   subtracted = cv2.subtract(img, M)   return subtracted"},
    "Randomly alter the brightness of the image": {"nl":"Randomly alter the brightness of the image","code":"def decrease_brightness(img):   M = np.ones(img.shape, dtype=\"uint8\") * 100   subtracted = cv2.subtract(img, M)   return subtracted"},
    "Alter the image's brighntess at random": {"nl":"Alter the image's brighntess at random","code":"def decrease_brightness(img):   M = np.ones(img.shape, dtype=\"uint8\") * 100   subtracted = cv2.subtract(img, M)   return subtracted"},
    "Randomly change the brightness of an image": {"nl":"Randomly change the brightness of an image","code":"def random_brightness(image):   hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)   ratio = 1.0 + 0.4 * (np.random.rand() - 0.5)   hsv[:,:,2] =  hsv[:,:,2] * ratio   return cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)"},
    "Randomly adjust the image's brightness": {"nl":"Randomly adjust the image's brightness","code":"def decrease_brightness(img):   M = np.ones(img.shape, dtype=\"\"uint8\"\") * 100   subtracted = cv2.subtract(img, M)   return subtracted"},
    "Randomly tweak the brightness of the image": {"nl":"Randomly tweak the brightness of the image","code":"def decrease_brightness(img):   M = np.ones(img.shape, dtype=\"uint8\") * 100   subtracted = cv2.subtract(img, M)   return subtracted"},
    "Randomize image brightness": {"nl":"Randomize image brightness","code":"def decrease_brightness(img):   M = np.ones(img.shape, dtype=\"uint8\") * 100   subtracted = cv2.subtract(img, M)   return subtracted"},
    "Shift the channels of image randomly": {"nl":"Shift the channels of image randomly","code":"def random_channel_shift(x, intensity, channel_index=0):   x = np.rollaxis(x, channel_index, 0)   min_x, max_x = np.min(x), np.max(x)   channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)                     for x_channel in x]   x = np.stack(channel_images, axis=0)   x = np.rollaxis(x, 0, channel_index+1)   return x"},
    "Randomly shift\u00a0the image channels": {"nl":"Randomly shift\u00a0the image channels","code":"def random_shift_channels(img):   img_copy = img.copy()   channels = cv2.split(img_copy)   random.shuffle(channels)   return cv2.merge(channels)"},
    "Randomly shift the channels of an image": {"nl":"Randomly shift the channels of an image","code":"def random_shift_channels(img):   img_copy = img.copy()   channels = cv2.split(img_copy)   random.shuffle(channels)   return cv2.merge(channels)"},
    "randomise the image channel shift": {"nl":"randomise the image channel shift","code":"def random_shift_channels(img):   img_copy = img.copy()   channels = cv2.split(img_copy)   random.shuffle(channels)   return cv2.merge(channels)"},
    "Randomise the shift of the image channels": {"nl":"Randomise the shift of the image channels","code":"def random_shift_channels(img):   img_copy = img.copy()   channels = cv2.split(img_copy)   random.shuffle(channels)   return cv2.merge(channels)"},
    "Change the contrast of image randomly": {"nl":"Change the contrast of image randomly","code":"def randomize_contrast(image, min_factor=0.5, max_factor=1.5):   factor = np.random.uniform(min_factor, max_factor)   image = image.astype(np.float32)   image *= factor   return image"},
    "Randomly change the image's contrast": {"nl":"Randomly change the image's contrast","code":"def randomize_contrast(image, min_factor=0.5, max_factor=1.5):   factor = np.random.uniform(min_factor, max_factor)   image = image.astype(np.float32)   image *= factor   return image"},
    "Change the image's contrast at random": {"nl":"Change the image's contrast at random","code":"def randomize_contrast(image, min_factor=0.5, max_factor=1.5):   factor = np.random.uniform(min_factor, max_factor)   image = image.astype(np.float32)   image *= factor   return image"},
    "Change the image's contrast in a random way.": {"nl":"Change the image's contrast in a random way.","code":"def randomize_contrast(image, min_factor=0.5, max_factor=1.5):   factor = np.random.uniform(min_factor, max_factor)   image = image.astype(np.float32)   image *= factor   return image"},
    "Alter the image's contrast at random": {"nl":"Alter the image's contrast at random","code":"def randomize_contrast(image, min_factor=0.5, max_factor=1.5):   factor = np.random.uniform(min_factor, max_factor)   image = image.astype(np.float32)   image *= factor   return image"},
    "Randomize image contrast": {"nl":"Randomize image contrast","code":"def change_contrast(img, contrast_factor):   img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)   img_hsv[:, :, 2] = img_hsv[:, :, 2] * contrast_factor   img_bgr = cv2.cvtColor(img_hsv, cv2.COLOR_HSV2BGR)   return img_bgr"},
    "Randomly alter the image's contrast": {"nl":"Randomly alter the image's contrast","code":"def randomize_contrast(image, min_factor=0.5, max_factor=1.5):   factor = np.random.uniform(min_factor, max_factor)   image = image.astype(np.float32)   image *= factor   return image"},
    "Adjust the saturation of image randomly": {"nl":"Adjust the saturation of image randomly","code":"def random_saturation(img, lower=0.5, upper=1.5):   img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)   img = np.array(img, dtype=np.float32)   random_scale = np.random.uniform(lower, upper)   img[:, :, 1] = img[:, :, 1] * random_scale   img[:, :, 1][img[:, :, 1] > 255] = 255   img = np.array(img, dtype=np.uint8)   img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)   return img"},
    "Randomly alter the image's saturation": {"nl":"Randomly alter the image's saturation","code":"def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):   if np.random.random() < u:       x = random_channel_shift(image, np.random.uniform(lower, upper))       y = random_channel_shift(mask, np.random.uniform(lower, upper))   else:       x = image       y = mask   return x, y"},
    "Randomly change the image's saturation": {"nl":"Randomly change the image's saturation","code":"def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):   if np.random.random() < u:       x = random_channel_shift(image, np.random.uniform(lower, upper))       y = random_channel_shift(mask, np.random.uniform(lower, upper))   else:       x = image       y = mask   return x, y"},
    "Randomly set the image's saturation": {"nl":"Randomly set the image's saturation","code":"def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):   if np.random.random() < u:       x = random_channel_shift(image, np.random.uniform(lower, upper))       y = random_channel_shift(mask, np.random.uniform(lower, upper))   else:       x = image       y = mask   return x, y"},
    "Randomly adjust the image's saturation": {"nl":"Randomly adjust the image's saturation","code":"def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):   if np.random.random() < u:       x = random_channel_shift(image, np.random.uniform(lower, upper))       y = random_channel_shift(mask, np.random.uniform(lower, upper))   else:       x = image       y = mask   return x, y"},
    "Change\u00a0the saturation of an image at random": {"nl":"Change\u00a0the saturation of an image at random","code":"def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):   if np.random.random() < u:       x = random_channel_shift(image, np.random.uniform(lower, upper))       y = random_channel_shift(mask, np.random.uniform(lower, upper))   else:       x = image       y = mask   return x, y"},
    "Randomize image saturation": {"nl":"Randomize image saturation","code":"def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):   if np.random.random() < u:       x = random_channel_shift(image, np.random.uniform(lower, upper))       y = random_channel_shift(mask, np.random.uniform(lower, upper))   else:       x = image       y = mask   return x, y"},
    "Alter the image saturation randomly": {"nl":"Alter the image saturation randomly","code":"def random_saturation(image, mask, lower=0.5, upper=1.5, u=0.5):   if np.random.random() < u:       x = random_channel_shift(image, np.random.uniform(lower, upper))       y = random_channel_shift(mask, np.random.uniform(lower, upper))   else:       x = image       y = mask   return x, y"},
    "Alter the saturation of image randomly": {"nl":"Alter the saturation of image randomly","code":"def random_saturation(img, lower=0.5, upper=1.5):   img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)   img = np.array(img, dtype=np.float32)   random_scale = np.random.uniform(lower, upper)   img[:, :, 1] = img[:, :, 1] * random_scale   img[:, :, 1][img[:, :, 1] > 255] = 255   img = np.array(img, dtype=np.uint8)   img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)   return img"},
    "Set the image saturation randomly": {"nl":"Set the image saturation randomly","code":"def random_saturation(img, lower=0.5, upper=1.5):   img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)   img = np.array(img, dtype=np.float32)   random_scale = np.random.uniform(lower, upper)   img[:, :, 1] = img[:, :, 1] * random_scale   img[:, :, 1][img[:, :, 1] > 255] = 255   img = np.array(img, dtype=np.uint8)   img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)   return img"},
    "Set the saturation of image randomly": {"nl":"Set the saturation of image randomly","code":"def random_saturation(img, lower=0.5, upper=1.5):   img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)   img = np.array(img, dtype=np.float32)   random_scale = np.random.uniform(lower, upper)   img[:, :, 1] = img[:, :, 1] * random_scale   img[:, :, 1][img[:, :, 1] > 255] = 255   img = np.array(img, dtype=np.uint8)   img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)   return img"},
    "Adjust the image saturation randomly": {"nl":"Adjust the image saturation randomly","code":"def random_saturation(img, lower=0.5, upper=1.5):   img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)   img = np.array(img, dtype=np.float32)   random_scale = np.random.uniform(lower, upper)   img[:, :, 1] = img[:, :, 1] * random_scale   img[:, :, 1][img[:, :, 1] > 255] = 255   img = np.array(img, dtype=np.uint8)   img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR)   return img"
    }
}